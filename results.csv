"id","experiment_name","problem_name","problem_category","problem_complexity","attempt","generated_code","tokens_used","ms_to_generate","temperature","topp","model_name","case_name","case_complexity","error","is_correct","result","sh_style_cnt","sh_info_cnt","sh_warning_cnt","sh_error_cnt","sh_output","score","mistake_reason","type","problem_desc","code_complexity"
7792,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child PIDs recursively using ps;child_pids=$(ps --ppid ""$parent_pid"" -o pid --no-headers | xargs);;# Function to recursively get all descendants;get_descendants() {; local children=$(ps --ppid ""$1"" -o pid --no-headers); for pid in $children; do; echo ""$pid""; get_descendants ""$pid""; done;};;# Get all descendant PIDs;all_pids=""$parent_pid $(get_descendants ""$parent_pid"")"";;# Find all script processes among children;for pid in $all_pids; do; # Get the command line and check if it's a script; if [[ -f ""/proc/$pid/cmdline"" ]]; then; cmdline=$(tr '\0' ' ' < ""/proc/$pid/cmdline""); if [[ ""$cmdline"" =~ \.sh(\ |$) ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name""; fi; fi;done | sort -u",418,"23322.989225387573","0","0.1","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,2,0,"Line 12: child_pids appears unused. Verify use (or export if used externally). Line 16: Declare and assign separately to avoid masking return values. ","1.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
9430,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"# Dump the MySQL database over a compressed SSH tunnel
ssh -C $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip > /tmp/test_db_dump.sql.gz

# Transfer the compressed dump file back to local machine
scp $1:/tmp/test_db_dump.sql.gz /tmp/

# Import the dump file to local MySQL
gunzip < /tmp/test_db_dump.sql.gz | mysql -u TEST_USER -pTEST TEST_DB",102,"3158.7865352630615","0.7","0.9","gpt-3.5-turbo","jāpārnes datubāze",1,"mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces scp: /tmp/test_db_dump.sql.gz: No such file or directory mysql: [Warning] Using a password on the command line interface can be insecure. ",False,"The data was not transferred to the other database",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. Line 6: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","13.05"
8820,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87};echo",18,"1969.2349433898926","0","0.1","gpt-4o","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
5319,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | sort | awk 'seen[$1]++' | cut -d' ' -f3- | xargs -I{} grep "" {}"" <(find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} +)",729,"8961.753606796265","0.2","0.4","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5298,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | sort -k 1,1",43,"1483.5917949676514","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.9"
7082,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash;apt-get update && apt-get install -y build-essential autoconf automake libncurses-dev wget;mkdir -p /usr/local/htop310;wget -O /tmp/htop-3.1.0.tar.gz https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz;tar -xzf /tmp/htop-3.1.0.tar.gz -C /tmp;cd /tmp/htop-3.1.0;autoreconf -i;./configure --prefix=/usr/local/htop310;make && make install;echo 'export PATH=$PATH:/usr/local/htop310/bin' > /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh",742,"40997.99919128418","0.7","0.9","deepseek-r1","Jāinstalē htop 3.1.0",1,"is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:547: warning: configure is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' ",False,"Htop was installed but not added to path",0,1,1,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 10: Expressions don't expand in single quotes, use double quotes for that. ","5.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","20.849999999999994"
8520,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8521,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8913,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",37,"950.6838321685791","0.2","0.4","gpt-3.5-turbo","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
7758,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Enable extended globbing;shopt -s extglob;;# Get the PID of exec.sh;exec_pid=$(pgrep -f ""^/bin/bash ./exec.sh$"");;# Use pstree to list all child processes of exec.sh and filter out script names;if [ -n ""$exec_pid"" ]; then; pstree -p $exec_pid | grep -oP '(?<=\().*?(?=\))' | while read pid; do; # Check if the process is a script; cmd=$(ps -o args= -p $pid); if [[ $cmd == */bin/bash* ]]; then; echo $(basename $(echo $cmd | awk '{print $2}')); fi; done | sort -u;fi",170,"3563.2452964782715","0.7","0.9","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",1,2,1,0,"Line 11: Double quote to prevent globbing and word splitting. Line 11: read without -r will mangle backslashes. Line 13: Double quote to prevent globbing and word splitting. Line 15: Quote this to prevent word splitting. Line 15: Useless echo? Instead of 'echo $(cmd)', just use 'cmd'. Line 15: Quote this to prevent word splitting. Line 15: Double quote to prevent globbing and word splitting. ","0.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8821,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87};echo",18,"952.9356956481934","0.2","0.4","gpt-4o","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
7313,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"2189.7037029266357","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7705,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}(?=\/)' | grep -v '127.0.0.1' | head -n 1 | awk '{print ""IP: "" $1}';ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}(?=\/)' | head -n 1 | awk '{print ""IP: "" $1}'",181,"13967.5874710083","0.7","0.9","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","24.33"
8522,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5324,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | sort | awk ';{; arr[$1]=arr[$1] $2 ""\n""; count[$1]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""MD5: %s\nFiles:\n%s"", md5, arr[md5]; }; };}'",501,"5731.551170349121","0.7","0.9","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","10.100000000000001"
5326,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2660.7203483581543","0","0.1","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5289,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}'",41,"1579.352855682373","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
7402,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1043,"56745.805740356445","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
9268,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ';FNR == NR {; file1[$1] = substr($0, index($0, "" "") + 1); next;};{; file2[$1] = substr($0, index($0, "" "") + 1);};END {; # Merge lines where key exists in both files; for (key in file1) {; if (key in file2) {; merged[key] = key "" "" file1[key] "" "" file2[key]; } else {; merged[key] = key "" "" file1[key]; }; }; # Add keys only in file2; for (key in file2) {; if (!(key in file1)) {; merged[key] = key "" "" file2[key]; }; }; # Print ""Exe"" lines first, then others; PROCINFO[""sorted_in""] = ""@ind_str_asc""; for (key in merged) {; if (key ~ /^Exe/) print merged[key]; }; for (key in merged) {; if (key !~ /^Exe/) print merged[key]; };}' GHJ1.txt GHJ2.txt",3020,"145905.60793876648","0.2","0.4","deepseek-r1","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","16.53"
5314,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | awk '{; md5=$1; filename=substr($0, 35); if (count[md5]++) {; files[md5] = files[md5] ""\n"" filename; } else {; files[md5] = filename; };};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""Duplicate MD5: %s\nFiles:\n%s\n\n"", md5, files[md5]; }; };}'",1983,"27636.147499084473","0","0.1","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","12.24"
7543,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1666.1195755004883","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
6983,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash;;# Install build dependencies;apt update && apt install -y build-essential autoconf automake libncurses-dev;;# Create build directory;mkdir -p /usr/local/htop310;cd /usr/local/htop310;;# Download and extract htop;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz;tar xzf htop-3.1.0.tar.gz;cd htop-3.1.0;;# Build and install;./autogen.sh;./configure --prefix=/usr/local/htop310;make;make install;;# Add to PATH;echo 'export PATH=/usr/local/htop310/bin:$PATH' >> /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh;source /etc/profile.d/htop310.sh",214,"13691.036939620972","0.7","0.9","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,1,0,"Line 8: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 13: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 22: Expressions don't expand in single quotes, use double quotes for that. Line 24: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","4.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","20.349999999999998"
8523,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5084,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7420,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",126,"11078.189373016357","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
9110,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3457.7078819274902","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
7421,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",126,"11078.189373016357","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5722,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2-);echo ""$USERNAME""",135,"11084.251880645752","0.2","0.4","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
9255,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt and store data (skip Exe line);while read -r line; do; if [[ $line == Exe* ]]; then; exe_line=$line; else; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$line; fi;done < GHJ1.txt;;# Read GHJ2.txt and store data;while read -r line; do; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$line;done < GHJ2.txt;;# Print the table header (Exe line);echo ""$exe_line"";;# Print merged data;for key in ""${!file1_data[@]}""; do; if [[ -n ""${file2_data[$key]}"" ]]; then; # Merge lines when key exists in both files; line1=""${file1_data[$key]}""; line2=""${file2_data[$key]}""; echo ""$line1 $line2"" | awk '{; printf ""%s "", $1; for (i=2;i<=NF;i++) if ($i != $1) printf ""%s "", $i; print """"; }' | sed 's/ $//'; else; # Just print line from file1 if no match in file2; echo ""${file1_data[$key]}""; fi;done;;# Print lines from file2 that weren't in file1;for key in ""${!file2_data[@]}""; do; if [[ -z ""${file1_data[$key]}"" ]]; then; echo ""${file2_data[$key]}""; fi;done",533,"29460.139751434326","0.2","0.4","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","69.96000000000001"
7422,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",126,"11078.189373016357","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5315,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | awk ';{; md5=$1; filename=$0; sub(/^[^ ]* /, """", filename) # Properly remove MD5 and spaces to get filename; if (md5 in count) {; files[md5] = files[md5] ""\n"" filename; } else {; files[md5] = filename; }; count[md5]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""Duplicate MD5: %s\nFiles:\n%s\n\n"", md5, files[md5]; }; };}'",1447,"14552.286386489868","0","0.1","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","14.14"
6410,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",58,"1978.9774417877197","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.5100000000000002"
8657,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
7445,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -28 -print",23,"1766.9649124145508","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7711,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: "" $4}'",36,"1062.5133514404297","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"Only output the one address after *IP: * in one line",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.24"
8659,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
9272,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; grep -v '^Exe' GHJ1.txt GHJ2.txt | awk '; {; if (FILENAME == ""GHJ1.txt"") {; data1[$1] = $0; } else {; data2[$1] = $0; }; }; END {; for (key in data1) {; if (key in data2) {; print data1[key], data2[key]; } else {; print data1[key]; }; }; for (key in data2) {; if (!(key in data1)) {; print data2[key]; }; }; }';} | column -t",159,"4671.80061340332","0","0.1","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","5.35"
5332,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -D",105,"4109.872102737427","0.2","0.4","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
7486,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade | grep -q ""htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",38,"1469.512939453125","0.7","0.9","llama3.3-70b","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
9115,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = ******; FS = *\n*; counter = 0; other = 0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",242,"5487.3902797698975","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","13.04"
6988,"Experiment 1","InstallHtop","IaC",3,2,"# Install required build tools
apt update
apt install -y build-essential

# Download the source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir -p /usr/local/htop310
tar -xzf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310 || exit
./autogen.sh
./configure
make
make install

# Add htop binary to the system path
ln -sf /usr/local/bin/htop /usr/local/htop310/htop

# Clean up
rm htop-3.1.0.tar.gz",189,"2666.72945022583","0.2","0.4","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"d. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' rm: cannot remove 'htop-3.1.0.tar.gz': No such file or directory ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","15.9"
9121,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS=******; FS=*\n*; counter=0; other=0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",245,"5788.65122795105","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.7"
9164,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum (for quick comparison); size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device and inode; unique_id=""${device}:${inode}""; # Store file path with its unique_id, size, and checksum; echo ""$file"" >> ""$tmpdir/files_${unique_id}_${size}_${checksum}.txt"";done;;# Now compare files with same size and initial checksum;find ""$tmpdir"" -type f -name 'files_*.txt' | while read -r group; do; # Get the first file in the group; first_file=$(head -n 1 ""$group""); # If we have multiple files or the checksum file has multiple entries; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Verify with full checksum if needed; full_md5=$(md5sum ""$first_file"" | cut -d' ' -f1); same_files=(""$first_file""); # Compare with other files in the group; while read -r other_file; do; if [ ""$other_file"" != ""$first_file"" ]; then; other_md5=$(md5sum ""$other_file"" | cut -d' ' -f1); if [ ""$full_md5"" = ""$other_md5"" ]; then;  same_files+=(""$other_file""); fi; fi; done < ""$group""; # If we found duplicates, print them; if [ ${#same_files[@]} -gt 1 ]; then; echo ""${same_files[@]}""; fi; fi;done;;# Clean up;rm -rf ""$tmpdir""",689,"37179.93760108948","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,1,0,"Line 29: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
8524,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
9252,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS=' ' read -r key rest; do; file1_data[""$key""]=""$rest"";done < GHJ1.txt;;# Read GHJ2.txt;while IFS=' ' read -r key rest; do; file2_data[""$key""]=""$rest"";done < GHJ2.txt;;# Print header;printf ""%-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"";echo ""--------------------------------------------------------"";;# First print the ""Exe"" line if it exists in either file;if [[ -n ""${file1_data[Exe]}"" || -n ""${file2_data[Exe]}"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""Exe"" ""${file1_data[Exe]}"" ""${file2_data[Exe]}"";fi;;# Print all other keys (excluding Exe);for key in ""${!file1_data[@]}"" ""${!file2_data[@]}""; do; if [[ ""$key"" != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}""; fi;done | sort -u",466,"25069.290161132812","0","0.1","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","41.9"
5065,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5342,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d -w 32 | cut -c 1-32",43,"1377.6211738586426","0.2","0.4","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.9"
7480,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if [ $(apt-get -s upgrade htop | grep -c ""htop"") -gt 0 ]; then
 echo ""update needed""
else
 echo ""update not needed""
fi",47,"2267.204523086548","0","0.1","llama3.3-70b","Ir vecāka versija",1,"",False,"",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","6.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
9165,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum (for quick comparison); size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device and inode; unique_id=""${device}:${inode}""; # Store file path with its unique_id, size, and checksum; echo ""$file"" >> ""$tmpdir/files_${unique_id}_${size}_${checksum}.txt"";done;;# Now compare files with same size and initial checksum;find ""$tmpdir"" -type f -name 'files_*.txt' | while read -r group; do; # Get the first file in the group; first_file=$(head -n 1 ""$group""); # If we have multiple files or the checksum file has multiple entries; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Verify with full checksum if needed; full_md5=$(md5sum ""$first_file"" | cut -d' ' -f1); same_files=(""$first_file""); # Compare with other files in the group; while read -r other_file; do; if [ ""$other_file"" != ""$first_file"" ]; then; other_md5=$(md5sum ""$other_file"" | cut -d' ' -f1); if [ ""$full_md5"" = ""$other_md5"" ]; then;  same_files+=(""$other_file""); fi; fi; done < ""$group""; # If we found duplicates, print them; if [ ${#same_files[@]} -gt 1 ]; then; echo ""${same_files[@]}""; fi; fi;done;;# Clean up;rm -rf ""$tmpdir""",689,"37179.93760108948","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,1,0,"Line 29: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
8892,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo *result = $(echo *$line* | rev)* done < *info.txt*",34,"1650.8007049560547","0","0.1","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
5344,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d -w 32 | cut -c 1-32",48,"1302.3710250854492","0.2","0.4","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9"
9106,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3459.446907043457","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
8863,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1753.9944648742676","0.7","0.9","llama3.3-70b","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
9166,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum (for quick comparison); size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device and inode; unique_id=""${device}:${inode}""; # Store file path with its unique_id, size, and checksum; echo ""$file"" >> ""$tmpdir/files_${unique_id}_${size}_${checksum}.txt"";done;;# Now compare files with same size and initial checksum;find ""$tmpdir"" -type f -name 'files_*.txt' | while read -r group; do; # Get the first file in the group; first_file=$(head -n 1 ""$group""); # If we have multiple files or the checksum file has multiple entries; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Verify with full checksum if needed; full_md5=$(md5sum ""$first_file"" | cut -d' ' -f1); same_files=(""$first_file""); # Compare with other files in the group; while read -r other_file; do; if [ ""$other_file"" != ""$first_file"" ]; then; other_md5=$(md5sum ""$other_file"" | cut -d' ' -f1); if [ ""$full_md5"" = ""$other_md5"" ]; then;  same_files+=(""$other_file""); fi; fi; done < ""$group""; # If we found duplicates, print them; if [ ${#same_files[@]} -gt 1 ]; then; echo ""${same_files[@]}""; fi; fi;done;;# Clean up;rm -rf ""$tmpdir""",689,"37179.93760108948","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 29: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
5061,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
9167,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and full checksum; size=$(stat -c '%s' ""$file""); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and checksum; unique_id=""${device}:${inode}:${size}:${checksum}""; # Store file path with its unique_id; echo ""$file"" >> ""$tmpdir/${unique_id}.txt"";done;;# Process each group of potentially identical files;find ""$tmpdir"" -type f -name '*.txt' -print0 | while IFS= read -r -d $'\0' group; do; # Count files in this group; count=$(wc -l < ""$group""); # If we have multiple files, print them; if [ ""$count"" -gt 1 ]; then; # Read all files in the group into an array; mapfile -t files < ""$group""; # Print all files in the group on one line; printf '%s\n' ""${files[*]}""; fi;done;;# Clean up;rm -rf ""$tmpdir""",512,"26759.291648864746","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
6964,"Experiment 1","InstallHtop","IaC",3,2,"# Download and extract Htop source code
mkdir -p /usr/local/htop310
cd /usr/local/htop310 || exit
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xzf 3.1.0.tar.gz --strip-components=1

# Install necessary dependencies for building Htop
apt update
apt install -y build-essential autotools-dev autoconf libncurses5-dev pkg-config

# Compile and install Htop
./autogen.sh
./configure --prefix=/usr/local/htop310
make
make install

# Add Htop binary to PATH
echo ""export PATH=\$PATH:/usr/local/htop310/bin"" >> /etc/profile
source /etc/profile",175,"3057.6400756835938","0.7","0.9","gpt-4o","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 20: Not following: /etc/profile was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","16.900000000000002"
5281,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"2258.498191833496","0.7","0.9","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
5282,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"2258.498191833496","0.7","0.9","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
6657,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"5873.924732208252","0","0.1","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
9315,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }'",162,"5778.406381607056","0.2","0.4","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
8425,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"sed -i -e ':a;N;$!ba' -e 's/^\(.*\)\n\(.*\)\n\(.*\)\n\(.*\)\n\(.*\)$/\1/' data.md",54,"8908.559799194336","0","0.1","llama3.3-70b","data.md ar 10 rindām",1,"",False,"The last 5 lines were not removed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.6"
6148,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) tar -xvf ""$file"" ;;
 *.bz2) tar -xvf ""$file"" ;;
 *.xz) tar -xvf ""$file"" ;;
 *.lzma) tar --lzma -xvf ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xvf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",124,"7123.215198516846","0.2","0.4","llama3.3-70b","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.15"
9171,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and partial checksum; id=""${device}:${inode}:${size}:${checksum}""; # Append file path to the identifier's record; echo ""$file"" >> ""$tmpdir/$id"";done;;# Output files with identical identifiers (including hard links);for idfile in ""$tmpdir""/*; do; # Only show groups with more than one file; if [ $(wc -l < ""$idfile"") -gt 1 ]; then; # Replace newlines with spaces; tr '\n' ' ' < ""$idfile""; echo # Add newline after each group; fi;done;;# Clean up;rm -rf ""$tmpdir""",499,"26644.14930343628","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,1,0,"Line 26: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
5284,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",80,"7867.178201675415","0.7","0.9","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5190,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4419.171333312988","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
6959,"Experiment 1","InstallHtop","IaC",3,1,"mkdir -p /usr/local/htop310;cd /usr/local/htop310;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz;tar -xzf 3.1.0.tar.gz --strip-components=1;./autogen.sh;./configure;make;make install;echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile;source /etc/profile",107,"2291.076183319092","0","0.1","gpt-4o","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,2,1,0,"Line 3: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 10: Expressions don't expand in single quotes, use double quotes for that. Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","1.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","10.549999999999999"
9318,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0; next} {print $0, a[$1]}' GHJ1.txt GHJ2.txt > temp.txt;awk 'NR==FNR{a[$1]=$0; next} {print $0, a[$1]}' GHJ2.txt GHJ1.txt | grep -v -f temp.txt | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }';rm temp.txt",223,"2862.5972270965576","0.2","0.4","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","17.12"
5071,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5067,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
9159,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as a checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier for potential duplicates; echo ""$file"" >> ""$tmpdir/files_${device}_${inode}_${size}_${checksum}"";done;;# Output groups of identical files;find ""$tmpdir"" -type f -size +0c | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; tr '\n' ' ' < ""$group""; echo; fi;done",436,"24238.853216171265","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,1,0,"Line 24: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","48.599999999999994"
9160,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as a checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier for potential duplicates; echo ""$file"" >> ""$tmpdir/files_${device}_${inode}_${size}_${checksum}"";done;;# Output groups of identical files;find ""$tmpdir"" -type f -size +0c | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; tr '\n' ' ' < ""$group""; echo; fi;done",436,"24238.853216171265","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 24: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","48.599999999999994"
5274,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"1921.1437702178955","0","0.1","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
6978,"Experiment 1","InstallHtop","IaC",3,2,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
cd htop-3.1.0 || exit
./autogen.sh
./configure --prefix=/usr/local/htop310
make
make install
echo ""export PATH=$PATH:/usr/local/htop310/bin"" >> /etc/profile
source /etc/profile",113,"1463.3560180664062","0.7","0.9","llama3.3-70b","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.850000000000001"
8664,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
9247,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 find -type f -exec ls -li {} +",51,"1154.0069580078125","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"find: paths must precede expression: `/usr/files/subdir/file3copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file2copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file1.txt' find: possible unquoted pattern after predicate `-exec'? ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","11.45"
6965,"Experiment 1","InstallHtop","IaC",3,1,"# Create the installation directory;mkdir -p /usr/local/htop310;;# Navigate to the installation directory;cd /usr/local/htop310;;# Download the Htop source code;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz;;# Extract the tar.gz archive;tar -xzf htop-3.1.0.tar.gz --strip-components=1;;# Compile and install Htop;./autogen.sh;./configure --prefix=/usr/local/htop310;make;make install;;# Add Htop binary to PATH;echo 'export PATH=/usr/local/htop310/bin:$PATH' >> /etc/profile;source /etc/profile",1081,"10894.558668136597","1","1","o1-mini","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,1,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 21: Expressions don't expand in single quotes, use double quotes for that. Line 22: Not following: /etc/profile was not specified as input (see shellcheck -x). ","4.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","11.700000000000001"
5306,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 -d",36,"1764.8732662200928","0.2","0.4","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
5184,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4324.1868019104","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
5185,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4324.1868019104","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
9322,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0;next} {if($1 in a) print a[$1],$0}' GHJ1.txt GHJ2.txt | awk 'NR==1{print $0} NR>1{if($1==""Exe"") {print $0} else {print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11}}'",94,"1659.9199771881104","0.7","0.9","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","8.64"
5076,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
9250,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 md5sum | sort | uniq -Dw32 | cut -c35-",57,"1578.5348415374756","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","16.1"
6966,"Experiment 1","InstallHtop","IaC",3,2,"# Create the installation directory
mkdir -p /usr/local/htop310

# Navigate to the installation directory
cd /usr/local/htop310 || exit

# Download the Htop source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the tar.gz archive
tar -xzf htop-3.1.0.tar.gz --strip-components=1

# Compile and install Htop
./autogen.sh
./configure --prefix=/usr/local/htop310
make
make install

# Add Htop binary to PATH
echo ""export PATH=/usr/local/htop310/bin:\$PATH"" >> /etc/profile
source /etc/profile",1340,"9482.97095298767","1","1","o1-mini","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 22: Not following: /etc/profile was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","14"
5618,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash;USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-);export USERNAME",427,"3768.393039703369","1","1","o1-mini",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
9311,"Experiment 1","PrintTable","NL2Bash",3,1,"join <(sort GHJ1.txt) <(sort GHJ2.txt) | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }'",158,"2359.0948581695557","0","0.1","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5083,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD e833b4b..0e040d5 develop -> origin/develop Switched to branch 'develop' fatal: Not possible to fast-forward, aborting. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
6277,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl --include=""result.log"" ""FAIL"" /usr/results | wc -l",144,"12184.828042984009","0.2","0.4","deepseek-v3","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
4554,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"1655.280351638794","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4555,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"1655.280351638794","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
9198,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | awk '{; if (seen[$1]++) {; printf(""%s %s\n"", prev, $2); } else {; prev = $2; };}' | sort -u",69,"1755.260944366455","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","12.84"
5498,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"1854.6984195709229","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5302,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 -d",36,"1471.1320400238037","0","0.1","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
6285,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results/*.log | wc -l",21,"945.8353519439697","0.2","0.4","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"Only files that are named result.log and contain the word FAIL should be counted.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
4565,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} \;",61,"1718.2445526123047","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
9199,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | awk '{; if (seen[$1]++) {; printf(""%s %s\n"", prev, $2); } else {; prev = $2; };}' | sort -u",69,"1755.260944366455","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","12.84"
5718,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"1455.7926654815674","0.2","0.4","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
8823,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87};echo",478,"3363.1699085235596","1","1","o1-mini","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
5055,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5056,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD e08fd38..ff7ed8a develop -> origin/develop ",False,"Changes weren't pulled.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5057,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
6289,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results/*.log | wc -l",21,"1146.6026306152344","0.7","0.9","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"Only files that are named result.log and contain the word FAIL should be counted.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
5058,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 04e657e..b091286 develop -> origin/develop ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
7770,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I {} basename $(readlink -f /proc/{}/exe)",119,"3160.9086990356445","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"ormation. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. ",False,"All child processes weren't listed",0,1,1,0,"Line 13: Double quote to prevent globbing and word splitting. Line 13: Quote this to prevent word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8314,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""first monday of may 2013"" +""%Y-%m-%d""",485,"4702.187061309814","1","1","o1-mini","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘first monday of may 2013’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
5711,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f2-);echo ""$USERNAME""",147,"11077.015399932861","0","0.1","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7489,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"#!/bin/bash
if apt list --upgradable 2>/dev/null | grep -q ""^htop/""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",1834,"100419.63529586792","0.2","0.4","deepseek-r1","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7490,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"#!/bin/bash
if apt list --upgradable 2>/dev/null | grep -q ""^htop/""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",1834,"100419.63529586792","0.2","0.4","deepseek-r1","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7638,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1057.5037002563477","0","0.1","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
5749,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"1441.9188499450684","0.2","0.4","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
6240,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",13,"851.8917560577393","0.7","0.9","gpt-3.5-turbo","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
7281,"Experiment 1","Factorial","NL2Bash",2,1,"seq -s '*' 1 623 | bc",892,"48335.40964126587","0.2","0.4","deepseek-r1","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","3.8"
4837,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5712,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f2-);echo ""$USERNAME""",147,"11077.015399932861","0","0.1","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
9278,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt; join -j 1 -o 0,1.2,1.3,2.2,2.3 <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v '^Exe';} | column -t",71,"1676.2139797210693","0.2","0.4","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
7491,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"apt-get update >/dev/null 2>&1 && \;if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",1499,"255279.4258594513","0.7","0.9","deepseek-r1","Ir jaunākā versija",1,"",False,"The package is up to date but update not needed was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","24"
7355,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1421.1153984069824","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7356,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1421.1153984069824","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4829,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4830,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","8.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4831,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5738,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"2147.5472450256348","0","0.1","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5109,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5110,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7362,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1273.7178802490234","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7493,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"apt-get update >/dev/null 2>&1 && \;if apt list --upgradable --no-color 2>/dev/null | grep -q '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",3253,"348592.1301841736","0.7","0.9","deepseek-r1","Ir jaunākā versija",1,"",False,"The package is up to date but update not needed was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","24.05"
6639,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1447.7064609527588","0.2","0.4","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
4869,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4870,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4871,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5744,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"2062.706470489502","0","0.1","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5112,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8927,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in $(ps -eo stat,ppid | awk '/^Z/ {print $2}' | sort -u); do; kill -9 ""$pid"" 2>/dev/null;done",49,"1488.374948501587","0.7","0.9","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.45"
5596,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1045.1622009277344","0.2","0.4","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5134,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7497,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""htop.*upgraded""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",43,"6876.7688274383545","0.2","0.4","deepseek-v3","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
8926,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo stat,ppid | awk '/^Z/ {print $2}' | sort -u); do; kill -9 $pid 2>/dev/null;done",48,"1769.5422172546387","0.7","0.9","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.45"
7343,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1777.353048324585","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5652,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"1548.0294227600098","0","0.1","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
5653,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"1548.0294227600098","0","0.1","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
5155,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
7506,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q htop; then
 echo ""update needed""
else
 echo ""update not needed""
fi",42,"1057.7399730682373","0.2","0.4","gpt-3.5-turbo","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7344,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1777.353048324585","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
4877,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4875,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5654,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"1548.0294227600098","0","0.1","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
5656,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"source <(grep ""^USERNAME="" .env)
echo ""$USERNAME""",19,"1347.4838733673096","0","0.1","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: ShellCheck can't follow non-constant source. Use a directive to specify location. ","7.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","-1"
4960,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4961,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7507,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"#!/bin/bash

if apt list --upgradable 2>/dev/null | grep -q ""\bhtop\b""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",49,"1558.1903457641602","0.7","0.9","gpt-3.5-turbo","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7345,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1777.353048324585","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
4963,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 0204e4d..a8a0110 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4876,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5657,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"source <(grep ""^USERNAME="" .env)
echo ""$USERNAME""",19,"1347.4838733673096","0","0.1","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: ShellCheck can't follow non-constant source. Use a directive to specify location. ","7.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","-1"
5658,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"source <(grep ""^USERNAME="" .env)
echo ""$USERNAME""",19,"1347.4838733673096","0","0.1","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"/dev/fd/63: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,0,1,0,"Line 2: ShellCheck can't follow non-constant source. Use a directive to specify location. ","7.8","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","-1"
5620,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1650.8996486663818","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
7059,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash # Stop the current PostgreSQL 16 cluster pg_dropcluster 16 main --stop # Install PostgreSQL 17 apt update apt install postgresql-17 # Create a new PostgreSQL 17 cluster pg_createcluster 17 main --start # Upgrade the cluster from 16 to 17 pg_upgradecluster 16 main # Drop the old PostgreSQL 16 cluster pg_dropcluster 16 main # Restart the PostgreSQL 17 cluster to ensure everything is working systemctl restart postgresql",125,"3987.680673599243","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","9.85"
7347,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1445.340871810913","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4939,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
5619,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash;USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-);export USERNAME",427,"3768.393039703369","1","1","o1-mini",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7504,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q htop; then
 echo ""update needed""
else
 echo ""update not needed""
fi",42,"1159.5494747161865","0","0.1","gpt-3.5-turbo","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
8845,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1760.737419128418","0","0.1","gpt-4o","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
4883,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4881,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8388,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",41,"1279.0284156799316","0","0.1","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.25"
8856,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1466.0053253173828","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
7349,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1445.340871810913","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7350,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1445.340871810913","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4880,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8527,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5023,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b549a7d..e0fc63a develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7465,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",41,"875.0131130218506","0.2","0.4","gpt-4o","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7466,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",41,"875.0131130218506","0.2","0.4","gpt-4o","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
8872,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",14,"948.4546184539795","0.2","0.4","gpt-3.5-turbo","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
8857,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1466.0053253173828","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8528,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8531,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
4998,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD d9abc59..05bb69b develop -> origin/develop Index was not unstashed. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
4999,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD b7c64f0..d2dfa8f develop -> origin/develop error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"Incorrect changes have been pulled. File content is incorrect.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
7467,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""^Inst""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",39,"1370.640516281128","0.7","0.9","gpt-4o","Ir jaunākā versija",1,"",False,"The package is up to date but update needed was outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7351,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1258.3253383636475","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
4887,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8532,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8534,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
4996,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
4888,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8824,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87}",16,"1463.4313583374023","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.4"
5011,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server f18700f..4c98ff5 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
7464,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",41,"1095.2215194702148","0","0.1","gpt-4o","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7353,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1258.3253383636475","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
8667,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8668,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8874,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"cd /usr/src
for file in *.java; do
 ln -s /usr/src/$file /path/to/current/directory/$file
done",38,"1350.329875946045","0.7","0.9","gpt-3.5-turbo","2 .java datnes, 1 cita veida",1,"ln: failed to create symbolic link '/path/to/current/directory/file1.java': No such file or directory ln: failed to create symbolic link '/path/to/current/directory/file2.java': No such file or directory ",False,"Required symlinks were not created",0,1,1,0,"Line 2: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 4: Double quote to prevent globbing and word splitting. Line 4: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","4.800000000000001"
4860,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: *.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5233,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Check if in a Git repo, initialize temporarily if not
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
 git init -q
 TEMP_GIT=1
fi

# Delete ignored files
git clean -dfX

# Clean up temporary repo
if [[ -n ""$TEMP_GIT"" ]]; then
 rm -rf .git
fi",1816,"18269.07229423523","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.5"
4981,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 0204e4d..a8a0110 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7472,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -E ""^htop/"" > /dev/null; then
 echo ""update needed""
else
 echo ""update not needed""
fi",380,"3375.779628753662","1","1","o1-mini","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.599999999999998"
6031,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",802,"9473.279476165771","0.7","0.9","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8873,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",14,"948.4546184539795","0.2","0.4","gpt-3.5-turbo","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
7358,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1421.1153984069824","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4986,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD d9abc59..05bb69b develop -> origin/develop Index was not unstashed. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
4987,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD b7c64f0..d2dfa8f develop -> origin/develop error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"Incorrect changes have been pulled. File content is incorrect.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
7124,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1560.9934329986572","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
4864,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7600,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: ${exit_code}""",713,"41303.720235824585","0.2","0.4","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6032,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",802,"9473.279476165771","0.7","0.9","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4910,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4913,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8648,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
5571,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1343.9648151397705","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0_0.1_2.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
7607,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash
exit_code=$(systemctl show -p ExecMainStatus --value myservice)
echo ""exit code: $exit_code""",723,"39193.35603713989","0.7","0.9","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6049,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",113,"10574.0385055542","0.2","0.4","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5575,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 ./""$script""
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",52,"1364.6750450134277","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script1.sh: Permission denied /media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script2.sh: Permission denied /media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./subdir.sh: Is a directory ",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.5"
7592,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice --property=ExecMainStatus | cut -d= -f2)""",665,"44310.922384262085","0","0.1","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7361,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1273.7178802490234","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7363,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1400.6297588348389","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7594,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"code=$(journalctl -u myservice --no-pager | grep -a ""Main process exited, code=exited, status="" | tail -n1 | sed -n 's/.*status=\([0-9]\+\).*/\1/p');[ -z ""$code"" ] && code=$(systemctl show myservice --property=ExecMainStatus --value);echo ""exit code: ${code:-0}""",3222,"563536.4928245544","0","0.1","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
5450,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1774.1165161132812","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
7595,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"code=$(journalctl -u myservice --no-pager | grep -a ""Main process exited, code=exited, status="" | tail -n1 | sed -n 's/.*status=\([0-9]\+\).*/\1/p');[ -z ""$code"" ] && code=$(systemctl show myservice --property=ExecMainStatus --value);echo ""exit code: ${code:-0}""",3222,"563536.4928245544","0","0.1","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
5622,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1650.8996486663818","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
7596,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"code=$(journalctl -u myservice --no-pager | grep -a ""Main process exited, code=exited, status="" | tail -n1 | sed -n 's/.*status=\([0-9]\+\).*/\1/p');[ -z ""$code"" ] && code=$(systemctl show myservice --property=ExecMainStatus --value);echo ""exit code: ${code:-0}""",3222,"563536.4928245544","0","0.1","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
4914,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: ./*.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8693,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8694,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_gpt-3.5-turbo_0_0.1.sh: line 9: export: `attempts = 3': not a valid identifier /media/sf_scripts/LoadIniFile_gpt-3.5-turbo_0_0.1.sh: line 9: export: `appname = test.exe': not a valid identifier ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,0,0,0,"","10.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
7364,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1400.6297588348389","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4916,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"jq: error (at <stdin>:1): Cannot index string with string *user* parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
8440,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1350.0685691833496","0","0.1","gpt-3.5-turbo","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
7089,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;apt update;apt install -y postgresql postgresql-contrib;;VERSION=$(ls /etc/postgresql | sort -V | tail -n1);CONFIG_FILE=""/etc/postgresql/$VERSION/main/postgresql.conf"";sed -i -E ""s/^#?\s*port\s*=\s*[0-9]+/port = 5433/"" ""$CONFIG_FILE"";systemctl restart postgresql;;sudo -u postgres psql -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -d storedb -f init.sql;;sudo -u postgres psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb << EOF;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOF",3535,"343672.4679470062","0.2","0.4","deepseek-r1","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"User public_view does not have access to a common_data tables created after first initialization (future tables)",0,1,0,0,"Line 6: Use find instead of ls to better handle non-alphanumeric filenames. ","7.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.950000000000003"
8703,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8701,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
5168,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1650.4566669464111","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
7366,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1400.6297588348389","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4918,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"jq: error (at <stdin>:1): Cannot index string with string *user* parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4919,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"jq: error (at <stdin>:1): Cannot index string with string *user* parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
7090,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash;;apt update;apt install -y postgresql postgresql-contrib;;VERSION=$(find /etc/postgresql -maxdepth 1 -type d -name '*.*' -printf '%f\n' | sort -V | tail -n1);CONFIG_FILE=""/etc/postgresql/$VERSION/main/postgresql.conf"";sed -i -E ""s/^#?\s*port\s*=\s*[0-9]+/port = 5433/"" ""$CONFIG_FILE"";systemctl restart postgresql;;sudo -u postgres psql -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -d storedb -f init.sql;;sudo -u postgres psql -c ""CREATE USER IF NOT EXISTS public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb << EOF;CREATE SCHEMA IF NOT EXISTS common_data;;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOF",767,"42500.74577331543","0.2","0.4","deepseek-r1","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"o frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql//main/postgresql.conf: No such file or directory ERROR: syntax error at or near *NOT* LINE 1: CREATE USER IF NOT EXISTS public_view WITH PASSWORD 'fox';   ^ NOTICE: schema *common_data* already exists, skipping ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ",False,"Couldn't connect to storedb as public_view user with password fox",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","23.350000000000005"
7675,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show scope global | grep inet | awk '{print *IP: * $2}' | cut -d/ -f1",34,"1856.6277027130127","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.99"
7625,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p ExecMainStatus,Result --no-pager | awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} END {if (code == """") code=""unknown""; print ""exit code: "" code}';journalctl -u myservice.service -n 1 --no-pager | grep -oP 'code=exited, status=\K[0-9]+' | awk '{print ""exit code: "" $1}'",230,"14287.87612915039","0.2","0.4","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","16.93"
7626,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p ExecMainStatus,Result --no-pager | awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} END {if (code == """") code=""unknown""; print ""exit code: "" code}';journalctl -u myservice.service -n 1 --no-pager | grep -oP 'code=exited, status=\K[0-9]+' | awk '{print ""exit code: "" $1}'",230,"14287.87612915039","0.2","0.4","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","16.93"
8710,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
4925,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6432,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean: * sum/count}' products.csv",34,"1643.8114643096924","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
8712,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
9299,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/!d' | sort | (read -r line; echo ""$line""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/d')",102,"2166.442632675171","0","0.1","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
7133,"Experiment 1","SetupAlpineContainer","IaC",2,1,"mkdir -p /usr/alpinedata && docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",1120,"56563.88807296753","0","0.1","deepseek-r1","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","6.2"
7033,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to port 5433;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -d storedb <<EOF;CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF;;echo ""PostgreSQL setup complete:"";echo ""- Running on port 5433"";echo ""- Database 'storedb' created"";echo ""- User 'public_view' with password 'fox' created"";echo ""- Read-only access granted to schema 'common_data'""",368,"21116.761684417725","0.7","0.9","deepseek-v3","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","29.05000000000001"
4897,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
7029,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to port 5433;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;echo ""PostgreSQL setup complete on port 5433""",398,"22727.70404815674","0","0.1","deepseek-v3","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","21.900000000000002"
4893,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
7616,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"5372.980833053589","0","0.1","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
5800,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"3047.4321842193604","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5180,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1606.9893836975098","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
8553,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8554,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5181,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1606.9893836975098","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
7030,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to port 5433;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;echo ""PostgreSQL setup complete on port 5433""",398,"22727.70404815674","0","0.1","deepseek-v3","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","21.900000000000002"
4714,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4715,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7619,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service --property=ExecMainStatus,Result --no-pager | ; awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} ;  END {printf ""exit code: %d\n"", (code != """") ? code : (result == ""exit-code"") ? 0 : ""unknown""}'",247,"19593.6598777771","0","0.1","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.9"
7620,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service --property=ExecMainStatus,Result --no-pager | ; awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} ;  END {printf ""exit code: %d\n"", (code != """") ? code : (result == ""exit-code"") ? 0 : ""unknown""}'",247,"19593.6598777771","0","0.1","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.9"
8562,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
5818,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level | select(. == *warning*)] | length') echo *Count warning: $count*",54,"2051.1889457702637","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"jq: error (at <stdin>:1): Cannot index string with string *level* ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7000,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Start PostgreSQL service;systemctl restart postgresql;;# Switch to the postgres user to setup the database;sudo -i -u postgres bash << EOF;;# Create the ""storedb"" database;psql -c ""CREATE DATABASE storedb;"";;# Run the SQL script;psql -d storedb -f /root/init.sql;;# Create the ""public_view"" user with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Grant read-only access to the ""public_view"" user on the ""common_data"" schema;psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",260,"5668.36142539978","0.7","0.9","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"ze frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: psql: error: /root/init.sql: Permission denied ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","16.3"
7655,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"1458.4064483642578","0.7","0.9","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
8570,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
8571,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
8825,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87}",16,"1359.032392501831","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.4"
7022,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql postgresql-contrib;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database ""storedb"";psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",260,"3268.9361572265625","0.2","0.4","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.249999999999998"
7641,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1955.7552337646484","0","0.1","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
4716,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5799,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1859.370470046997","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7522,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -1 | awk '{print ""exit code: "" $1}'",56,"1916.6431427001953","0.2","0.4","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.129999999999999"
4721,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7024,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql postgresql-contrib;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change authentication method to md5 for postgres user;echo ""host all postgres 127.0.0.1/32 md5"" >> /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database ""storedb"";psql -U postgres -h localhost -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -h localhost -p 5433 -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -h localhost -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",365,"3710.3683948516846","0.2","0.4","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"ting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? psql: error: connection to server at *localhost* (::1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.250000000000004"
7523,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -1 | awk '{print ""exit code: "" $1}'",56,"1916.6431427001953","0.2","0.4","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.129999999999999"
8125,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"1972.3265171051025","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
5203,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"3028.226375579834","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
8622,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,0,0,0,"","10.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
8822,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87}; echo",18,"951.9534111022949","0.7","0.9","gpt-4o","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
4727,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7527,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"status=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: $status""",29,"1457.7124118804932","0.7","0.9","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7528,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"status=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: $status""",29,"1457.7124118804932","0.7","0.9","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7525,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"status=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: $status""",29,"1457.7124118804932","0.7","0.9","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4728,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8658,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
7585,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitStatus | awk -F '=' '{print ""exit code: "" $2}'",29,"3067.7237510681152","0.7","0.9","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
7028,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres config to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change Postgres authentication method to md5;sed -i 's/peer/md5/' /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database storedb;psql -U postgres -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on storedb;psql -U postgres -p 5433 -d storedb -f init.sql;;# Create user public_view with password fox;psql -U postgres -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema common_data for user public_view;psql -U postgres -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -U postgres -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",322,"2680.1226139068604","0.7","0.9","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"sql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","18.649999999999995"
8630,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
5198,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1563.1396770477295","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
4729,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8136,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep -E 'Failed password|Failed login' /var/log/auth.log | grep *$(date +*%b %d*)* | awk '{print $(NF-1)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",66,"2833.6715698242188","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
7019,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change authentication method to md5 for postgres user;echo ""host all postgres 127.0.0.1/32 md5"" >> /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database ""storedb"";psql -U postgres -h localhost -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -h localhost -p 5433 -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -h localhost -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",362,"2822.629690170288","0","0.1","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"ting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? psql: error: connection to server at *localhost* (::1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.200000000000003"
5624,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1650.8996486663818","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
7535,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice -p ExecMainStatus --value)""",484,"3770.936965942383","1","1","o1-mini","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7534,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice -p ExecMainStatus --value)""",484,"3770.936965942383","1","1","o1-mini","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7536,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice -p ExecMainStatus --value)""",484,"3770.936965942383","1","1","o1-mini","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
5216,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",2515,"31062.458038330078","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
8636,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
4733,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4734,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7020,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change authentication method to md5 for postgres user;echo ""host all postgres 127.0.0.1/32 md5"" >> /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database ""storedb"";psql -U postgres -h localhost -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -h localhost -p 5433 -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -h localhost -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",362,"2822.629690170288","0","0.1","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"ting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? psql: error: connection to server at *localhost* (::1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.200000000000003"
4735,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8124,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",139,"3976.47762298584","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
7537,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(systemctl show myservice -p ExecMainExitCode --value)
echo ""exit code: ${exit_code:-0}""",2157,"12300.067663192749","1","1","o1-mini","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
5225,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [[ -f .gitignore ]]; then
 git init -q
 git clean -Xdf
 rm -rf .git
else
 echo ""Error: No .gitignore file found"" >&2
 exit 1
fi",1816,"18195.217847824097","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
5213,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git ls-files --others -z --exclude-standard | xargs -0 -p rm",24,"1290.9867763519287","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"rm .gitignore program.jsxargs: failed to open /dev/tty for reading: No such device or address ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.95"
8640,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8826,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87}; echo",18,"1556.2846660614014","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
7009,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/13/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/13/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",322,"7676.994562149048","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/13/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 14: /etc/postgresql/13/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
7010,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/13/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/13/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",322,"7676.994562149048","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/13/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 14: /etc/postgresql/13/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
4620,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",551,"6365.650653839111","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
7007,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",390,"8823.762655258179","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
8918,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash;;# Find all zombie processes and get their PPIDs;zombie_ppids=$(ps -A -ostat,ppid | awk '/[Zz]/ && $2 != 0 {print $2}');;if [[ -z ""$zombie_ppids"" ]]; then; echo ""No zombie processes found.""; exit 0;fi;;# Kill each parent process with SIGKILL;for ppid in $zombie_ppids; do; echo ""Killing parent process $ppid of zombie process""; kill -9 ""$ppid"";done;;echo ""Zombie cleanup completed.""",244,"15699.690341949463","0.7","0.9","deepseek-v3","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","16.55"
7172,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -t && systemctl restart nginx",81,"2769.6104049682617","0","0.1","qwen/qwen2.5-coder-32b-instruct","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
8673,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
8614,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5642,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1545.1200008392334","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
9057,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '{ if ($0 ~ /%/) { print substr($0, 1, index($0, ""%"")-1); exit } else print $0 }')",42,"1254.0082931518555","0.7","0.9","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
8922,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo stat,ppid | awk '$1 ~ /Z/ {print $2}' | sort -u); do; kill -9 $pid;done",45,"3273.453950881958","0","0.1","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8315,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-01 next Monday"" +""%Y-%m-%d""",614,"5812.432289123535","1","1","o1-mini","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
4702,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8617,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
8618,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
7389,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"3676.5120029449463","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6020,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",443,"7867.5856590271","0.2","0.4","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8575,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
9016,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; printf *%s* *$char*; done; })",54,"1956.3944339752197","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
6021,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",443,"7867.5856590271","0.2","0.4","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7084,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;apt update && apt install -y postgresql postgresql-contrib;;PG_CONF=$(find /etc/postgresql/*/main/postgresql.conf -type f | head -n1);sed -i ""s/^#*listen_addresses.*/listen_addresses = '*'/"" ""$PG_CONF"";sed -i ""s/^#*port.*/port = 5433/"" ""$PG_CONF"";systemctl restart postgresql;;sudo -u postgres createdb -p 5433 storedb;sudo -u postgres psql -p 5433 -d storedb -f init.sql;;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb <<EOSQL;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOSQL",3028,"329507.68780708313","0","0.1","deepseek-r1","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","8.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","23.400000000000002"
7717,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: ""$4}' | awk '{print $2}'",42,"1241.2874698638916","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.77"
7709,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show ""$(ip route | awk '/default/ {print $5}')"" | awk '{print ""IP: "" $4}' | awk '{print $2}'",44,"2044.816017150879","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.79"
5701,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\''""]//' -e 's/[""'\''""]$//');export USERNAME",560,"34961.12394332886","0.7","0.9","deepseek-r1",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6033,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",802,"9473.279476165771","0.7","0.9","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4703,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4704,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8384,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 ls -l ""$file""
 fi
done",144,"14121.92440032959","0.7","0.9","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.299999999999997"
6175,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""

# Extract based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) tar -xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar -xjf ""$file"" ;;
 *.tar.xz|*.txz) tar -xJf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.gz)  gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz)  unxz ""$file"" ;;
 *.7z)  7z x ""$file"" ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Check if extraction succeeded
if [[ $? -ne 0 ]]; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",1821,"46573.923110961914","0.7","0.9","deepseek-r1","arhīvs ir .bz2",2,"",False,"",1,0,0,0,"Line 36: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","12.5","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6012,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",870,"12086.254358291626","0","0.1","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4708,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4709,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8674,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
8373,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r';ls -l | awk '$1 ~ /^-.r/'",173,"13192.781686782837","0","0.1","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,1,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 3: Use find instead of ls to better handle non-alphanumeric filenames. ","10.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","11.45"
6152,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"3465.360403060913","0.7","0.9","llama3.3-70b","arhīvs ir .tar.gz",1,"",False,"An archive of type .tar.gz was not extracted.",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.55"
6016,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",1102,"355343.9531326294","0","0.1","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6017,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",1102,"355343.9531326294","0","0.1","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4710,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7966,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5702,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\''""]//' -e 's/[""'\''""]$//');export USERNAME",560,"34961.12394332886","0.7","0.9","deepseek-r1",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8375,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -u=r -ls
find . -maxdepth 1 -type f -perm -u=r -exec ls -ld {} +",165,"12322.636365890503","0","0.1","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","3.6"
6154,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"3465.360403060913","0.7","0.9","llama3.3-70b","arhīvs ir .xz",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.55"
5243,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -fdX",167,"7713.548183441162","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
8830,"Experiment 1","PrintLine","NL2Bash",1,2,"printf ""%.0s"" {1..87} | tr -d '[:space:]'",24,"1382.227897644043","0.2","0.4","llama3.3-70b","Jāizprintē rinda",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 87 *=* characters","5.800000000000001"
6099,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find the archive file with the name pattern archive.*
file=$(ls archive.* 2>/dev/null | head -n 1)

if [ -z ""$file"" ]; then
 echo ""No archive file named archive.* found in the current directory.""
 exit 1
fi

case ""$file"" in
 *.tar.gz|*.tgz)
 tar -xzf ""$file""
 ;;
 *.tar.bz2|*.tbz2)
 tar -xjf ""$file""
 ;;
 *.tar.xz|*.txz)
 tar -xJf ""$file""
 ;;
 *.zip)
 unzip ""$file""
 ;;
 *.7z)
 7z x ""$file""
 ;;
 *.gz)
 gunzip ""$file""
 ;;
 *.bz2)
 bunzip2 ""$file""
 ;;
 *.xz)
 unxz ""$file""
 ;;
 *)
 echo ""Unsupported archive format: $file""
 exit 1
 ;;
esac",1003,"5970.0939655303955","1","1","o1-mini","arhīvs ir .xz",2,"",False,"",0,1,0,0,"Line 4: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
4801,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6046,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",113,"10574.0385055542","0.2","0.4","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6047,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",113,"10574.0385055542","0.2","0.4","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6048,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",113,"10574.0385055542","0.2","0.4","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8351,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '$1 ~ /^-..r/ {print $0}'",23,"1251.1608600616455","0.7","0.9","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"A file with read permission was not found",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","4.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
4807,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5759,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo $USERNAME",29,"1344.003677368164","0.7","0.9","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6051,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2148.9009857177734","0.7","0.9","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8678,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6104,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash;;# Find the first archive file matching archive.* in the current directory;file=$(find . -maxdepth 1 -type f -name 'archive.*' -print -quit);;if [ -z ""$file"" ]; then; echo ""No archive file named archive.* found in the current directory.""; exit 1;fi;;case ""$file"" in; *.tar.gz|*.tgz); tar -xzf ""$file"";;; *.tar.bz2|*.tbz2); tar -xjf ""$file"";;; *.tar.xz|*.txz); tar -xJf ""$file"";;; *.zip); unzip ""$file"";;; *.7z); 7z x ""$file"";;; *.gz); gunzip ""$file"";;; *.bz2); bunzip2 ""$file"";;; *.xz); unxz ""$file"";;; *); echo ""Unsupported archive format: $file""; exit 1;;;esac",692,"5174.609184265137","1","1","o1-mini","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
8344,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '/^-r/ {print $0}'",19,"1153.6777019500732","0","0.1","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
5259,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore -q {} 2>/dev/null; then rm {}; fi' \;",36,"2254.000663757324","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
4653,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",161,"2760.106325149536","0.2","0.4","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4655,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4915.4016971588135","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
6070,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"952.0080089569092","0.2","0.4","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6071,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"952.0080089569092","0.2","0.4","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4810,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8356,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -perm -u=r -exec ls -l {} +",1060,"11382.601022720337","1","1","o1-mini","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.8"
6133,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",120,"3559.7331523895264","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6134,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",120,"3559.7331523895264","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6072,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"952.0080089569092","0.2","0.4","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8860,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""${file##*/}""
done",30,"1452.4593353271484","0.2","0.4","llama3.3-70b","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
4811,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7096,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash;;# Add PostgreSQL repository for version 17;echo 'deb [signed-by=/usr/share/postgresql-common/pgdg/apt.postgresql.org.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main' > /etc/apt/sources.list.d/pgdg.list;;# Import repository signing key;wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -;;# Install PostgreSQL 17;apt-get update;apt-get install -y postgresql-17;;# Stop old cluster and upgrade;systemctl stop postgresql@16-main;pg_upgradecluster -v 17 16 main;;# Remove old cluster;pg_dropcluster 16 main --stop",3297,"157265.9637928009","0.2","0.4","deepseek-r1","Jāinstalē postgres 17",2,"n trusted.gpg.d instead (see apt-key(8)). E: The repository 'http://apt.postgresql.org/pub/repos/apt $(lsb_release Release' does not have a Release file. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. E: Unable to locate package postgresql-17 dpkg-query: no packages found matching postgresql*-17* Error: pg_upgradecluster pre-upgrade checks failed ",False,"Postgres 17 was not installed (based on *psql --version*)",0,1,0,0,"Line 4: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","14.45"
6075,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^\([^#]\)/#\1/' settings.env",22,"841.9342041015625","0.7","0.9","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7097,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash

# Add PostgreSQL repository for version 17 with proper variable expansion
echo ""deb [signed-by=/etc/apt/keyrings/postgresql.gpg] https://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main"" > /etc/apt/sources.list.d/pgdg.list

# Create key directory and import repository signing key properly
mkdir -p /etc/apt/keyrings
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --dearmor -o /etc/apt/keyrings/postgresql.gpg

# Install PostgreSQL 17 with client packages
apt-get update
apt-get install -y postgresql-17 postgresql-client-17

# Stop old cluster and upgrade with package validation
systemctl stop postgresql@16-main
pg_upgradecluster -v 17 16 main

# Remove old cluster after successful upgrade
pg_dropcluster 16 main --stop

# Optional: Set new cluster as default
systemctl enable postgresql@17-main",840,"44147.17793464661","0.2","0.4","deepseek-r1","Jāinstalē postgres 17",2,"",True,"",0,0,0,0,"","13.0","","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","17.349999999999998"
5944,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1145.0212001800537","0.2","0.4","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5945,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1145.0212001800537","0.2","0.4","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4737,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7070,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash

# Stop the current PostgreSQL 16 cluster
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install -y postgresql-17

# Create a new cluster for PostgreSQL 17
pg_createcluster 17 main --start

# Stop the new cluster to prepare for upgrade
systemctl stop postgresql@17-main

# Perform the upgrade using pg_upgradecluster
pg_upgradecluster -v 17 -m upgrade 16 main

# Remove the old cluster (after verifying the upgrade worked)
pg_dropcluster 16 main --stop

# Update symlinks to point to PostgreSQL 17
update-alternatives --auto pg_config
update-alternatives --auto pg_ctl
update-alternatives --auto postgresql

# Restart the new cluster
systemctl start postgresql@17-main

echo ""PostgreSQL upgrade from 16 to 17 completed successfully""",314,"16831.74419403076","0.7","0.9","deepseek-v3","Jāinstalē postgres 17",2,"not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists update-alternatives: error: no alternatives for pg_config update-alternatives: error: no alternatives for pg_ctl update-alternatives: error: no alternatives for postgresql ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","17.05"
5948,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"948.6925601959229","0.7","0.9","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4746,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7049,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL 16 service
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install -y postgresql-17

# Initialize a new cluster for PostgreSQL 17
pg_createcluster 17 main --start

# Upgrade the data from PostgreSQL 16 to 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 service
systemctl start postgresql@17-main

# Optionally, remove the old PostgreSQL 16 cluster
pg_dropcluster 16 main --stop",122,"2875.7457733154297","0.2","0.4","gpt-4o","Jāinstalē postgres 17",2," apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","9.9"
5935,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1246.17600440979","0","0.1","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5936,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1246.17600440979","0","0.1","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5937,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1246.17600440979","0","0.1","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4760,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4761,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7837,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7431,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -print
find /usr/info -type f -mtime +20 -mtime -22 -print",163,"12694.263458251953","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.3"
7843,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7053,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash;set -e;;# Update package lists;apt update;;# Install PostgreSQL 17;apt install -y postgresql-17;;# Upgrade the 'main' cluster from version 16 to 17;pg_upgradecluster 16 main;;# Optionally, remove the old PostgreSQL 16 packages if no longer needed;# apt remove -y postgresql-16",482,"6320.434808731079","1","1","o1-mini","Jāinstalē postgres 17",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Old cluster was not removed after upgrading",0,0,0,0,"","9.5","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","5.550000000000001"
4637,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"3990.223169326782","0","0.1","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4763,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8444,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1053.3416271209717","0.7","0.9","gpt-3.5-turbo","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
7257,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>/dev/null | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1571.4502334594727","0.2","0.4","gpt-3.5-turbo","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: key 7721F63BD38B4796: 2 duplicate signatures removed gpg: /root/.gnupg/trustdb.gpg: trustdb created gpg: key 7721F63BD38B4796: public key *Google Inc. (Linux Packages Signing Authority) <linux-packages-keymaster@google.com>* imported gpg: Total number processed: 1 gpg:   imported: 1 ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
6002,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1546.4608669281006","0.7","0.9","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6003,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1546.4608669281006","0.7","0.9","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6626,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1066.3683414459229","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
4638,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"3990.223169326782","0","0.1","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
8831,"Experiment 1","PrintLine","NL2Bash",1,1,"printf ""%.0s="" $(seq 1 87)",17,"1354.6912670135498","0.7","0.9","llama3.3-70b","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.4"
4764,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4765,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7217,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"3071.146249771118","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data gpg: Signature made Wed 26 Mar 2025 03:36:09 PM PDT gpg:  using RSA key 0F06FF86BEEAF4E71866EE5232EE5355A6BC6E42 gpg: Can't check signature: No public key ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
7473,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"2070.673704147339","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7474,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"2070.673704147339","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
6270,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -exec grep -q 'FAIL' {} \; -printf '.' | wc -c",922,"10171.703815460205","0.2","0.4","deepseek-r1","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.300000000000001"
5975,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1245.2330589294434","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6269,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -print0 | xargs -0 grep -l 'FAIL' | wc -l",573,"5961.0595703125","0","0.1","deepseek-r1","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","8.45"
9328,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations and check their versions;find /home -type f -path '*/public_html/wp-includes/version.php' -print0 | while IFS= read -r -d $'\0' wp_version_file; do; wp_dir=$(dirname ""$(dirname ""$wp_version_file"")""); wp_version=$(grep -oP ""(?<=\\$wp_version = ')[^']+"" ""$wp_version_file""); echo ""Found: $wp_version in $wp_dir"";done; echo ""Found: $wp_version""",204,"12901.73053741455","0.2","0.4","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"grep: the -P option only supports a single pattern ",False,"All Wordpress versions were not found. Look in all users' home directories",0,2,0,0,"Line 6: Modification of wp_version is local (to subshell caused by pipeline). Line 9: wp_version was modified in a subshell. That change might be lost. ","3.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
7821,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"rsync: [sender] change_dir */--sd* failed: No such file or directory (2) rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1338) [sender=3.2.7] ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
4768,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5069,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
7514,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -n 1 | awk '{print ""exit code: "" $1}'",58,"1809.6601963043213","0","0.1","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.18"
6284,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results/*.log | wc -l",21,"945.8353519439697","0.2","0.4","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
7824,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
8473,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} +",25,"1355.7038307189941","0","0.1","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
7035,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",212,"2451.3096809387207","0","0.1","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
6900,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6286,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",36,"1162.6548767089844","0.2","0.4","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
9333,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Search all home directories for WordPress installations;find /home -type d -name 'wp-content' | while read -r wp_content_dir; do; # Get the WordPress root directory (parent of wp-content); wp_root=$(dirname ""$wp_content_dir""); # Check for version.php in the expected location; version_file=""$wp_root/wp-includes/version.php""; if [[ -f ""$version_file"" ]]; then; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; echo ""Found: $wp_version (in $wp_root)""; fi; fi;done;;# Alternative check for wp-config.php if version.php isn't found;find /home -type f -name 'wp-config.php' | while read -r wp_config; do; wp_root=$(dirname ""$wp_config""); version_file=""$wp_root/wp-includes/version.php""; if [[ -f ""$version_file"" ]]; then; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; echo ""Found: $wp_version (in $wp_root)""; fi; fi;done",432,"25267.83061027527","0.7","0.9","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","83.39999999999999"
4691,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -exec rm {} +",41,"968.106746673584","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.2"
7713,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show ""$(ip route | awk '/default/ {print $5}')"" | awk '{print ""IP: "" $4}' | awk '{print $2}'",44,"1335.8829021453857","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.79"
5632,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1643.474817276001","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
9324,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations in users' public_html directories;find /home -type f -path '*/public_html/wp-includes/version.php' | while read -r wp_version_file; do; # Extract the WordPress version from the version.php file; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$wp_version_file"" 2>/dev/null); if [ -n ""$wp_version"" ]; then; # Get the website path (parent directory of wp-includes); website_path=$(dirname ""$(dirname ""$wp_version_file"")""); echo ""Found: $wp_version (in $website_path)""; fi;done;#!/bin/bash;;find /home -type f -path '*/public_html/wp-includes/version.php' -exec \; grep -hoP ""\$wp_version = '\K[^']+"" {} \; 2>/dev/null | \; while read -r version; do; echo ""Found: $version""; done",310,"18015.40446281433","0","0.1","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
6288,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results/*.log | wc -l",21,"1146.6026306152344","0.7","0.9","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
6242,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l",25,"1650.345802307129","0","0.1","gpt-4o","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
8661,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
8662,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
8832,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87} && echo",19,"5668.376684188843","0","0.1","deepseek-v3","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","3.7"
4769,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6902,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
5646,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1245.6550598144531","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
6290,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",36,"1293.7541007995605","0.7","0.9","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
5644,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1545.1200008392334","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
4697,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" \) -exec rm {} +",44,"2213.918685913086","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
9325,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Search all home directories for WordPress installations;find /home -type d -name 'public_html' -o -type d -name 'www' | while read -r webroot; do; # Check if this directory contains WordPress; if [ -f ""$webroot/wp-includes/version.php"" ]; then; version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$webroot/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version (in $webroot)""; fi; fi; # Also check for WordPress in subdirectories; find ""$webroot"" -maxdepth 3 -type f -name 'version.php' | grep '/wp-includes/version.php$' | while read -r version_file; do; version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [ -n ""$version"" ]; then; wp_path=$(dirname ""$(dirname ""$version_file"")""); echo ""Found: $version (in $wp_path)""; fi; done;done",435,"27662.121772766113","0","0.1","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
7086,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash;;apt update && apt install -y postgresql postgresql-contrib;;PG_CONF=$(find /etc/postgresql/*/main/postgresql.conf -type f | head -n1);sed -i ""s/^#*listen_addresses.*/listen_addresses = '*'/"" ""$PG_CONF"";sed -i ""s/^#*port.*/port = 5433/"" ""$PG_CONF"";systemctl restart postgresql;;sudo -u postgres createdb -p 5433 storedb;sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Add default privileges for future tables in the schema;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb <<EOSQL;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOSQL",853,"44871.666431427","0","0.1","deepseek-r1","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","25.250000000000004"
9350,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home -type f -path '*/public_html/wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",51,"2221.4913368225098","0","0.1","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
6283,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rl ""FAIL"" /usr/results | grep ""/result.log$"" | wc -l",25,"1270.2789306640625","0","0.1","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
4770,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4771,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4767,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"A user was found when there were none to be found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8591,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5444,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"3283.9159965515137","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
9384,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ]; then; for file in ""$user/public_html/wp-includes/version.php""; do; if [ -f ""$file"" ]; then; version=$(grep \$wp_version ""$file"" | cut -d ""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi; done; fi;done",104,"1916.5894985198975","0.7","0.9","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,1,"Line 4: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","42"
6249,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} + | wc -l",33,"1245.1763153076172","0.7","0.9","gpt-4o","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
5645,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1245.6550598144531","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5648,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1245.6550598144531","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8592,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
9358,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -path ""*/wp-includes/version.php"" -exec grep ""\$wp_version"" {} \; | awk -F""'"" '{print ""Found: "" $2}'",767,"8172.644138336182","1","1","o1-mini","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"There are more results than there are websites. Perhaps because a webssite's wp-content folder contains a file named version.php",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.6"
8702,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
6267,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"1844.4526195526123","0.7","0.9","llama3.3-70b","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
4586,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2084.843635559082","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
5647,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1245.6550598144531","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
7105,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest",29,"1213.5059833526611","0.2","0.4","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
9371,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in user home directories under public_html find /home -type d -name *wp-includes* -print0 | while IFS= read -r -d '' wp; do # Navigate to the wp-includes directory cd *$wp* || continue # Check if the version.php file exists if [ -f version.php ]; then  # Extract the version number from version.php  version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]** version.php)  # Print the found version  echo *Found: $version* fi done",147,"3798.023223876953","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","32.35"
9372,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in user home directories under public_html find /home -type d -name *wp-includes* -print0 | while IFS= read -r -d '' wp; do # Navigate to the wp-includes directory cd *$wp* || continue # Check if the version.php file exists if [ -f version.php ]; then  # Extract the version number from version.php  version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]** version.php)  # Print the found version  echo *Found: $version* fi done",147,"3798.023223876953","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","32.35"
6250,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",240,"2745.370864868164","1","1","o1-mini","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
4773,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8309,"Experiment 1","FindDate","NL2Bash",3,1,"ncal -b 5 2013 | awk '/^Mo/ {print $2}' | xargs -I{} date -d ""2013-05-{}"" +""%Y-%m-%d""",1794,"61935.58621406555","0.7","0.9","deepseek-r1","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","8.67"
7323,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1409.6078872680664","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5703,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\''""]//' -e 's/[""'\''""]$//');export USERNAME",560,"34961.12394332886","0.7","0.9","deepseek-r1",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8602,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6649,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"users | tr ' ' '\n' | sort -u | wc -l",2352,"30389.30606842041","0.2","0.4","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.4"
6062,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"1447.681188583374","0","0.1","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7419,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",126,"11078.189373016357","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7477,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"1759.1488361358643","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
6648,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"last -a | awk '/still logged in/ {print $1}' | sort -u | wc -l",464,"116746.25015258789","0","0.1","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Count number of users logged in","10.959999999999999"
4774,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7475,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"1658.3073139190674","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7476,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"1658.3073139190674","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
6609,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1083.031177520752","0.2","0.4","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6610,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1083.031177520752","0.2","0.4","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
4580,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.apng"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.ico"" -o -name ""*.tiff"" -o -name ""*.tif"" -o -name ""*.webp"" \) -delete",87,"2460.860252380371","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
6634,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"2266.2038803100586","0","0.1","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6829,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7541,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1666.1195755004883","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
5649,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1245.6550598144531","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
6828,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6618,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",215,"2674.541711807251","1","1","o1-mini","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
4775,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7551,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1664.0357971191406","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7542,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1666.1195755004883","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
4923,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4776,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7714,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show ""$(ip route | awk '/default/ {print $5}')"" | awk '{print ""IP: "" $4}' | awk '{print $2}'",44,"1335.8829021453857","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.79"
6836,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
9086,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk '; BEGIN {; RS = ""\\*\\*\\*\\*\n"" # Properly escaped record separator; main = 0; other = 0; }; {; has_apples = ($0 ~ /apples=2/); has_z = ($0 ~ /Z=2/); if (has_apples && has_z) main++; if (!has_apples) other++; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",1840,"92022.91297912598","0.2","0.4","deepseek-r1","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.72"
4777,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5455,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in ./*.sh; do
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",444,"3579.9190998077393","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"./subdir.sh: ./subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
9089,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' '; BEGIN { has=0; other=0 }; {; a2 = index($0, ""apples=2""); z2 = index($0, ""Z=2""); if (a2 && z2) has++; if (!a2) other++; }; END { printf ""Final counter value= %d ; other= %d\n"", has, other }'",5176,"237328.7959098816","0.7","0.9","deepseek-r1","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
4781,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
9080,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ';BEGIN {; RS = ""\\*\\*\\*\\*\n""; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; line = lines[i]; sub(/^[[:space:]]+/, """", line); sub(/[[:space:]]+$/, """", line); if (line == ""apples=2"") a = 1; if (line == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",7220,"344917.1841144562","0","0.1","deepseek-r1","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","14.02"
7555,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2475.473642349243","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6834,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
4783,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6942,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
4750,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6946,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
4751,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6837,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7558,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | cut -d= -f2) echo *exit code: $exit_code*",43,"1756.9410800933838","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4752,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6841,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
9062,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_z2 = 0; has_apples2 = 0; if ($0 ~ /\nZ=2(\n|$)/) has_z2 = 1; if ($0 ~ /\napples=2(\n|$)/) has_apples2 = 1; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",329,"18830.098628997803","0","0.1","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.639999999999999"
4753,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7559,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | cut -d= -f2) echo *exit code: $exit_code*",43,"1756.9410800933838","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7461,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -22",21,"1361.4814281463623","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4748,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6842,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6956,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
4754,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7706,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}(?=\/)' | grep -v '127.0.0.1' | head -n 1 | awk '{print ""IP: "" $1}';ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}(?=\/)' | head -n 1 | awk '{print ""IP: "" $1}'",181,"13967.5874710083","0.7","0.9","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","24.33"
6843,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7478,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then echo *update needed* else echo *update not needed* fi",43,"1759.1488361358643","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7501,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",40,"7183.786392211914","0.7","0.9","deepseek-v3","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
9157,"Experiment 1","CountRecords","NL2Bash",3,2,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values in the correct format;echo ""Final counter value= {$z2_apples2_counter} ; other= {$no_apples2_counter}""",168,"2175.8649349212646","0.7","0.9","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.550000000000001"
7712,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: "" $4}'",36,"1062.5133514404297","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"Only output the one address after *IP: * in one line. If there exist any virtual interfaces, only output the physical interface's IP",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.24"
8625,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
7564,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat | tail -n 1 | awk '{print $NF}') echo *exit code: $exit_code*",38,"9299.698829650879","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7500,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if [ ""$(apt-get -s upgrade htop 2>/dev/null | grep -oP '^Inst \K[^ ]+')"" == ""htop"" ]; then; echo ""update needed"";else; echo ""update not needed"";fi",195,"13085.356950759888","0.2","0.4","deepseek-v3","Ir vecāka versija",1,"",False,"The package is outdated but update not needed was outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
9142,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2561.7051124572754","0","0.1","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
7707,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: "" $4}'",36,"1355.6623458862305","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"Only output the one address after *IP: * in one line",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.24"
6934,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
7495,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",40,"6778.597831726074","0","0.1","deepseek-v3","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
6476,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; gsub(/^""|""$/, """", $i);; if (tolower($i) == ""price"") {; col = i;; break;; }; }; if (col == 0) {; print ""Error: Price column not found."" > ""/dev/stderr""; exit 1; };};NR > 1 {; gsub(/[^0-9.]/, """", $col);; if ($col != """") {; sum += $col;; count++;; };};END {; printf ""Mean: %.2f\n"", (count > 0) ? sum/count : 0;}' products.csv",3085,"29639.60027694702","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"Error: Price column not found. ",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6500,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"1244.386911392212","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
5604,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",25,"1552.9584884643555","0.7","0.9","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"The script should not load a variable that is commented out.",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","7.2","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
6845,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with no flags passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
6423,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; }; if (!col) {; print ""Mean: 0.00""; exit; }; }; NR>1 && col {; # Remove any commas and quotes; gsub(/["",]/, """", $col); # Replace comma decimal separators with dots if necessary; gsub(/,/, ""."", $col); if ($col ~ /^[0-9.]+$/) {; sum += $col; count++; }; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",1494,"11677.667140960693","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
5399,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[].Vulnerabilities[]?.VulnerabilityID' | sort -u | xargs);if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",934,"16701.20644569397","0","0.1","deepseek-r1","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
6431,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean: * sum/count}' products.csv",34,"1643.8114643096924","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6791,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
5467,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3666.095495223999","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
7503,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q htop; then
 echo ""update needed""
else
 echo ""update not needed""
fi",42,"1159.5494747161865","0","0.1","gpt-3.5-turbo","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
5876,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | grep -c "": warning:"");echo ""Count warning: $count""",831,"47518.707275390625","0.7","0.9","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5878,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | grep -c "": warning:"");echo ""Count warning: $count""",831,"47518.707275390625","0.7","0.9","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7110,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported:rw alpine:latest",31,"1184.4866275787354","0.7","0.9","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7101,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported:ro alpine",29,"1324.6357440948486","0","0.1","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7509,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"3618.99471282959","0","0.1","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
4825,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5854,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",2136,"24517.924308776855","0","0.1","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7129,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"1461.2927436828613","0.2","0.4","llama3.3-70b","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
9137,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' '; { ; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) { ; has_both++ ; } ; if (!$0 ~ /apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; printf ""Final counter value=%d ; other=%d\n"", has_both, doesnt_have_apples ; }'",125,"2159.508228302002","0.7","0.9","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.56"
6795,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
6846,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
8979,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash
IFS= read -r -d % text
echo ""$text"" # Demonstrate usage - remove if actually used elsewhere",372,"21630.234241485596","0.7","0.9","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
9126,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}' | sed '/^$/d'",68,"1558.4194660186768","0","0.1","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.31"
9127,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}' | sed '/^$/d'",68,"1558.4194660186768","0","0.1","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.31"
5902,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2348.8032817840576","0.7","0.9","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5903,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2348.8032817840576","0.7","0.9","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5606,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME_LINE=$(grep -w '^USERNAME' .env);USERNAME=$(echo ""$USERNAME_LINE"" | cut -d '=' -f2);export USERNAME;echo ""USERNAME: $USERNAME""",44,"1349.3375778198242","0.7","0.9","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.300000000000001"
4844,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
5788,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;count=$(shellcheck ./*.sh --format=json | jq '[.[] | select(.level==""warning"")] | length');echo ""Count warning: $count""",822,"7171.492338180542","1","1","o1-mini","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5590,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"1446.8586444854736","0.2","0.4","gpt-4o",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5801,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"3047.4321842193604","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5803,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"3047.4321842193604","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
8842,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"shopt -s nullglob
for file in /usr/src/*.java; do
 ln -sf ""$file"" ""./$(basename ""$file"")""
done
shopt -u nullglob",1127,"52540.082693099976","0.7","0.9","deepseek-r1","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","6.25"
8843,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"shopt -s nullglob
for file in /usr/src/*.java; do
 ln -sf ""$file"" ""./$(basename ""$file"")""
done
shopt -u nullglob",1127,"52540.082693099976","0.7","0.9","deepseek-r1","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","6.25"
4845,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
4909,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
6848,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
8867,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"#!/bin/bash
for src_file in /usr/src/*.java; do
 if [ -f ""$src_file"" ]; then
 ln -s ""$src_file"" ""./$(basename ""$src_file"")""
 fi
done",55,"8173.0711460113525","0.2","0.4","deepseek-v3","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","9.899999999999999"
6616,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -E -v '^$' | wc -l",20,"1047.8804111480713","0.7","0.9","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.1"
8868,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",33,"5968.699932098389","0.7","0.9","deepseek-v3","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8980,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash
IFS= read -r -d % text
echo ""$text"" # Demonstrate usage - remove if actually used elsewhere",372,"21630.234241485596","0.7","0.9","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
5804,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"3047.4321842193604","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7581,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitStatus myservice | sed 's/ExitStatus=//g' | xargs -I {} echo ""exit code: {}""",38,"1760.8323097229004","0.7","0.9","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
8869,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",33,"5968.699932098389","0.7","0.9","deepseek-v3","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
4882,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5809,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1846.1039066314697","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6849,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
6617,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",215,"2674.541711807251","1","1","o1-mini","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
8871,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",14,"948.1234550476074","0","0.1","gpt-3.5-turbo","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
8350,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -exec ls -l {} \;",27,"2183.0406188964844","0.2","0.4","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
6193,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"2061.478614807129","0.2","0.4","deepseek-v3","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6818,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6194,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"2061.478614807129","0.2","0.4","deepseek-v3","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6393,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1764.254093170166","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6815,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A file was deleted from destination (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
5226,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [[ -f .gitignore ]]; then
 git init -q
 git clean -Xdf
 rm -rf .git
else
 echo ""Error: No .gitignore file found"" >&2
 exit 1
fi",1816,"18195.217847824097","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
5309,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w 32 -d",35,"1457.287311553955","0.7","0.9","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
5811,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level] | count(.[] | select(. == *warning*))') echo *Count warning: $count*",57,"3464.5230770111084","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"jq: error: count/1 is not defined at <top-level>, line 1: [.[] | .[].level] | count(.[] | select(. == *warning*))   jq: 1 compile error ",False,"The script should have outputted *Count warning: 0* since there were no warning level errors.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5812,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level] | count(.[] | select(. == *warning*))') echo *Count warning: $count*",57,"3464.5230770111084","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"jq: error: count/1 is not defined at <top-level>, line 1: [.[] | .[].level] | count(.[] | select(. == *warning*))   jq: 1 compile error ",False,"The script should have outputted *Count warning: 0* since there were no scripts to check.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5305,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 -d",36,"1764.8732662200928","0.2","0.4","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
5230,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",1455,"19021.294355392456","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5321,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | sort | awk ';{; arr[$1]=arr[$1] $2 ""\n""; count[$1]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""MD5: %s\nFiles:\n%s"", md5, arr[md5]; }; };}'",1010,"144247.76482582092","0.7","0.9","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","10"
5819,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level | select(. == *warning*)] | length') echo *Count warning: $count*",54,"2051.1889457702637","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"jq: error (at <stdin>:1): Cannot index string with string *level* ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5320,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | sort | awk 'seen[$1]++' | cut -d' ' -f3- | xargs -I{} grep "" {}"" <(find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} +)",729,"8961.753606796265","0.2","0.4","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5240,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -fdX",100,"4154.205799102783","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5120,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5249,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt-get install -y git

# Use git to clean the directory based on .gitignore rules
git clean -Xdf",82,"4283.616065979004","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
8083,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""^$(date +""%b %e"")"" /var/log/auth.log \;| grep -E 'Failed password|authentication failure' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",6324,"284991.055727005","0.2","0.4","deepseek-r1","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.13"
5335,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{count[$1]++; lines[$1]=lines[$1] $2 ""\n""} END {for (md5 in count) if (count[md5] > 1) printf ""%s\n%s"", md5, lines[md5]}'",336,"8404.82211112976","0.7","0.9","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.76"
5250,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt-get install -y git

# Use git to clean the directory based on .gitignore rules
git clean -Xdf",82,"4283.616065979004","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
7593,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"code=$(journalctl -u myservice --no-pager | grep -a ""Main process exited, code=exited, status="" | tail -n1 | sed -n 's/.*status=\([0-9]\+\).*/\1/p');[ -z ""$code"" ] && code=$(systemctl show myservice --property=ExecMainStatus --value);echo ""exit code: ${code:-0}""",3222,"563536.4928245544","0","0.1","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
8162,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log | grep -i ""failed"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $count""",200,"13297.080278396606","0.2","0.4","deepseek-v3","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5338,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",38,"1279.4020175933838","0","0.1","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
5237,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -Xdf",152,"4310.838222503662","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
5471,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"3794.7933673858643","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
8163,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log | grep -i ""failed"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $count""",200,"13297.080278396606","0.2","0.4","deepseek-v3","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
7532,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1 | grep -oP 'status=\K\d+' | tail -n 1 | xargs -I {} echo ""exit code: {}""",49,"5026.4892578125","0.7","0.9","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","10.85"
8166,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check all auth logs including rotated ones;log_files=(/var/log/auth.log /var/log/auth.log.[0-9] /var/log/auth.log.[0-9].gz);;# Patterns for different types of failed authentication;patterns=(; ""Failed password""; ""authentication failure""; ""FAILED LOGIN""; ""invalid user""; ""user unknown"";);;# Get today's date in log format (e.g., ""Jan 1"");today=$(date '+%b %e');;# Temporary file for storing results;temp_file=$(mktemp);;for log in ""${log_files[@]}""; do; if [ -f ""$log"" ]; then; if [[ ""$log"" == *.gz ]]; then; zgrep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; else; grep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; fi; fi;done;;# Extract usernames from logs and count;count=$(awk '{; if (/invalid user|user unknown/) {; for(i=1; i<=NF; i++) if ($i == ""user"") {print $(i+1); break}; } else if (/authentication failure/) {; for(i=1; i<=NF; i++) if ($i == ""user="") {print $(i+1); break}; } else {; for(i=1; i<=NF; i++) if ($i == ""for"") {print $(i+1); break}; };}' ""$temp_file"" | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count"";rm ""$temp_file""",540,"27681.88762664795","0.2","0.4","deepseek-v3","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5472,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3961.127758026123","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
5268,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Delete all files according to .gitignore
find . -type f -print | git check-ignore --stdin | xargs rm -f",35,"1350.208044052124","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.3"
8347,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '/^-r/ {print $0}'",19,"1252.0060539245605","0.2","0.4","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
6816,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
5990,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1354.0873527526855","0","0.1","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8170,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Find all auth log files (including rotated ones);log_files=();possible_locations=(; ""/var/log/auth.log""; ""/var/log/auth.log.1""; ""/var/log/auth.log.*.gz""; ""/var/log/secure""; ""/var/log/secure.*"";);;for loc in ""${possible_locations[@]}""; do; for file in $loc; do; if [ -f ""$file"" ] || [[ ""$file"" == *.gz ]]; then; log_files+=(""$file""); fi; done;done;;if [ ${#log_files[@]} -eq 0 ]; then; echo ""Users: 0 (no auth logs found)""; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(zgrep -h ""$(date '+%b %e')"" ""${log_files[@]}"" 2>/dev/null | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -E ""user=|user |for |login failed"" | \; sed -E 's/.*(user=|user |for )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",419,"20934.237241744995","0.7","0.9","deepseek-v3","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6857,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with no flags passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
5989,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1646.7041969299316","0","0.1","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6654,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | awk '{print $1}' | sort -u | wc -l",1976,"18515.494346618652","0.7","0.9","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.549999999999999"
6821,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A file was deleted from destination (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8353,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -ls",22,"1272.392988204956","0.7","0.9","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
5260,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore -q {} 2>/dev/null; then rm {}; fi' \;",36,"2254.000663757324","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
6823,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8325,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-06"" +%Y-%m-%d",23,"2163.318395614624","0.2","0.4","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","1.45"
8202,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; relative_path=$(dirname ""$found_file"" | sed 's|^/etc/docs/||'); target_dir=""/etc/movedDocs/${relative_path}""; mkdir -p ""$target_dir""; mv -f ""$found_file"" ""$target_dir/"" 2>/dev/null; mv -f ""$docx_file"" ""$target_dir/"" 2>/dev/null;done",1640,"60423.38562011719","0.2","0.4","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","30.299999999999997"
8327,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""$(date -d ""2013-05-01"" +%Y-%m-01) + 7 - $(date -d ""2013-05-01"" +%u) days"" +%Y-%m-%d",55,"2279.484510421753","0.7","0.9","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘2013-05-01 + 7 - 3 days’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
8144,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $1}' | sort | uniq -d | awk 'NR>2 {a[$1]++} END {for (i in a) if (a[i]>=3) b++; print b}')""",77,"1950.272560119629","0.2","0.4","llama3.3-70b","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5166,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"1673.9869117736816","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
5165,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"1673.9869117736816","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
8153,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"users=$(awk -v date=""$(date +""%b %d"")"" '/failed password for|authentication failure|invalid user/ && $0 ~ date {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",76,"2972.919702529907","0.7","0.9","llama3.3-70b","Autorizācijas ar su un sudo",2,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5170,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1650.4566669464111","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5418,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep -E ""^\d{4}"" | awk '{print $1}' | xargs echo ""Here are the vulnerabilities:"" || echo ""The project is clean""",54,"1145.8072662353516","0.2","0.4","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.3"
8206,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 relative_path=""${file#/etc/docs/}""
 dest_dir=""/etc/movedDocs/$(dirname ""$relative_path"")""
 mkdir -p ""$dest_dir""
 mv -- ""$file"" ""$dest_dir/""
 mv -- ""${file%.found}"" ""$dest_dir/""
done",1136,"43119.956970214844","0.7","0.9","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","13.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","26.9"
8243,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2377.5954246520996","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
8196,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs || exit 1;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; if mkdir -p ""$target_dir""; then; if mv -v -- ""$found_file"" ""$docx_file"" ""$target_dir/""; then; echo ""Moved: $found_file and $docx_file to $target_dir""; else; echo ""Error moving files: $found_file and $docx_file"" >&2; fi; else; echo ""Error creating directory: $target_dir"" >&2; fi; else; echo ""No matching .docx for: $found_file"" >&2; fi;done",7374,"267160.3276729584","0","0.1","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","77.19999999999999"
8250,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",78,"2483.449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
5770,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length // 0');echo ""Count warning: $count""",59,"1450.573444366455","0","0.1","gpt-4o","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5771,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length // 0');echo ""Count warning: $count""",59,"1450.573444366455","0","0.1","gpt-4o","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5173,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git init
git add .
git commit -m ""Initial commit""
git clean -fdX",25,"1061.1178874969482","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"mmonly chosen instead of 'master' are 'main', 'trunk' and hint: 'development'. The just-created branch can be renamed via this command: hint: hint: 	git branch -m <name> Author identity unknown *** Please tell me who you are. Run git config --global user.email *you@example.com*  git config --global user.name *Your Name* to set your account's default identity. Omit --global to set the identity only in this repository. fatal: unable to auto-detect email address (got 'root@debian.(none)') ",False,"The script shouldn't have initiated a git repository in the directory.",0,0,0,0,"","10.5","MINOR_SIDE_EFFECT","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.6"
5172,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git init
git add .
git commit -m ""Initial commit""
git clean -fdX",25,"1061.1178874969482","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.6"
5796,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1859.370470046997","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8126,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"1972.3265171051025","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
8237,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2384.0949535369873","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
5780,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;total_warnings=0;;for script in *.sh; do; warnings=$(shellcheck ""$script"" --format json | jq '[.[] | select(.level == ""warning"")] | length'); total_warnings=$((total_warnings + warnings));done;;echo ""Count warning: $total_warnings""",74,"1857.2564125061035","0.7","0.9","gpt-4o","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5205,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1555.9234619140625","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
8127,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"1972.3265171051025","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
8279,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Calculate relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",328,"16522.867679595947","0.2","0.4","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
8238,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2384.0949535369873","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
9294,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) {  print a[left] } } ' GHJ1.txt GHJ2.txt | column -t",118,"3363.9516830444336","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.979999999999999"
5807,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1846.1039066314697","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5207,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"2176.192045211792","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
8128,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",128,"3312.5927448272705","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
8285,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Get relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",324,"16209.774017333984","0.7","0.9","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
8286,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Get relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",324,"16209.774017333984","0.7","0.9","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
4989,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4990,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8133,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/Failed password/ && $1 == *$(date +*%b*)* && $2 == *$(date +*%d*)* {print $9}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",67,"2054.0895462036133","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.86"
5476,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2773.3449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
5816,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level | select(. == *warning*)] | length') echo *Count warning: $count*",54,"2051.1889457702637","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","6.199999999999999","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5214,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git ls-files --others -z --exclude-standard | xargs -0 -p rm",24,"1290.9867763519287","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"rm .gitignore program.js subdir/program2.js temp/.gitkeepxargs: failed to open /dev/tty for reading: No such device or address ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.95"
5817,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level | select(. == *warning*)] | length') echo *Count warning: $count*",54,"2051.1889457702637","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"",False,"The script should have outputted *Count warning: 0* since there were no scripts to check.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5825,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1853.0542850494385","0","0.1","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5826,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1853.0542850494385","0","0.1","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8294,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/'$(basename ""$1"" .docx)'.found' _ {} \;",184,"2880.166530609131","0.2","0.4","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"All nessesary *.docx.found files were not moved",0,1,1,0,"Line 10: Quote this to prevent word splitting. Line 10: This will expand once before find runs, not per file found. ","2.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
4991,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7864,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4616,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",779,"14366.31989479065","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"find: Unknown argument to -type: ( ",False,"An image was not deleted",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.7"
6517,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",39,"1146.3119983673096","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
8295,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/'$(basename ""$1"" .docx)'.found' _ {} \;",184,"2880.166530609131","0.2","0.4","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"All nessesary *.docx.found files were not moved",0,1,1,0,"Line 10: Quote this to prevent word splitting. Line 10: This will expand once before find runs, not per file found. ","2.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
4997,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 4c17017..b19e6d5 develop -> origin/develop No stash entries found. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"File content seems to be incorrect after running the script. It is equal to neither local, nor remote changes.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
5609,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME_LINE=$(grep -w '^USERNAME' .env);USERNAME=$(echo ""$USERNAME_LINE"" | cut -d '=' -f2);export USERNAME;echo ""USERNAME: $USERNAME""",44,"1349.3375778198242","0.7","0.9","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.300000000000001"
5004,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server f1c072c..87209a9 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
6089,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"3386.063575744629","0.2","0.4","gpt-4o","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
4621,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",551,"6365.650653839111","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4619,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",551,"6365.650653839111","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
7865,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7866,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7861,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8220,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2480.368137359619","0.2","0.4","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
5010,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server bb6e9da..824eb98 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
4628,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",1186,"20068.64047050476","0.7","0.9","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4624,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",1186,"20068.64047050476","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
7393,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1285,"461694.20313835144","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5850,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",2136,"24517.924308776855","0","0.1","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5845,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -n *.sh 2>/dev/null | grep -c ""warning:"")
echo ""Count warning: $count""",33,"1847.5515842437744","0.7","0.9","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5860,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f gcc *.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",1195,"13477.10919380188","0.2","0.4","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","12.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5853,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",2136,"24517.924308776855","0","0.1","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5855,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",524,"31243.82448196411","0","0.1","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7869,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4985,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 4c17017..b19e6d5 develop -> origin/develop No stash entries found. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"File content seems to be incorrect after running the script. It is equal to neither local, nor remote changes.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
6601,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"7274.859189987183","0.7","0.9","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6603,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w;users | tr ' ' '\n' | sort -u | wc -l",147,"9091.722011566162","0.7","0.9","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","12.05"
4608,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -delete",940,"87836.06743812561","0","0.1","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
5478,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2773.3449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
5875,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | grep -c "": warning:"");echo ""Count warning: $count""",831,"47518.707275390625","0.7","0.9","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8258,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"3181.941270828247","0.2","0.4","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"find: sed: read error on /etc/movedDocs: Is a directory missing argument to `-exec' ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
6655,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"w -hs | awk '{print $1}' | sort -u | wc -l",2337,"78056.16736412048","0.7","0.9","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","10.6"
8992,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done

echo ""$text""",54,"1355.7870388031006","0.2","0.4","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
5871,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | wc -l);echo ""Count warning: $count""",1473,"15083.918809890747","0.7","0.9","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5025,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4647,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4460.139036178589","0.2","0.4","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
5877,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | grep -c "": warning:"");echo ""Count warning: $count""",831,"47518.707275390625","0.7","0.9","deepseek-r1","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5880,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2545.571804046631","0","0.1","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5885,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",78,"8270.371675491333","0","0.1","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7876,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7011,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",390,"8613.985300064087","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
9403,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C ""$1"" ""mysqldump -u TEST_USER -pTEST TEST_DB"" | mysql -u TEST_USER -pTEST TEST_DB",852,"44728.004455566406","0.7","0.9","deepseek-r1","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
7012,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",390,"8613.985300064087","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
9031,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"1655.2555561065674","0.2","0.4","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
4652,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",161,"2760.106325149536","0.2","0.4","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7423,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -printf ""%p\n""
find /usr/info -type f -mtime +20 -mtime -22 -printf ""%p\n""",173,"12292.346239089966","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.4"
7424,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -printf ""%p\n""
find /usr/info -type f -mtime +20 -mtime -22 -printf ""%p\n""",173,"12292.346239089966","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.4"
5765,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length');echo ""Count warning: $count""",56,"1992.6517009735107","0","0.1","gpt-4o","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7882,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5785,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;count=$(shellcheck ./*.sh --format=json | jq '[.[] | select(.level==""warning"")] | length');echo ""Count warning: $count""",822,"7171.492338180542","1","1","o1-mini","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
9400,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh -C ""$1"" ""MYSQL_PWD=TEST mysqldump -u TEST_USER --no-tablespaces --single-transaction TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB",630,"34052.325963974","0","0.1","deepseek-r1","jāpārnes datubāze",1,"",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.9"
7006,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/13/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/13/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",322,"6968.606233596802","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/13/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 14: /etc/postgresql/13/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
4658,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4915.4016971588135","0.7","0.9","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7427,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -printf ""%p\n""
find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22 -printf ""%p\n""",129,"10251.765727996826","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.6"
5900,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2348.8032817840576","0.7","0.9","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7428,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -printf ""%p\n""
find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22 -printf ""%p\n""",129,"10251.765727996826","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.6"
9427,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"# Dump the MySQL database over a compressed SSH tunnel
ssh -C $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip > test_db_dump.sql.gz

# Transfer the dump file back to the local machine
scp $1:test_db_dump.sql.gz .

# Import the dump file into another MySQL database
zcat test_db_dump.sql.gz | mysql -u TEST_USER -pTEST TEST_DB",130,"1862.5526428222656","0.2","0.4","gpt-3.5-turbo","jāpārnes datubāze",1,"mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces scp: test_db_dump.sql.gz: No such file or directory mysql: [Warning] Using a password on the command line interface can be insecure. ",False,"The data was not transferred to the other database",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. Line 6: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","13.05"
6280,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results | grep ""/result.log$"" | wc -l",25,"1040.5552387237549","0","0.1","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
4676,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -exec rm {} +",48,"987.4520301818848","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",False,"An image was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.35"
5905,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",90,"9074.62453842163","0.7","0.9","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5906,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",90,"9074.62453842163","0.7","0.9","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
9013,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; echo -n *$char*; done; })",53,"1957.531452178955","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
4682,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" \) -exec rm {} +",51,"1451.6210556030273","0.2","0.4","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4679,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" \) -exec rm {} +",51,"1451.6210556030273","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
5802,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"3047.4321842193604","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7883,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7884,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7879,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6394,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1764.254093170166","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
9406,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh ""$1"" ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",40,"4842.550277709961","0","0.1","gpt-4o","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
6272,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -exec grep -l -- 'FAIL' {} + | wc -l",1013,"12082.978963851929","0.7","0.9","deepseek-r1","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
4690,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -exec rm {} +",41,"968.106746673584","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.2"
7851,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7852,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6119,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3666.698694229126","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6120,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3666.698694229126","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
7860,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5611,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash;export USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-)",617,"21331.657886505127","1","1","o1-mini",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
9421,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip -c | gzip -dc | mysql -u TEST_USER -pTEST TEST_DB",43,"1959.773302078247","0.2","0.4","llama3.3-70b","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","10.6"
6124,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3562.488794326782","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
4699,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" \) -exec rm {} +",44,"2213.918685913086","0.7","0.9","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7270,"Experiment 1","Factorial","NL2Bash",2,1,"python3 -c 'import math; print(math.factorial(623))'",545,"4174.49426651001","1","1","o1-mini","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","1.4"
7449,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -22",21,"952.0254135131836","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6401,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1545.0809001922607","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6405,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2247.920274734497","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6406,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2247.920274734497","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6428,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean:*, sum/count}' products.csv",33,"1649.4312286376953","0","0.1","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6131,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",105,"4065.983295440674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
9424,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh ""$1"" ""mysqldump -h localhost -u TEST_USER -pTEST TEST_DB"" | gzip -c | gzip -dc | mysql -h localhost -u TEST_USER -pTEST TEST_DB",50,"1365.3645515441895","0.7","0.9","llama3.3-70b","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","10.7"
6014,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",1102,"355343.9531326294","0","0.1","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4667,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" -exec rm {} +",55,"1939.012050628662","0","0.1","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.5"
8020,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8021,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6091,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"3386.063575744629","0.2","0.4","gpt-4o","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
8905,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 reversed=$(echo ""$line"" | rev)
 echo ""result = $reversed""
done < info.txt",39,"5864.692211151123","0","0.1","deepseek-v3","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","7.65"
4672,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" \) -exec rm {} +",58,"1852.7305126190186","0","0.1","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
6421,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; }; if (!col) {; print ""Mean: 0.00""; exit; }; }; NR>1 && col {; # Remove any commas and quotes; gsub(/["",]/, """", $col); # Replace comma decimal separators with dots if necessary; gsub(/,/, ""."", $col); if ($col ~ /^[0-9.]+$/) {; sum += $col; count++; }; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",1494,"11677.667140960693","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
8022,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6116,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3454.3325901031494","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6434,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {printf *Mean: %.2f\n*, sum/count}' products.csv",38,"2246.554374694824","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
9265,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ';FNR == NR {; key = $1; rest = substr($0, index($0, "" "") + 1); if (key in merged) {; merged[key] = merged[key] "" "" rest; } else {; merged[key] = $0; }; next;};{; key = $1; rest = substr($0, index($0, "" "") + 1); if (key in merged) {; merged[key] = merged[key] "" "" rest; } else {; merged[key] = $0; };};END {; # Print lines starting with ""Exe"" first; for (key in merged) {; if (key ~ /^Exe/) {; print merged[key]; delete merged[key]; }; }; # Print remaining lines; for (key in merged) {; print merged[key]; };}' GHJ1.txt GHJ2.txt",7729,"363004.57286834717","0.2","0.4","deepseek-r1","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","14.049999999999999"
4514,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"2020.2162265777588","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4518,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"2020.2162265777588","0.2","0.4","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
8027,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8028,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7057,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash # Update package lists and install PostgreSQL 17 apt update apt install -y postgresql-17 # Stop the current PostgreSQL 16 cluster pg_dropcluster 16 main --stop # Create a new PostgreSQL 17 cluster pg_createcluster 17 main --start # Upgrade the data from PostgreSQL 16 to PostgreSQL 17 pg_upgradecluster 16 main # Verify the upgrade pg_lsclusters # Remove the old PostgreSQL 16 cluster pg_dropcluster 16 main --stop",124,"3777.538299560547","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: specified cluster does not exist Error: specified cluster does not exist ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","8.85"
7060,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash # Log file for the upgrade process LOGFILE=*/var/log/postgresql_upgrade.log* # Function to log messages log_message() { echo *$(date '+%Y-%m-%d %H:%M:%S') - $1* | tee -a $LOGFILE } # Stop the current PostgreSQL 16 cluster log_message *Stopping PostgreSQL 16 cluster...* pg_dropcluster 16 main --stop if [ $? -ne 0 ]; then log_message *Failed to stop PostgreSQL 16 cluster.* exit 1 fi # Install PostgreSQL 17 log_message *Updating package list...* apt update >> $LOGFILE 2>&1 if [ $? -ne 0 ]; then log_message *Failed to update package list.* exit 1 fi log_message *Installing PostgreSQL 17...* apt install -y postgresql-17 >> $LOGFILE 2>&1 if [ $? -ne 0 ]; then log_message *Failed to install PostgreSQL 17.* exit 1 fi # Create a new PostgreSQL 17 cluster log_message *Creating new PostgreSQL 17 cluster...* pg_createcluster 17 main --start if [ $? -ne 0 ]; then log_message *Failed to create new PostgreSQL 17 cluster.* exit 1 fi # Upgrade the cluster from 16 to 17 log_message *Upgrading cluster from 16 to 17...* pg_upgradecluster 16 main if [ $? -ne 0 ]; then log_message *Failed to upgrade cluster from 16 to 17.* exit 1 fi # Drop the old PostgreSQL 16 cluster log_message *Dropping old PostgreSQL 16 cluster...* pg_dropcluster 16 main if [ $? -ne 0 ]; then log_message *Failed to drop old PostgreSQL 16 cluster.* exit 1 fi # Restart the PostgreSQL 17 cluster to ensure everything is working log_message *Restarting PostgreSQL 17 cluster...* systemctl restart postgresql if [ $? -ne 0 ]; then log_message *Failed to restart PostgreSQL 17 cluster.* exit 1 fi log_message *PostgreSQL upgrade from 16 to 17 completed successfully.*",565,"13683.26997756958","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"Error: cluster configuration already exists ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",1,0,0,0,". Line 22: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. Line 29: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. Line 37: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. Line 45: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. Line 53: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. Line 61: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","4.5","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","82.60000000000001"
4520,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1253.6194324493408","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4521,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1253.6194324493408","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
6443,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if ($0 ~ /^[0-9]+,/) {sum+=$2; count++}} END {if (count > 0) print ""Mean: "" sum/count; else print ""No numeric values found""}' products.csv",61,"1657.3429107666016","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
8034,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8030,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4525,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -exec rm -f {} +",68,"2630.394220352173","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4526,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -exec rm -f {} +",68,"2630.394220352173","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
8007,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8008,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8009,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8010,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7221,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"2670.0408458709717","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data gpg: Signature made Wed 26 Mar 2025 03:36:09 PM PDT gpg:  using RSA key 0F06FF86BEEAF4E71866EE5232EE5355A6BC6E42 gpg: Can't check signature: No public key ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
9312,"Experiment 1","PrintTable","NL2Bash",3,1,"join <(sort GHJ1.txt) <(sort GHJ2.txt) | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }'",158,"2359.0948581695557","0","0.1","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
7228,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 if gpg --list-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 > /dev/null 2>&1; then gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL* else echo *Key not found* fi",205,"5890.5956745147705","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data ",False,"The file was invalid but FAIL was not outputted",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","24.5"
7450,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -22",21,"952.0254135131836","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6622,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1366.081953048706","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
4506,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"1628.7322044372559","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
6460,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='[^,]*|""[^""]*""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",49,"1946.4893341064453","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.8599999999999999"
4507,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"1628.7322044372559","0","0.1","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
8011,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6490,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",151,"11077.256917953491","0.2","0.4","deepseek-v3","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6491,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",151,"11077.256917953491","0.2","0.4","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
4510,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1377.350091934204","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4511,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1377.350091934204","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
9282,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt GHJ2.txt; join -j 1 GHJ1.txt GHJ2.txt;} | sort -k 1,1 -u | column -t",51,"1357.6617240905762","0.7","0.9","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","7.800000000000001"
9366,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format echo *Found: $version* done",122,"3158.383369445801","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
6473,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; gsub(/^""|""$/, """", $i);; if (tolower($i) == ""price"") {; col = i;; break;; }; }; if (col == 0) {; print ""Error: Price column not found."" > ""/dev/stderr""; exit 1; };};NR > 1 {; gsub(/[^0-9.]/, """", $col);; if ($col != """") {; sum += $col;; count++;; };};END {; printf ""Mean: %.2f\n"", (count > 0) ? sum/count : 0;}' products.csv",3085,"29639.60027694702","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"Error: Price column not found. ",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6466,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; # Remove quotes and trim whitespace from header name; gsub(/[""]/, """", $i); header = tolower($i); sub(/^[ \t]+/, """", header); sub(/[ \t]+$/, """", header); if (header == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; # Remove currency symbols, commas, and quotes from the value; gsub(/[""$£,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",905,"9772.428274154663","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","14.35"
8012,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6481,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"" || $i == ""\""price\"""") {; col = i; }; };};NR > 1 {; if ($col != """") {; # Remove all non-numeric characters except decimal point; gsub(/[^0-9.]/, """", $col); # Handle empty strings after cleanup; if ($col != """") {; sum += $col; count++; }; };};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",1880,"19606.629133224487","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","7.25","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
5588,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1450.5157470703125","0","0.1","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
9303,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; [[ $line =~ ^Exe ]] && echo ""$line""; join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe"")",75,"2761.021137237549","0.2","0.4","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9370,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in user home directories under public_html for wp in $(find /home -type d -name *wp-includes*); do # Navigate to the wp-includes directory cd *$wp* || continue # Check if the version.php file exists if [ -f version.php ]; then  # Extract the version number from version.php  version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]** version.php)  # Print the found version  echo *Found: $version* fi done",135,"3356.889247894287","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"",0,0,1,0,"Line 4: For loops over find output are fragile. Use find -exec or a while read loop. ","11.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","18.75"
4587,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2084.843635559082","0.2","0.4","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4588,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2084.843635559082","0.2","0.4","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7453,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22",26,"1184.7968101501465","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.75"
6479,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; }; };};NR > 1 && $col != """" {; gsub(/,/, """", $col); sum += $col; count++;};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",955,"12679.79907989502","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","7.71"
6625,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1066.3683414459229","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6624,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",21,"1549.4449138641357","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.549999999999999"
9380,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ] && [ -d ""$user/public_html"" ]; then; if [ -f ""$user/public_html/wp-includes/version.php"" ]; then; version=$(grep -oP 'Version: \K[0-9\.]+' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; else; echo ""Found: Unknown""; fi; fi; fi;done",127,"1761.1210346221924","0.2","0.4","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","46.8"
9364,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format if [ -n *$version* ]; then  echo *Found: $version* else  echo *Found: Unknown version in $version_file* fi done",196,"4598.582744598389","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
4591,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.apng"" -o -name ""*.svg"" -o -name ""*.webp"" -o -name ""*.ico"" -o -name ""*.tiff"" \) -delete",87,"4966.463565826416","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
4592,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.apng"" -o -name ""*.svg"" -o -name ""*.webp"" -o -name ""*.ico"" -o -name ""*.tiff"" \) -delete",87,"4966.463565826416","0.2","0.4","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
7454,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22",26,"1184.7968101501465","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.75"
6486,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",128,"11079.681873321533","0","0.1","deepseek-v3","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
8070,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
8052,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5252,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Install rsync if not already installed
apt-get install -y rsync

# Create a temporary directory
temp_dir=$(mktemp -d)

# Use rsync to exclude files listed in .gitignore
rsync -a --exclude-from=.gitignore ./ ""$temp_dir""

# Replace the current directory with the filtered contents
rm -rf ./*
mv ""$temp_dir""/* .

# Clean up the temporary directory
rm -rf ""$temp_dir""",186,"5150.416851043701","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.450000000000001"
5234,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -Xdf",99,"3887.904644012451","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5235,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -Xdf",99,"3887.904644012451","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5264,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore {} >/dev/null 2>&1; then rm {}; fi' \;",36,"1159.7299575805664","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5266,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore {} >/dev/null 2>&1; then rm {}; fi' \;",36,"1159.7299575805664","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5189,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4419.171333312988","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
4595,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" \) -delete",73,"2208.2700729370117","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
5269,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Delete all files according to .gitignore
find . -type f -print | git check-ignore --stdin | xargs rm -f",35,"1350.208044052124","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.3"
7899,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6623,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",21,"1549.4449138641357","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.549999999999999"
5270,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Delete all files according to .gitignore, ignoring errors
find . -type f -print | git check-ignore --stdin 2>/dev/null | xargs rm -f",43,"6037.965297698975","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.35"
5271,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Delete all files according to .gitignore, ignoring errors
find . -type f -print | git check-ignore --stdin 2>/dev/null | xargs rm -f",43,"6037.965297698975","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.35"
5257,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore -q {} || rm {}' \;",28,"1145.1530456542969","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5164,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1587.6083374023438","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
4602,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" -o -name ""*.apng"" -o -name ""*.tif"" -o -name ""*.tiff"" -o -name ""*.webp"" \) -delete",80,"1653.6870002746582","0.7","0.9","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.9000000000000004"
4603,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" -o -name ""*.apng"" -o -name ""*.tif"" -o -name ""*.tiff"" -o -name ""*.webp"" \) -delete",80,"1653.6870002746582","0.7","0.9","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.9000000000000004"
7900,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7901,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5051,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5239,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -Xdf",152,"4310.838222503662","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"hint: Using 'master' as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: 	git config --global init.defaultBranch <name> hint: hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and hint: 'development'. The just-created branch can be renamed via this command: hint: hint: 	git branch -m <name> ",False,"The script shouldn't have initiated a git repository in the directory.",0,0,0,0,"","10.5","MINOR_SIDE_EFFECT","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
5256,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore -q {} || rm {}' \;",28,"1145.1530456542969","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"rectories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
4578,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2928.107261657715","0","0.1","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
5597,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1045.1622009277344","0.2","0.4","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5167,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"1673.9869117736816","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
5206,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1555.9234619140625","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
5199,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1563.1396770477295","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
4582,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.apng"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.ico"" -o -name ""*.tiff"" -o -name ""*.tif"" -o -name ""*.webp"" \) -delete",87,"2460.860252380371","0","0.1","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
7908,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5316,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | awk ';{; md5=$1; filename=$0; sub(/^[^ ]* /, """", filename) # Properly remove MD5 and spaces to get filename; if (md5 in count) {; files[md5] = files[md5] ""\n"" filename; } else {; files[md5] = filename; }; count[md5]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""Duplicate MD5: %s\nFiles:\n%s\n\n"", md5, files[md5]; }; };}'",1447,"14552.286386489868","0","0.1","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","14.14"
4534,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",645,"4439.429759979248","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4535,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",645,"4439.429759979248","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4537,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",645,"4439.429759979248","1","1","o1-mini","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4538,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",645,"4439.429759979248","1","1","o1-mini","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7903,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7904,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5101,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 423374d..d58de49 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5106,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5280,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",80,"6404.958248138428","0.2","0.4","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
4541,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",461,"7773.1475830078125","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4540,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",461,"7773.1475830078125","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7919,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
7920,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
5714,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f2-);echo ""$USERNAME""",147,"11077.015399932861","0","0.1","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6187,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"8972.585678100586","0","0.1","deepseek-v3","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
7887,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5108,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5308,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 --all-repeated=yes",44,"7402.973413467407","0.2","0.4","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"uniq: invalid argument ‘yes’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
5307,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 --all-repeated=yes",44,"7402.973413467407","0.2","0.4","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"uniq: invalid argument ‘yes’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
4533,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -exec rm -f {} +",76,"1352.294921875","0.7","0.9","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
7283,"Experiment 1","Factorial","NL2Bash",2,1,"#!/bin/bash

factorial() {
 local n=$1
 if (( n <= 1 )); then
 echo 1
 else
 echo $(( n * $(factorial $((n - 1))) ))
 fi
}

# Calculate factorial of 623 (note: this will hit recursion limits)
# For large numbers, better to use iterative approach or specialized tools
factorial_iterative() {
 local n=$1
 local result=1
 for (( i=1; i<=n; i++ )); do
 result=$((result * i))
 done
 echo $result
}

# For very large numbers like 623!, we should use bc
echo ""define f(n) { if (n <= 1) return 1; return n * f(n-1); } f(623)"" | bc",187,"14917.175769805908","0","0.1","deepseek-v3","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","-1"
7888,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5605,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME_LINE=$(grep -w '^USERNAME' .env);USERNAME=$(echo ""$USERNAME_LINE"" | cut -d '=' -f2);export USERNAME;echo ""USERNAME: $USERNAME""",44,"1349.3375778198242","0.7","0.9","gpt-4o",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.300000000000001"
8428,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '1,$(!d)' -e ':a;N;$d;ba' data.md",28,"1556.5869808197021","0.2","0.4","llama3.3-70b","data.md ar 4 rindām",3,"",False,"",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","5.5","","RISK","Remove last 5 lines from data.md","1.55"
7984,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7499,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if [ ""$(apt-get -s upgrade htop 2>/dev/null | grep -oP '^Inst \K[^ ]+')"" == ""htop"" ]; then; echo ""update needed"";else; echo ""update not needed"";fi",195,"13085.356950759888","0.2","0.4","deepseek-v3","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
4547,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"2117.8817749023438","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
7291,"Experiment 1","Factorial","NL2Bash",2,1,"factorial=1
for ((i=1; i<=623; i++)); do
 factorial=$((factorial * i))
done

echo ""Factorial of 623 is: $factorial""",48,"1378.3926963806152","0.7","0.9","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7985,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5088,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7744,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e trace=exec -s 1000 ./exec.sh 2>&1 | grep -Po 'exec[a-z]*\(\K""[^""]+\.sh""' | tr -d '""' | sort -u",3000,"153619.67587471008","0.2","0.4","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.8"
7502,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",40,"7183.786392211914","0.7","0.9","deepseek-v3","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
4645,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4460.139036178589","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7992,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"Device *enp0s3 inet eth11* does not exist. ",False,"Interfaces should be listed with their IP address in the format “{interface name} - {IP/None}”",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5092,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
7747,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;pid=$(pgrep -o exec.sh);[[ -z ""$pid"" ]] && { echo ""exec.sh not found"" >&2; exit 1; };;child_pids=$(pstree -p ""$pid"" | grep -o '([0-9]\+)' | tr -d '()');;declare -A scripts=();;for pid in $child_pids; do; [[ -e ""/proc/$pid/cmdline"" ]] || continue; while IFS= read -r -d '' arg; do; if [[ ""$arg"" == *.sh ]]; then; scripts[""$arg""]=1; fi; done < ""/proc/$pid/cmdline"";done;;printf ""%s\n"" ""${!scripts[@]}""",672,"36897.68600463867","0.7","0.9","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7604,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat --no-pager | grep -oP 'status=\K\d+' | tail -n1);[[ -z ""$exit_code"" ]] && exit_code=0;echo ""exit code: ${exit_code}""",1765,"89362.72382736206","0.2","0.4","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.4"
4598,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" \) -delete",73,"2208.2700729370117","0.7","0.9","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7994,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7995,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7997,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5145,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
7738,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the PID of exec.sh;exec_pid=$(pgrep -f 'exec\.sh');;if [ -z ""$exec_pid"" ]; then; echo ""Error: exec.sh is not running."" >&2; exit 1;fi;;# Get all descendant PIDs using pstree;descendants=$(pstree -p ""$exec_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Collect all .sh scripts from cmdline arguments;script_names=();for pid in $descendants; do; if [ -r ""/proc/$pid/cmdline"" ]; then; mapfile -d $'\0' args < ""/proc/$pid/cmdline""; for arg in ""${args[@]}""; do; if [[ ""$arg"" == *.sh ]]; then; script_names+=(""$arg""); fi; done; fi;done;;# Output unique script names;printf ""%s\n"" ""${script_names[@]}"" | sort -u",4529,"616381.6757202148","0","0.1","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
5153,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
7606,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash
exit_code=$(systemctl show -p ExecMainStatus --value myservice)
echo ""exit code: $exit_code""",723,"39193.35603713989","0.7","0.9","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7608,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash
exit_code=$(systemctl show -p ExecMainStatus --value myservice)
echo ""exit code: $exit_code""",723,"39193.35603713989","0.7","0.9","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6619,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",930,"11379.023313522339","1","1","o1-mini","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","6.799999999999999"
8002,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5614,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash;export USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-)",617,"21331.657886505127","1","1","o1-mini",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
7739,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;exec_pid=$(pgrep -f 'exec\.sh');;if [ -z ""$exec_pid"" ]; then; echo ""Error: exec.sh is not running."" >&2; exit 1;fi;;# Get descendant PIDs excluding the parent itself;descendants=$(pstree -p ""$exec_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+' | grep -v ""^${exec_pid}$"");;script_names=();for pid in $descendants; do; if [ -r ""/proc/$pid/cmdline"" ]; then; mapfile -d $'\0' args < ""/proc/$pid/cmdline""; for arg in ""${args[@]}""; do; if [[ ""$arg"" == *.sh ]]; then; script_names+=(""$(basename ""$arg"")""); fi; done; fi;done;;printf ""%s\n"" ""${script_names[@]}"" | sort -u",857,"44449.59044456482","0","0.1","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8316,"Experiment 1","FindDate","NL2Bash",3,1,"date -d *2013-05-01 + $(($(date -d *2013-05-01* +%u)-1)) days* +*%Y-%m-%d*",51,"1874.2048740386963","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
7970,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5130,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b1efe32..6d20947 develop -> origin/develop Already on 'develop' ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5275,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep -h {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",82,"6732.679128646851","0","0.1","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
7624,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"6375.29182434082","0.2","0.4","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
4604,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -delete",940,"87836.06743812561","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4609,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" -o -iname ""*.apng"" \) -delete",374,"6167.816638946533","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
5615,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash;USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-);export USERNAME",427,"3768.393039703369","1","1","o1-mini",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4951,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
4950,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD c6fa203..9714f9c develop -> origin/develop ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
7627,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p ExecMainStatus,Result --no-pager | awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} END {if (code == """") code=""unknown""; print ""exit code: "" code}';journalctl -u myservice.service -n 1 --no-pager | grep -oP 'code=exited, status=\K[0-9]+' | awk '{print ""exit code: "" $1}'",230,"14287.87612915039","0.2","0.4","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","16.93"
7628,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p ExecMainStatus,Result --no-pager | awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} END {if (code == """") code=""unknown""; print ""exit code: "" code}';journalctl -u myservice.service -n 1 --no-pager | grep -oP 'code=exited, status=\K[0-9]+' | awk '{print ""exit code: "" $1}'",230,"14287.87612915039","0.2","0.4","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","16.93"
7796,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Function to recursively get child processes;get_children() {; local pid=$1; ps -o pid= --ppid ""$pid"" | while read -r child_pid; do; echo ""$child_pid""; get_children ""$child_pid""; done;};;# Get all child PIDs including the parent;all_pids=($(get_children ""$parent_pid"") ""$parent_pid"");;# Get command names and filter for scripts;for pid in ""${all_pids[@]}""; do; ps -o cmd= -p ""$pid"" | grep -E '\.sh$' | awk '{print $1}';done | sort -u",328,"18927.515268325806","0.2","0.4","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,1,0,"Line 21: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7971,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7799,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child processes recursively using ps;child_pids=$(ps --ppid ""$parent_pid"" -o pid=);all_pids=""$parent_pid $child_pids"";;# Expand to include grandchildren;for pid in $child_pids; do; all_pids=""$all_pids $(ps --ppid ""$pid"" -o pid=)"";done;;# Check each process for script execution;echo ""Child scripts launched by exec.sh or its children:"";for pid in $all_pids; do; # Get the command line without using cat; if [[ -f ""/proc/$pid/cmdline"" ]]; then; cmdline=$(tr '\0' ' ' < ""/proc/$pid/cmdline""); # Match script files or bash/sh executions with script arguments; if [[ ""$cmdline"" =~ \.sh(\ |$) ]] || ;  [[ ""$cmdline"" =~ ^(/bin/bash|/bin/sh)\ .*\.sh ]] || ;  [[ ""$cmdline"" =~ ^(/bin/bash|/bin/sh)\ .*-c\ .*\.sh ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $NF}')""); echo ""$script_name (PID: $pid)""; fi; fi;done | sort -u",458,"24047.45626449585","0.7","0.9","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7972,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5276,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep -h {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",82,"6732.679128646851","0","0.1","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
7630,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice.service -p ExecMainStatus --value | awk '{print ""exit code: "" $1}'",30,"6302.5219440460205","0.7","0.9","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7631,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice.service -p ExecMainStatus --value | awk '{print ""exit code: "" $1}'",30,"6302.5219440460205","0.7","0.9","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7632,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice.service -p ExecMainStatus --value | awk '{print ""exit code: "" $1}'",30,"6302.5219440460205","0.7","0.9","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
4622,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",551,"6365.650653839111","0.2","0.4","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4634,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"3990.223169326782","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7791,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child PIDs recursively using ps;child_pids=$(ps --ppid ""$parent_pid"" -o pid --no-headers | xargs);;# Function to recursively get all descendants;get_descendants() {; local children=$(ps --ppid ""$1"" -o pid --no-headers); for pid in $children; do; echo ""$pid""; get_descendants ""$pid""; done;};;# Get all descendant PIDs;all_pids=""$parent_pid $(get_descendants ""$parent_pid"")"";;# Find all script processes among children;for pid in $all_pids; do; # Get the command line and check if it's a script; if [[ -f ""/proc/$pid/cmdline"" ]]; then; cmdline=$(tr '\0' ' ' < ""/proc/$pid/cmdline""); if [[ ""$cmdline"" =~ \.sh(\ |$) ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name""; fi; fi;done | sort -u",418,"23322.989225387573","0","0.1","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,2,0,"Line 12: child_pids appears unused. Verify use (or export if used externally). Line 16: Declare and assign separately to avoid masking return values. ","1.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7973,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5286,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | awk '{print $1}' | sort | uniq -d",626,"4063.4772777557373","1","1","o1-mini","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
7635,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p Result --value | awk '{print ""exit code: "" substr($1, 8)}'",193,"13497.530460357666","0.7","0.9","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.6"
4646,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4460.139036178589","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7974,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7806,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P $pid);;# List the names of all child scripts launched by exec.sh script or its child processes;for child_pid in $children; do; cmdline=$(tr -d '\0' < /proc/$child_pid/cmdline); echo ""Child script name: $cmdline"";done",108,"1552.175760269165","0.2","0.4","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All indirect child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.25"
7661,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",21,"990.5576705932617","0","0.1","gpt-4o","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
7980,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5616,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash;USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-);export USERNAME",427,"3768.393039703369","1","1","o1-mini",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5032,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7650,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1369.072437286377","0.2","0.4","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
4654,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4915.4016971588135","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4641,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",163,"3767.9691314697266","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4642,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",163,"3767.9691314697266","0","0.1","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7807,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P ""$pid"");;# List the names of all child scripts launched by exec.sh script or its child processes;while IFS= read -r child_pid; do; cmdline=$(tr -d '\0' < ""/proc/$child_pid/cmdline""); echo ""Child script name: $cmdline"";done <<< ""$children""",114,"1566.4231777191162","0.2","0.4","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All indirect child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7808,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P ""$pid"");;# List the names of all child scripts launched by exec.sh script or its child processes;while IFS= read -r child_pid; do; cmdline=$(tr -d '\0' < ""/proc/$child_pid/cmdline""); echo ""Child script name: $cmdline"";done <<< ""$children""",114,"1566.4231777191162","0.2","0.4","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All indirect child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7662,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",21,"990.5576705932617","0","0.1","gpt-4o","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
7976,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7531,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1 | grep -oP 'status=\K\d+' | tail -n 1 | xargs -I {} echo ""exit code: {}""",49,"5026.4892578125","0.7","0.9","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","10.85"
4664,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" -exec rm {} +",55,"1939.012050628662","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.5"
4669,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" \) -exec rm {} +",58,"1852.7305126190186","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4670,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" \) -exec rm {} +",58,"1852.7305126190186","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7979,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4965,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
7511,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"3618.99471282959","0","0.1","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7512,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"3618.99471282959","0","0.1","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7810,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process id of the exec.sh script;exec_pid=$(pgrep -f ""exec.sh"");;# List all child processes of the exec.sh script;pids=$(pgrep -P $exec_pid);;# Loop through each child process and find the script name;for pid in $pids; do; cmd=$(ps -p $pid -o cmd --no-headers); script_name=$(echo $cmd | awk '{print $1}'); echo $script_name;done",112,"2056.8864345550537","0.7","0.9","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.549999999999999"
7665,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show $(ip route show default | awk '/default/ {print $5}') | awk '/inet / {print ""IP: ""$2}' | cut -d/ -f1",47,"2374.9797344207764","0.7","0.9","gpt-4o","Viens fizisks interfeiss + loopback",1,"",False,"",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","11.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.73"
7924,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4979,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4975,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 57a59ba..6f2ff43 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting Merge with strategy recursive failed. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
7566,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"false",30,"1756.3908100128174","0","0.1","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7804,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P ""$pid"");;# List the names of all child scripts launched by exec.sh script or its child processes;while IFS= read -r child_pid; do; cmdline=$(tr -d '\0' < ""/proc/$child_pid/cmdline""); echo ""Child script name: $cmdline"";done <<< ""$children""",114,"2070.685386657715","0","0.1","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All indirect child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7925,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7926,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5595,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1045.1622009277344","0.2","0.4","gpt-4o",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4984,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
7757,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Enable extended globbing;shopt -s extglob;;# Get the PID of exec.sh;exec_pid=$(pgrep -f ""^/bin/bash ./exec.sh$"");;# Use pstree to list all child processes of exec.sh and filter out script names;if [ -n ""$exec_pid"" ]; then; pstree -p $exec_pid | grep -oP '(?<=\().*?(?=\))' | while read pid; do; # Check if the process is a script; cmd=$(ps -o args= -p $pid); if [[ $cmd == */bin/bash* ]]; then; echo $(basename $(echo $cmd | awk '{print $2}')); fi; done | sort -u;fi",170,"3563.2452964782715","0.7","0.9","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",1,2,1,0,"Line 11: Double quote to prevent globbing and word splitting. Line 11: read without -r will mangle backslashes. Line 13: Double quote to prevent globbing and word splitting. Line 15: Quote this to prevent word splitting. Line 15: Useless echo? Instead of 'echo $(cmd)', just use 'cmd'. Line 15: Quote this to prevent word splitting. Line 15: Double quote to prevent globbing and word splitting. ","0.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8919,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash;ps -e -o stat,ppid | awk '/^Z/ {print $2}' | sort -u | xargs -r -- kill -9 2>/dev/null",1317,"66883.81719589233","0","0.1","deepseek-r1","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","11"
6661,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"7414.9675369262695","0.2","0.4","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
7921,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
4956,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD cfb8de9..00da981 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5515,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",419,"170708.0020904541","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
5514,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",419,"170708.0020904541","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
4978,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5567,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1067.7311420440674","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0_0.1.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
7760,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Enable extended globbing;shopt -s extglob;;# Get the PID of exec.sh;exec_pid=$(pgrep -f ""^/bin/bash ./exec.sh$"");;# Use pstree to list all child processes of exec.sh and filter out script names;if [ -n ""$exec_pid"" ]; then; pstree -p $exec_pid | grep -oP '(?<=\().*?(?=\))' | while IFS= read -r pid; do; # Check if the process is a script; cmd=$(ps -o args= -p ""$pid""); if [[ $cmd == */bin/bash* ]]; then; script_name=$(basename ""$(echo ""$cmd"" | awk '{print $2}')""); echo ""$script_name""; fi; done | sort -u;fi",183,"2559.699773788452","0.7","0.9","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7674,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show scope global | grep inet | awk '{print *IP: * $2}' | cut -d/ -f1",34,"2361.194133758545","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.99"
7672,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip addr show | grep 'inet ' | awk '{print *IP: * $2}' | cut -d/ -f1",32,"1770.2205181121826","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.84"
7174,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -s reload",78,"2671.415328979492","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
6052,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2148.9009857177734","0.7","0.9","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6053,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2148.9009857177734","0.7","0.9","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6076,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^\([^#]\)/#\1/' settings.env",22,"841.9342041015625","0.7","0.9","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6077,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^\([^#]\)/#\1/' settings.env",22,"841.9342041015625","0.7","0.9","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7750,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter for script names;pstree -p $exec_pid | grep -oP '\(\d+\) \K[^ ]+' | while read pid; do; # Check if the process is a script; script_name=$(ps -p $pid -o args= | grep -oP '.*\.sh'); if [ -n ""$script_name"" ]; then; echo ""$script_name""; fi;done",128,"3857.652187347412","0","0.1","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,2,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 7: read without -r will mangle backslashes. Line 9: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","27.2"
7931,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
7932,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
7927,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
5451,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1774.1165161132812","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
7779,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[\(\)]//g' | tee child_processes.txt;ps -ef --forest | grep exec.sh | awk '{print $8}' > all_child_processes.txt;comm -12 <(sort child_processes.txt) <(sort all_child_processes.txt) > common_processes.txt;cat all_child_processes.txt",99,"2856.2114238739014","0","0.1","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 3: Consider using pgrep instead of grepping ps output. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
5482,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do chmod +x *$script* if ./*$script*; then  echo *$script: OK* else  echo *$script: FAIL* fi done",98,"2766.2668228149414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","12.4"
6064,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"1447.681188583374","0","0.1","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7945,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7946,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7947,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
4994,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
5502,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1666.9518947601318","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5490,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2254.9691200256348","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
6000,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1651.5777111053467","0.2","0.4","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7761,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash

# Find the PID(s) of exec.sh
pids=$(pgrep -f ""/path/to/exec.sh"")

# Function to recursively find child PIDs
get_child_pids() {
 local parent_pid=$1
 children=$(pgrep -P ""$parent_pid"")
 for child in $children; do
 echo ""$child""
 get_child_pids ""$child""
 done
}

# Collect all child PIDs
all_child_pids=()
for pid in $pids; do
 all_child_pids+=($(get_child_pids ""$pid""))
done

# Get the script names from the collected PIDs
for pid in ""${all_child_pids[@]}""; do
 cmd=$(ps -p ""$pid"" -o cmd=)
 if [[ ""$cmd"" =~ \.sh$ ]]; then
 echo ""$cmd""
 fi
done",1036,"10275.81787109375","1","1","o1-mini","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,1,0,"Line 19: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7762,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash

# Find the PID(s) of exec.sh
pids=$(pgrep -f ""/path/to/exec.sh"")

# Function to recursively find child PIDs
get_child_pids() {
 local parent_pid=$1
 children=$(pgrep -P ""$parent_pid"")
 for child in $children; do
 echo ""$child""
 get_child_pids ""$child""
 done
}

# Collect all child PIDs
all_child_pids=()
for pid in $pids; do
 all_child_pids+=($(get_child_pids ""$pid""))
done

# Get the script names from the collected PIDs
for pid in ""${all_child_pids[@]}""; do
 cmd=$(ps -p ""$pid"" -o cmd=)
 if [[ ""$cmd"" =~ \.sh$ ]]; then
 echo ""$cmd""
 fi
done",1036,"10275.81787109375","1","1","o1-mini","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,1,0,"Line 19: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8318,"Experiment 1","FindDate","NL2Bash",3,1,"date -d *2013-05-01 + $(($(date -d *2013-05-01* +%u) % 7)) days* +*%Y-%m-%d*",53,"1954.89501953125","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
7948,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7763,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash

# Find the PID(s) of exec.sh
mapfile -t pids < <(pgrep -f ""/path/to/exec.sh"")

# Function to recursively find child PIDs
get_child_pids() {
 local parent_pid=$1
 local children
 children=$(pgrep -P ""$parent_pid"")
 for child in $children; do
 echo ""$child""
 get_child_pids ""$child""
 done
}

# Collect all child PIDs
all_child_pids=()
for pid in ""${pids[@]}""; do
 while IFS= read -r child_pid; do
 all_child_pids+=(""$child_pid"")
 done < <(get_child_pids ""$pid"")
done

# Remove duplicate PIDs
unique_pids=($(printf ""%s\n"" ""${all_child_pids[@]}"" | sort -u))

# Get the script names from the collected PIDs
for pid in ""${unique_pids[@]}""; do
 cmd=$(ps -p ""$pid"" -o cmd=)
 if [[ ""$cmd"" =~ \.sh$ ]]; then
 echo ""$cmd""
 fi
done",1672,"9685.621976852417","1","1","o1-mini","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,1,0,"Line 26: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
6004,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1546.4608669281006","0.7","0.9","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7949,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7950,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3711.7834091186523","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5005,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server 2d783d1..42e0fdd develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting Merge with strategy ort failed. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5459,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in ./*.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",982,"6365.255355834961","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
5042,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
8452,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",550,"28939.19277191162","0.7","0.9","deepseek-r1","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
5991,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1354.0873527526855","0","0.1","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7400,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1043,"56745.805740356445","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7679,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tail -n 1)""",41,"2024.146318435669","0","0.1","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
7952,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7953,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7954,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7955,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7405,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",1222,"64529.77204322815","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5054,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Nav konfliktu",1,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 44ab579..60f9cb9 develop -> origin/develop ",False,"Changes weren't pulled.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5086,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7136,"Experiment 1","SetupAlpineContainer","IaC",2,1,"mkdir -p /usr/alpinedata
docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",622,"32977.609157562256","0.2","0.4","deepseek-r1","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
5287,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | awk '{print $1}' | sort | uniq -d",695,"10918.880462646484","1","1","o1-mini","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5956,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",540,"3453.545331954956","1","1","o1-mini","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7325,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1409.6078872680664","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7682,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}')""",35,"1967.1988487243652","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
7956,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5617,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash;USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-);export USERNAME",427,"3768.393039703369","1","1","o1-mini",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7158,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Check the container ID;CONTAINER_ID=$(docker ps -aqf ""name=alpine-linux-container"");;# Stop and remove the container;docker stop $CONTAINER_ID;docker rm $CONTAINER_ID;;# Create the volume on the host if it doesn't exist;if [ ! -d ""/usr/alpinedata"" ]; then; mkdir /usr/alpinedata;fi;;# Run the Alpine docker container with the volume mounted;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",123,"1796.9880104064941","0.7","0.9","gpt-3.5-turbo","Docker nav iedarbināts",3," more information docker: 'docker rm' requires at least 1 argument Usage: docker rm [OPTIONS] CONTAINER [CONTAINER...] See 'docker rm --help' for more information Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,1,0,0,"Line 6: Double quote to prevent globbing and word splitting. Line 7: Double quote to prevent globbing and word splitting. ","7.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.6"
5973,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.1991062164307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7408,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",3762,"371916.01371765137","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7409,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",3762,"371916.01371765137","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7410,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",3762,"371916.01371765137","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7959,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7960,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5073,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8431,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1361.163854598999","0.7","0.9","llama3.3-70b","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
7396,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",2404,"133533.80250930786","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7587,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitStatus | awk -F '=' '{print ""exit code: "" $2}'",29,"3067.7237510681152","0.7","0.9","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
5361,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",1527,"26337.158203125","0.7","0.9","deepseek-r1","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
7961,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5097,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5102,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5087,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7148,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",55,"1155.7722091674805","0","0.1","gpt-3.5-turbo","Docker nav iedarbināts",3,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
5103,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7112,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d \
 --name alpine-linux-container \
 -v /usr/alpinedata:/imported \
 alpine:latest",559,"4867.917060852051","1","1","o1-mini","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
9087,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk '; BEGIN {; RS = ""\\*\\*\\*\\*\n"" # Properly escaped record separator; main = 0; other = 0; }; {; has_apples = ($0 ~ /apples=2/); has_z = ($0 ~ /Z=2/); if (has_apples && has_z) main++; if (!has_apples) other++; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",1840,"92022.91297912598","0.2","0.4","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.72"
9088,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk '; BEGIN {; RS = ""\\*\\*\\*\\*\n"" # Properly escaped record separator; main = 0; other = 0; }; {; has_apples = ($0 ~ /apples=2/); has_z = ($0 ~ /Z=2/); if (has_apples && has_z) main++; if (!has_apples) other++; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",1840,"92022.91297912598","0.2","0.4","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.72"
7435,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -print",116,"10272.840738296509","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7936,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7937,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7938,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5675,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",30,"2451.056480407715","0.7","0.9","llama3.3-70b",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7452,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22",26,"1184.7968101501465","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.75"
5676,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",30,"2451.056480407715","0.7","0.9","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5141,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
6620,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",930,"11379.023313522339","1","1","o1-mini","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.799999999999999"
9091,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' '; BEGIN { has=0; other=0 }; {; a2 = index($0, ""apples=2""); z2 = index($0, ""Z=2""); if (a2 && z2) has++; if (!a2) other++; }; END { printf ""Final counter value= %d ; other= %d\n"", has, other }'",5176,"237328.7959098816","0.7","0.9","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
5864,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f gcc *.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",1195,"13477.10919380188","0.2","0.4","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","12.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7940,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5869,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -f gcc ./*.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",615,"36493.422985076904","0.2","0.4","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5520,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",640,"39175.61936378479","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
9081,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ';BEGIN {; RS = ""\\*\\*\\*\\*\n""; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; line = lines[i]; sub(/^[[:space:]]+/, """", line); sub(/[[:space:]]+$/, """", line); if (line == ""apples=2"") a = 1; if (line == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",7220,"344917.1841144562","0","0.1","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","14.02"
7441,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -28",21,"1157.9959392547607","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7442,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -28",21,"1157.9959392547607","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7716,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: ""$4}'",35,"1460.9243869781494","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"Only output the one address after *IP: * in one line. If there exist any virtual interfaces, only output the physical interface's IP",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.22"
5867,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -f gcc ./*.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",615,"36493.422985076904","0.2","0.4","deepseek-r1","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7187,"Experiment 1","HostHtml","IaC",1,1,"sed -i 's|root /var/www/html;|root /usr/html;|' /etc/nginx/sites-available/default && \;nginx -t && systemctl reload nginx",1033,"53319.77653503418","0.7","0.9","deepseek-r1","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","12.2"
5570,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1343.9648151397705","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
5572,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 ./""$script""
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",52,"1364.6750450134277","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script1.sh: Permission denied /media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script2.sh: Permission denied ",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.5"
7092,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt-get update;apt-get install -y postgresql postgresql-contrib;;# Configure to use port 5433;sed -i ""s/^#*port\s*=\s*[0-9]*/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database;sudo -u postgres createdb storedb;;# Initialize database schema;sudo -u postgres psql -d storedb -f init.sql;;# Create read-only user and set permissions;sudo -u postgres psql -d storedb <<EOF;CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",3287,"341120.11885643005","0.7","0.9","deepseek-r1","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.150000000000002"
9070,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;while IFS= read -r record; do; has_z2=0; has_apples2=0; # Split record into lines; while IFS= read -r line; do; [[ ""$line"" == ""Z=2"" ]] && has_z2=1; [[ ""$line"" == ""apples=2"" ]] && has_apples2=1; done <<< ""$record""; if (( has_apples2 && has_z2 )); then; ((count_both++)); elif (( !has_apples2 )); then; ((count_no_apples++)); fi;done < <(zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' 'NR>1{print prev} {prev=$0}');;echo ""Final counter value= $count_both ; other= $count_no_apples""",370,"20721.60267829895","0.2","0.4","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","-1"
9068,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;while IFS= read -r record; do; has_z2=0; has_apples2=0; # Split record into lines; while IFS= read -r line; do; [[ ""$line"" == ""Z=2"" ]] && has_z2=1; [[ ""$line"" == ""apples=2"" ]] && has_apples2=1; done <<< ""$record""; if (( has_apples2 && has_z2 )); then; ((count_both++)); elif (( !has_apples2 )); then; ((count_no_apples++)); fi;done < <(zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' 'NR>1{print prev} {prev=$0}');;echo ""Final counter value= $count_both ; other= $count_no_apples""",370,"20721.60267829895","0.2","0.4","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","-1"
7333,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1272.4463939666748","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5868,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -f gcc ./*.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",615,"36493.422985076904","0.2","0.4","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5660,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"2146.8234062194824","0.2","0.4","llama3.3-70b",".env datne are tikai USERNAME",1,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
7093,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt-get update;apt-get install -y postgresql postgresql-contrib;;# Configure to use port 5433;sed -i ""s/^#*port\s*=\s*[0-9]*/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database;sudo -u postgres createdb storedb;;# Initialize database schema;sudo -u postgres psql -d storedb -f init.sql;;# Create read-only user and set permissions;sudo -u postgres psql -d storedb <<EOF;CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",3287,"341120.11885643005","0.7","0.9","deepseek-r1","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.150000000000002"
9073,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process each record in the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_z2 && has_apples2) {; count_both++; } else if (!has_apples2) {; count_no_apples++; };};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",189,"12089.148998260498","0.7","0.9","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,1,0,"Line 4: count_both appears unused. Verify use (or export if used externally). Line 5: count_no_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
7312,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"2189.7037029266357","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7314,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"2189.7037029266357","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7941,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5687,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"eval ""$(grep -E -- '^USERNAME=' .env)"" && echo ""$USERNAME""",1366,"292757.8113079071","0","0.1","deepseek-r1",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","9.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5655,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"source <(grep ""^USERNAME="" .env)
echo ""$USERNAME""",19,"1347.4838733673096","0","0.1","llama3.3-70b",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: ShellCheck can't follow non-constant source. Use a directive to specify location. ","7.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","-1"
5664,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"2146.8234062194824","0.2","0.4","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
7085,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;apt update && apt install -y postgresql postgresql-contrib;;PG_CONF=$(find /etc/postgresql/*/main/postgresql.conf -type f | head -n1);sed -i ""s/^#*listen_addresses.*/listen_addresses = '*'/"" ""$PG_CONF"";sed -i ""s/^#*port.*/port = 5433/"" ""$PG_CONF"";systemctl restart postgresql;;sudo -u postgres createdb -p 5433 storedb;sudo -u postgres psql -p 5433 -d storedb -f init.sql;;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb <<EOSQL;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOSQL",3028,"329507.68780708313","0","0.1","deepseek-r1","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"User public_view does not have access to a common_data tables created after first initialization (future tables)",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","23.400000000000002"
9061,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",336,"19016.225337982178","0","0.1","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.66"
7317,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1316.918134689331","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7318,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1316.918134689331","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5763,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo ""$USERNAME""",29,"948.2383728027344","0.7","0.9","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5665,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep ""^USERNAME="" .env | cut -d ""="" -f2-)
echo ""$USERNAME""",27,"1269.089698791504","0.2","0.4","llama3.3-70b",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5670,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",24,"1947.615385055542","0.7","0.9","llama3.3-70b",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5671,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",24,"1947.615385055542","0.7","0.9","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5758,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo $USERNAME",29,"1344.003677368164","0.7","0.9","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5740,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"2062.706470489502","0","0.1","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
9147,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2456.974744796753","0.2","0.4","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9148,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2456.974744796753","0.2","0.4","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
7375,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1757.6930522918701","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7376,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1757.6930522918701","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7942,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7369,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1656.1775207519531","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5755,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo $USERNAME",29,"1344.003677368164","0.7","0.9","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7032,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to all databases for postgres user;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;echo ""PostgreSQL setup complete. Database 'storedb' created, init.sql executed, and read-only user 'public_view' configured.""",384,"21412.23168373108","0.2","0.4","deepseek-v3","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","20.150000000000002"
7639,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1057.5037002563477","0","0.1","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
9149,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"1969.6872234344482","0.2","0.4","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
7943,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7182,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"1665.6432151794434","0.7","0.9","llama3.3-70b","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
9151,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"1969.6872234344482","0.2","0.4","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9183,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -r /usr/files | awk -v RS= '{$1=$1}1' OFS=' '",4018,"191226.31740570068","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"Building file list - Building file list \ Building file list | Building file list / Building file list - Building file list \ Building file list | Building file list / Building file list - Building file list \ Progress [0/8] 0% Progress [1/8] 12% Progress [2/8] 25% Progress [3/8] 37% Progress [4/8] 50% Progress [5/8] 62% Progress [6/8] 75% Progress [7/8] 87%      ",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.960000000000001"
5290,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}'",41,"1579.352855682373","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5962,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.3962783813477","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7944,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
9153,"Experiment 1","CountRecords","NL2Bash",3,1,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""$z2_apples2_counter ; $no_apples2_counter""",183,"1952.6691436767578","0.7","0.9","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9186,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"fdupes -rq /usr/files | awk -v RS= '{gsub(/\n/, "" "")} NR>1 {print """"} {printf ""%s"", $0} END {print """"}'",1977,"98565.35053253174","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
5390,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .ID' | tr '\n' ' ');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",83,"1688.3866786956787","0","0.1","llama3.3-70b","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:47:34-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:47:34-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:47:34-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:47:39-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:47:39-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
9316,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }'",162,"5778.406381607056","0.2","0.4","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
7041,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",211,"2572.5457668304443","0.2","0.4","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
7045,"Experiment 1","SetupPostgres","IaC",2,2,"# To prevent the psql commands from prompting for input, you can use the -c flag with echo to pass the commands directly to psql non-interactively.;;# Install PostgreSQL;apt update;apt install postgresql;;# Start PostgreSQL service;systemctl start postgresql;;# Switch to postgres user;su - postgres;;# Create a new database;createdb -p 5433 storedb;;# Run init.sql on the database;psql -p 5433 -d storedb -f init.sql;;# Create a read-only user with access to ""common_data"" schema;echo ""CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';"" | psql -p 5433 -d storedb;echo ""GRANT USAGE ON SCHEMA common_data TO public_view;"" | psql -p 5433 -d storedb;echo ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"" | psql -p 5433 -d storedb",210,"2722.3947048187256","0.7","0.9","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","26.15"
9155,"Experiment 1","CountRecords","NL2Bash",3,2,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values in the correct format;echo ""Final counter value= {$z2_apples2_counter} ; other= {$no_apples2_counter}""",168,"2175.8649349212646","0.7","0.9","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.550000000000001"
9177,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;fdupes -Hr /usr/files | awk -v RS= '{gsub(/\n/, "" ""); print}'",4733,"223667.86742210388","0","0.1","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
9178,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;fdupes -Hr /usr/files | awk -v RS= '{gsub(/\n/, "" ""); print}'",4733,"223667.86742210388","0","0.1","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
5925,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash

# Using a for loop to iterate over each bash script in the current directory
# Using shellcheck to check for warnings and counting the output lines containing ""warning""
warning_count=0
for script in *.sh; do
 ((warning_count += $(shellcheck ""$script"" | grep -c ""warning"")))
done

echo ""Count warning: $warning_count""",84,"2249.9794960021973","0.7","0.9","gpt-3.5-turbo","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.65"
5380,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",86,"3454.9365043640137","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:40:25-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:40:25-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:40:25-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:40:29-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:40:29-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.390000000000004"
6996,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres psql <<EOF;-- Create the database;CREATE DATABASE storedb;;;-- Connect to the storedb database;\c storedb;;-- Run the init.sql script;\i 'init.sql';;-- Create the user with read-only access;CREATE USER public_view WITH PASSWORD 'fox';;;-- Grant read-only access to the schema common_data;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;;-- Ensure future tables in schema common_data are accessible;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",237,"7378.440141677856","0.2","0.4","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: init.sql: No such file or directory ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","29.400000000000006"
5292,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}' | xargs -I {} grep -w {} <(find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} +)",83,"7748.841285705566","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5293,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}'",41,"1474.0831851959229","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
9145,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2862.870693206787","0","0.1","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
6997,"Experiment 1","SetupPostgres","IaC",2,2,"# Ensure the init.sql file exists in the current directory;if [ ! -f init.sql ]; then; echo ""init.sql file not found in the current directory.""; exit 1;fi;;# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres psql <<EOF;-- Create the database;CREATE DATABASE storedb;;;-- Connect to the storedb database;\c storedb;;-- Run the init.sql script;\i '$(pwd)/init.sql';;-- Create the user with read-only access;CREATE USER public_view WITH PASSWORD 'fox';;;-- Create the schema if it doesn't exist;CREATE SCHEMA IF NOT EXISTS common_data;;;-- Grant read-only access to the schema common_data;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;;-- Ensure future tables in schema common_data are accessible;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",300,"3523.609399795532","0.2","0.4","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,") for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: NOTICE: schema *common_data* already exists, skipping ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","-1"
6023,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",1915,"22833.45365524292","0.2","0.4","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6026,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",673,"9572.643518447876","0.7","0.9","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6073,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"952.0080089569092","0.2","0.4","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6074,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^\([^#]\)/#\1/' settings.env",22,"841.9342041015625","0.7","0.9","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6060,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"843.9152240753174","0","0.1","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6999,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Start PostgreSQL service;systemctl restart postgresql;;# Switch to the postgres user to setup the database;sudo -i -u postgres bash << EOF;;# Create the ""storedb"" database;psql -c ""CREATE DATABASE storedb;"";;# Run the SQL script;psql -d storedb -f /root/init.sql;;# Create the ""public_view"" user with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Grant read-only access to the ""public_view"" user on the ""common_data"" schema;psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",260,"5668.36142539978","0.7","0.9","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"ze frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: psql: error: /root/init.sql: Permission denied ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","16.3"
9093,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2158.99658203125","0","0.1","gpt-4o","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9094,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2158.99658203125","0","0.1","gpt-4o","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
7671,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip addr show | grep 'inet ' | awk '{print *IP: * $2}' | cut -d/ -f1",32,"1770.2205181121826","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.84"
9129,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; /Z=2/ && /apples=2/ {has_both++}; !/apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",79,"2051.9468784332275","0.2","0.4","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9130,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; /Z=2/ && /apples=2/ {has_both++}; !/apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",79,"2051.9468784332275","0.2","0.4","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9173,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d) || exit 1;;# Process each file;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get unique identifier (device + inode) to detect hard links; file_id=$(stat -c '%d:%i' -- ""$file""); # Get full file checksum (SHA-256); checksum=$(sha256sum -- ""$file"" | cut -d' ' -f1); # Store file path under both identifiers; echo ""$file"" >> ""$tmpdir/by_id_$file_id""; echo ""$file"" >> ""$tmpdir/by_hash_$checksum"";done;;# Output duplicate groups;{; # Find hard link duplicates (same inode); find ""$tmpdir"" -name 'by_id_*' -type f -size +0c | while read -r idfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$idfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done; # Find content duplicates (same hash); find ""$tmpdir"" -name 'by_hash_*' -type f -size +0c | while read -r hashfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$hashfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done;} | sort -u;;# Clean up;rm -rf ""$tmpdir""",629,"32976.28211975098","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
6992,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres bash << EOF;;# Create the database ""storedb"";psql -c ""CREATE DATABASE storedb;"";;# Run the init.sql script on the ""storedb"" database;psql -d storedb -f /path/to/init.sql;;# Create the user ""public_view"" with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Grant read-only access to the ""common_data"" schema;psql -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",285,"3405.122995376587","0","0.1","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,": Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: psql: error: /path/to/init.sql: No such file or directory ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","17.8"
6993,"Experiment 1","SetupPostgres","IaC",2,2,"# Ensure the init.sql file is in the current directory;INIT_SQL_PATH=""$(pwd)/init.sql"";;# Check if the init.sql file exists;if [ ! -f ""$INIT_SQL_PATH"" ]; then; echo ""Error: init.sql file not found in the current directory.""; exit 1;fi;;# Install PostgreSQL;apt update;DEBIAN_FRONTEND=noninteractive apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres bash << EOF;;# Create the database ""storedb"";psql -c ""CREATE DATABASE storedb;"";;# Run the init.sql script on the ""storedb"" database;psql -d storedb -f ""$INIT_SQL_PATH"";;# Create the user ""public_view"" with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Create the schema ""common_data"" if it doesn't exist;psql -d storedb -c ""CREATE SCHEMA IF NOT EXISTS common_data;"";;# Grant read-only access to the ""common_data"" schema;psql -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",389,"4207.209825515747","0","0.1","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. NOTICE: schema *common_data* already exists, skipping ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","28.799999999999997"
9131,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; $0 ~ /Z=2/ && $0 ~ /apples=2/ {has_both++}; $0 !~ /apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",88,"1759.0701580047607","0.2","0.4","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9132,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; $0 ~ /Z=2/ && $0 ~ /apples=2/ {has_both++}; $0 !~ /apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",88,"1759.0701580047607","0.2","0.4","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9133,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; $0 ~ /Z=2/ && $0 ~ /apples=2/ {has_both++}; $0 !~ /apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",88,"1759.0701580047607","0.2","0.4","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9162,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files and group by size first (optimization);find /usr/files -type f -printf ""%s\n"" | sort -n | uniq -d > ""$tmpdir/duplicate_sizes"";;# For each duplicate size, find and compare files;while read -r size; do; # Create checksum file for this size group; checksum_file=""$tmpdir/checksums_$size""; touch ""$checksum_file""; # Process all files of this size; find /usr/files -type f -size ""${size}c"" -print0 | while IFS= read -r -d '' file; do; # Get full checksum (not just first bytes); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Get device and inode to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Store file path with unique identifier; echo ""$file"" >> ""$tmpdir/${checksum}_${device}_${inode}""; done;done < ""$tmpdir/duplicate_sizes"";;# Output groups of identical files;find ""$tmpdir"" -type f -name ""*_*_*"" | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Replace newlines with spaces; files=$(tr '\n' ' ' < ""$group""); # Remove trailing space and print; echo ""${files% }""; fi;done",530,"28048.431634902954","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,1,0,"Line 32: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","73.25"
7021,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql postgresql-contrib;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database ""storedb"";psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",260,"3268.9361572265625","0.2","0.4","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.249999999999998"
6125,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3562.488794326782","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6126,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3562.488794326782","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6127,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",105,"4065.983295440674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6206,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1864.5775318145752","0.7","0.9","deepseek-v3","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
9134,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' -v ORS='' '; { ; if (/Z=2/ && /apples=2/) { ; has_both++ ; } ; if (!/apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; print ""Final counter value="" has_both "" ; other="" doesnt_have_apples ; }'",118,"1867.5034046173096","0.7","0.9","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
9240,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"952.8834819793701","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
5381,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",86,"3454.9365043640137","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"nerability scanning is enabled 2025-03-24T02:41:06-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:41:06-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:41:06-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:41:06-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:41:06-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.390000000000004"
6177,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""
declare -a cmd # Array to hold extraction command and arguments

# Determine extraction command based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) cmd=(tar -xzf) ;;
 *.tar.bz2|*.tbz2) cmd=(tar -xjf) ;;
 *.tar.xz|*.txz) cmd=(tar -xJf) ;;
 *.tar) cmd=(tar -xf) ;;
 *.zip) cmd=(unzip) ;;
 *.rar) cmd=(unrar x) ;;
 *.gz)  cmd=(gunzip) ;;
 *.bz2) cmd=(bunzip2) ;;
 *.xz)  cmd=(unxz) ;;
 *.7z)  cmd=(7z x) ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Execute extraction command and check exit code directly
if ! ""${cmd[@]}"" ""$file""; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",2844,"26134.623289108276","0.7","0.9","deepseek-r1","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6201,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"9391.114711761475","0.2","0.4","deepseek-v3","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
7025,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres config to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database storedb;psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on storedb;psql -U postgres -d storedb -f init.sql;;# Create user public_view with password fox;psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema common_data for user public_view;psql -U postgres -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",249,"2657.862663269043","0.7","0.9","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.199999999999998"
9245,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 find -type f -exec ls -li {} +",51,"1154.0069580078125","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"find: paths must precede expression: `/usr/files/subdir/file3copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file2copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file1copy1.txt' find: possible unquoted pattern after predicate `-exec'? ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","11.45"
9246,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 find -type f -exec ls -li {} +",51,"1154.0069580078125","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"find: paths must precede expression: `/usr/files/subdir/file3copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file2copy1.txt' find: possible unquoted pattern after predicate `-exec'? find: paths must precede expression: `/usr/files/file1copy1.txt' find: possible unquoted pattern after predicate `-exec'? ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","11.45"
5296,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}' | xargs -I {} grep -w {} <(find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} +)",83,"10111.481428146362","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5297,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | sort -k 1,1",43,"1483.5917949676514","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.9"
5384,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | grep -oP '(?<=ID: ).*' | awk '{printf *%s *, $0}' | xargs -I {} echo *Here are the vulnerabilities: {}* || echo *The project is clean*",56,"2851.8545627593994","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:43:13-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:43:13-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:43:13-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:43:20-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:43:20-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.46"
7589,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice --property=ExecMainStatus | cut -d= -f2)""",665,"44310.922384262085","0","0.1","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
5303,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 --all-repeated=prefix",45,"11883.265495300293","0","0.1","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"uniq: invalid argument ‘prefix’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
5030,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6191,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"8972.585678100586","0","0.1","deepseek-v3","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
9248,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 md5sum | sort | uniq -Dw32 | cut -c35-",57,"1578.5348415374756","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","16.1"
9249,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -d -w32 | cut -c35- | xargs -n1 md5sum | sort | uniq -Dw32 | cut -c35-",57,"1578.5348415374756","0.7","0.9","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","16.1"
5024,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5916,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1542.2117710113525","0.2","0.4","gpt-3.5-turbo","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5387,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | grep -oP '(?<=ID: ).*' | awk '{printf *%s *, $0}' | xargs -I {} echo *Here are the vulnerabilities: {}* || echo *The project is clean*",61,"2353.9674282073975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"[---------------------------------------------->] 100.00% 10.58 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 6.91 MiB p/s 9.1s2025-03-24T02:45:28-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:45:28-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:45:28-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:45:28-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.560000000000002"
5445,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"3283.9159965515137","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5446,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"3283.9159965515137","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
9138,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' '; { ; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) { ; has_both++ ; } ; if (!$0 ~ /apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; printf ""Final counter value=%d ; other=%d\n"", has_both, doesnt_have_apples ; }'",125,"2159.508228302002","0.7","0.9","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.56"
9139,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' '; { ; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) { ; has_both++ ; } ; if (!$0 ~ /apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; printf ""Final counter value=%d ; other=%d\n"", has_both, doesnt_have_apples ; }'",125,"2159.508228302002","0.7","0.9","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.56"
8969,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1092,"56541.478395462036","0.2","0.4","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
9101,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;zcat records.gz | awk ';BEGIN {; RS=""\\*\\*\\*\\*\n""; has=0; other=0;};{; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) {; has++; }; if ($0 !~ /apples=2/) {; other++; };};END {; print ""Final counter value= "" has "" ; other= "" other;};'",696,"4771.4996337890625","1","1","o1-mini","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.34"
9189,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort -k1,1 | awk '{; if ($1 == prev_inode) {; printf ""%s "", $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_inode = $1;} END { if (NR > 0) print """" }' | while read -r line; do; files=($line); if [ ${#files[@]} -gt 1 ]; then; echo ""${files[@]}""; fi;done",134,"2756.504774093628","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,1,0,"Line 11: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
5376,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",86,"3452.732563018799","0","0.1","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:40:25-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:40:25-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:40:25-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:40:29-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:40:29-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.390000000000004"
5377,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",86,"3452.732563018799","0","0.1","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"nerability scanning is enabled 2025-03-24T02:41:06-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:41:06-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:41:06-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:41:06-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:41:06-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.390000000000004"
8626,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
5355,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",26,"1748.3203411102295","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
8956,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"# Read stdin into variable 'text' until first '%' character, including newlines;text="""";while IFS= read -r -d '' -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",173,"11995.249032974243","0.2","0.4","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
5353,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",26,"1851.0687351226807","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
9223,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"1951.2443542480469","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
5379,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",91,"2841.629981994629","0","0.1","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"[----------------------------------------------->] 100.00% 8.68 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 6.54 MiB p/s 9.6s2025-03-24T02:42:31-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:42:31-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:42:31-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:42:31-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.490000000000002"
9112,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3457.7078819274902","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
5360,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",1512,"26333.191871643066","0.2","0.4","deepseek-r1","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5354,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",26,"1847.1779823303223","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
9225,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | tr '\n' ' '",47,"3274.9226093292236","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","13.6"
9226,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | tr '\n' ' '",47,"3274.9226093292236","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","13.6"
5363,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",29,"2849.893808364868","0.2","0.4","deepseek-v3","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5362,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",29,"1753.3938884735107","0","0.1","deepseek-v3","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
9114,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = ******; FS = *\n*; counter = 0; other = 0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",242,"5487.3902797698975","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","13.04"
7165,"Experiment 1","HostHtml","IaC",1,1,"# Create an Nginx server block configuration for hosting index.html

cat > /etc/nginx/sites-available/my_site <<EOF
server {
 listen 80;
 server_name localhost;

 location / {
 root /usr/html;
 index index.html;
 }
}
EOF

# Enable the configuration by creating a symbolic link to sites-enabled
ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/

# Test the Nginx configuration for syntax errors
nginx -t

# Reload Nginx to apply the changes
systemctl reload nginx",128,"2262.03989982605","0.7","0.9","gpt-4o","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
8961,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash;# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text;;# Demonstrate usage of the variable (replace with your actual logic);printf ""Captured text: %s\n"" ""$text"";#!/bin/bash;# shellcheck disable=SC2034;IFS='%' read -r -d '%' text",174,"12909.732818603516","0.7","0.9","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","4.4"
9229,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",96,"1951.2505531311035","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.999999999999996"
7684,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tail -n 1)""",41,"1993.2842254638672","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
5835,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1448.106050491333","0.2","0.4","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7161,"Experiment 1","HostHtml","IaC",1,2,"# Remove the existing server block configuration to avoid conflicts;rm /etc/nginx/sites-enabled/default;;# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name localhost;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -sf /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",146,"2580.4085731506348","0","0.1","gpt-4o","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
9043,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(awk '{ if ($0 ~ /%/) { exit } else { print } }')",25,"954.1606903076172","0","0.1","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
5351,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",27,"1253.3245086669922","0.7","0.9","gpt-4o","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5357,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name ""*.txt"" -exec wc -l {} \; | awk '{total += $1} END {print total}'",38,"1547.9776859283447","0.2","0.4","llama3.3-70b","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.77"
9120,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS=******; FS=*\n*; counter=0; other=0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",245,"5788.65122795105","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.7"
5159,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"2009.1776847839355","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
9215,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"2655.2350521087646","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
7083,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash
apt-get update && apt-get install -y build-essential autoconf automake pkg-config libncurses-dev wget
mkdir -p /usr/local/htop310
wget -O /tmp/htop-3.1.0.tar.gz https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xzf /tmp/htop-3.1.0.tar.gz -C /tmp
cd /tmp/htop-3.1.0 || exit 1
autoreconf -i
./configure --prefix=/usr/local/htop310
make && make install
echo ""export PATH=\""\$PATH:/usr/local/htop310/bin\"""" > /etc/profile.d/htop310.sh
chmod +x /etc/profile.d/htop310.sh
. /etc/profile.d/htop310.sh",1960,"105695.06168365479","0.7","0.9","deepseek-r1","Jāinstalē htop 3.1.0",1,". .......... 1.42M 350K .......... .........      4.35M=0.3s 2025-04-04 02:16:21 (1.44 MB/s) - ‘/tmp/htop-3.1.0.tar.gz’ saved [378838] configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 12: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","26.6"
8986,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done < <(cat)",50,"2260.9050273895264","0","0.1","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
5358,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name ""*.txt"" -exec wc -l {} \; | awk '{total += $1} END {print total}'",38,"1546.6797351837158","0.7","0.9","llama3.3-70b","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.77"
5356,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name ""*.txt"" -exec wc -l {} \; | awk '{total += $1} END {print total}'",38,"1545.0892448425293","0","0.1","llama3.3-70b","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.77"
5352,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",551,"8172.1556186676025","1","1","o1-mini","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
9109,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = *****\n*; FS = *\n*; } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",238,"5384.242057800293","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.76"
9205,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec sha256sum {} + | sort | awk ';{; hash = $1; file = $2; files[hash] = files[hash] "" "" file;};END {; for (h in files) {; n = split(files[h], a, "" ""); if (n > 1) {; print substr(files[h], 2); }; };}'",1772,"11586.543083190918","1","1","o1-mini","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.559999999999999"
7079,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash
apt install -y build-essential autoconf automake libtool libncurses-dev pkg-config libhwloc-dev libsensors-dev
mkdir -p /usr/local/htop310
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O /tmp/htop-3.1.0.tar.gz
tar xzf /tmp/htop-3.1.0.tar.gz -C /tmp/
cd /tmp/htop-3.1.0 || exit 1
./autogen.sh
./configure --prefix=/usr/local/htop310
make -j""$(nproc)""
make install
echo ""export PATH=\""\$PATH:/usr/local/htop310/bin\"""" > /etc/profile.d/htop310.sh
chmod +x /etc/profile.d/htop310.sh
. /etc/profile.d/htop310.sh",1581,"78566.84756278992","0","0.1","deepseek-r1","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 13: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","20.35"
6282,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rl ""FAIL"" /usr/results | grep ""/result.log$"" | wc -l",25,"1270.2789306640625","0","0.1","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6635,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1547.6667881011963","0","0.1","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
8877,"Experiment 1","CreateSymlinks","NL2Bash",1,2,"cd /usr/src || exit
for file in *.java; do
 ln -s ""/usr/src/$file"" ""/path/to/current/directory/$file""
done",41,"1436.6545677185059","0.7","0.9","gpt-3.5-turbo","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"ln: failed to create symbolic link '/path/to/current/directory/file1.java': No such file or directory ln: failed to create symbolic link '/path/to/current/directory/file2.java': No such file or directory ",False,"Required symlinks were not created",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","7.1"
9033,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"3365.6229972839355","0.2","0.4","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
5242,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -fdX",100,"4154.205799102783","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
8834,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87} && echo",19,"6365.941286087036","0.7","0.9","deepseek-v3","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","3.7"
6180,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""
declare -a cmd # Array to hold extraction command and arguments

# Determine extraction command based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) cmd=(tar -xzf) ;;
 *.tar.bz2|*.tbz2) cmd=(tar -xjf) ;;
 *.tar.xz|*.txz) cmd=(tar -xJf) ;;
 *.tar) cmd=(tar -xf) ;;
 *.zip) cmd=(unzip) ;;
 *.rar) cmd=(unrar x) ;;
 *.gz)  cmd=(gunzip) ;;
 *.bz2) cmd=(bunzip2) ;;
 *.xz)  cmd=(unxz) ;;
 *.7z)  cmd=(7z x) ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Execute extraction command and check exit code directly
if ! ""${cmd[@]}"" ""$file""; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",2844,"26134.623289108276","0.7","0.9","deepseek-r1","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
4834,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5285,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | awk '{print $1}' | sort | uniq -d",626,"4063.4772777557373","1","1","o1-mini","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
7545,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2369.699716567993","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
8707,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
6189,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"8972.585678100586","0","0.1","deepseek-v3","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
4841,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6984,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash

# Install build dependencies
apt update && apt install -y build-essential autoconf automake libncurses-dev

# Create build directory
mkdir -p /usr/local/htop310 || exit 1
cd /usr/local/htop310 || exit 1

# Download and extract htop
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz
tar xzf htop-3.1.0.tar.gz
cd htop-3.1.0 || exit 1

# Build and install
./autogen.sh
./configure --prefix=/usr/local/htop310
make
make install

# Add to PATH
echo ""export PATH=/usr/local/htop310/bin:\$PATH"" > /etc/profile.d/htop310.sh
chmod +x /etc/profile.d/htop310.sh
. /etc/profile.d/htop310.sh

# Verify installation
if /usr/local/htop310/bin/htop --version; then
 echo ""htop installed successfully and added to PATH""
else
 echo ""htop installation failed"" >&2
 exit 1
fi",371,"20382.229328155518","0.7","0.9","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 24: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","43.849999999999994"
6178,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""
declare -a cmd # Array to hold extraction command and arguments

# Determine extraction command based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) cmd=(tar -xzf) ;;
 *.tar.bz2|*.tbz2) cmd=(tar -xjf) ;;
 *.tar.xz|*.txz) cmd=(tar -xJf) ;;
 *.tar) cmd=(tar -xf) ;;
 *.zip) cmd=(unzip) ;;
 *.rar) cmd=(unrar x) ;;
 *.gz)  cmd=(gunzip) ;;
 *.bz2) cmd=(bunzip2) ;;
 *.xz)  cmd=(unxz) ;;
 *.7z)  cmd=(7z x) ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Execute extraction command and check exit code directly
if ! ""${cmd[@]}"" ""$file""; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",2844,"26134.623289108276","0.7","0.9","deepseek-r1","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
5364,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",29,"1745.7945346832275","0.7","0.9","deepseek-v3","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5366,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",27,"1245.452880859375","0.2","0.4","gpt-3.5-turbo","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5253,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Install rsync if not already installed
apt-get install -y rsync

# Create a temporary directory
temp_dir=$(mktemp -d)

# Use rsync to exclude files listed in .gitignore
rsync -a --exclude-from=.gitignore ./ ""$temp_dir""

# Replace the current directory with the filtered contents
rm -rf ./*
mv ""$temp_dir""/* .

# Clean up the temporary directory
rm -rf ""$temp_dir""",186,"5150.416851043701","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.450000000000001"
5448,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1774.1165161132812","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
4848,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
4849,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
6485,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",128,"11079.681873321533","0","0.1","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6990,"Experiment 1","InstallHtop","IaC",3,2,"# Install necessary build tools
apt update
apt install -y build-essential

# Download the source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir /usr/local/htop310
tar -xzvf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310 || exit
./autogen.sh
./configure
make
make install

# Add htop binary to the path
ln -sf /usr/local/htop310/htop /usr/local/bin/htop",170,"2605.821371078491","0.7","0.9","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","14.5"
6186,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1958.5239887237549","0","0.1","deepseek-v3","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5367,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",27,"944.279670715332","0.7","0.9","gpt-3.5-turbo","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
6611,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"1050.0049591064453","0.2","0.4","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","6.799999999999999"
6607,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"5565.81974029541","0","0.1","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","6.799999999999999"
6608,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"5565.81974029541","0","0.1","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.799999999999999"
5255,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore -q {} || rm {}' \;",28,"1145.1530456542969","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5121,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4823,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7202,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl start nginx
systemctl enable nginx",37,"1110.642910003662","0.2","0.4","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
5126,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
8422,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md",49,"1758.5203647613525","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
6298,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",22,"1464.6532535552979","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6212,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"1057.229995727539","0","0.1","gpt-3.5-turbo","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5178,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash;;# Check if .gitignore exists;if [ ! -f .gitignore ]; then; echo "".gitignore file not found in the current directory.""; exit 1;fi;;# Function to convert .gitignore patterns to find expressions;convert_pattern() {; local pattern=""$1""; # Escape special characters for find; pattern=$(printf '%q' ""$pattern""); # Handle directory patterns; if [[ ""$pattern"" == */ ]]; then; echo ""-type d -name \""${pattern%/}\""""; else; echo ""-type f -name \""$pattern\""""; fi;};;# Read .gitignore patterns, ignoring comments and empty lines;mapfile -t patterns < <(grep -vE '^\s*(#|$)' .gitignore);;# Initialize find commands;find_cmd=""find ."";;# Build find expression;find_expr="""";for pattern in ""${patterns[@]}""; do; expr=$(convert_pattern ""$pattern""); if [ -n ""$expr"" ]; then; find_expr+="" -o $expr""; fi;done;;# Remove the first '-o';find_expr=${find_expr# -o };;# Combine and execute the find command;if [ -n ""$find_expr"" ]; then; eval ""$find_cmd \\( $find_expr \\) -exec rm -rf {} +"";else; echo ""No patterns found to delete."";fi",2493,"16980.484008789062","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","-1"
5122,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4826,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","8.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5132,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6305,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",566,"7682.657480239868","0","0.1","deepseek-r1","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6293,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",23,"1094.5110321044922","0.2","0.4","gpt-4o","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6221,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1647.4695205688477","0","0.1","gpt-3.5-turbo","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6291,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",36,"1293.7541007995605","0.7","0.9","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
7693,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",2815,"131707.7341079712","0.7","0.9","deepseek-r1","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
6094,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""${file##*.}"" in
 zip) unzip ""$file"" ;;
 tar) tar -xvf ""$file"" ;;
 gz) tar -xzvf ""$file"" ;;
 bz2) tar -xjvf ""$file"" ;;
 xz) tar -xJvf ""$file"" ;;
 7z) 7z x ""$file"" ;;
 rar) unrar x ""$file"" ;;
 *) echo ""Unsupported archive type: $file"" ;;
 esac
done",122,"2118.070125579834","0.7","0.9","gpt-4o","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.099999999999998"
6095,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""${file##*.}"" in
 zip) unzip ""$file"" ;;
 tar) tar -xvf ""$file"" ;;
 gz) tar -xzvf ""$file"" ;;
 bz2) tar -xjvf ""$file"" ;;
 xz) tar -xJvf ""$file"" ;;
 7z) 7z x ""$file"" ;;
 rar) unrar x ""$file"" ;;
 *) echo ""Unsupported archive type: $file"" ;;
 esac
done",122,"2118.070125579834","0.7","0.9","gpt-4o","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.099999999999998"
6096,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""${file##*.}"" in
 zip) unzip ""$file"" ;;
 tar) tar -xvf ""$file"" ;;
 gz) tar -xzvf ""$file"" ;;
 bz2) tar -xjvf ""$file"" ;;
 xz) tar -xJvf ""$file"" ;;
 7z) 7z x ""$file"" ;;
 rar) unrar x ""$file"" ;;
 *) echo ""Unsupported archive type: $file"" ;;
 esac
done",122,"2118.070125579834","0.7","0.9","gpt-4o","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.099999999999998"
5585,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1450.5157470703125","0","0.1","gpt-4o",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5179,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash;;# Check if .gitignore exists;if [ ! -f .gitignore ]; then; echo "".gitignore file not found in the current directory.""; exit 1;fi;;# Function to convert .gitignore patterns to find expressions;convert_pattern() {; local pattern=""$1""; # Escape special characters for find; pattern=$(printf '%q' ""$pattern""); # Handle directory patterns; if [[ ""$pattern"" == */ ]]; then; echo ""-type d -name \""${pattern%/}\""""; else; echo ""-type f -name \""$pattern\""""; fi;};;# Read .gitignore patterns, ignoring comments and empty lines;mapfile -t patterns < <(grep -vE '^\s*(#|$)' .gitignore);;# Initialize find commands;find_cmd=""find ."";;# Build find expression;find_expr="""";for pattern in ""${patterns[@]}""; do; expr=$(convert_pattern ""$pattern""); if [ -n ""$expr"" ]; then; find_expr+="" -o $expr""; fi;done;;# Remove the first '-o';find_expr=${find_expr# -o };;# Combine and execute the find command;if [ -n ""$find_expr"" ]; then; eval ""$find_cmd \\( $find_expr \\) -exec rm -rf {} +"";else; echo ""No patterns found to delete."";fi",2493,"16980.484008789062","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","-1"
8321,"Experiment 1","FindDate","NL2Bash",3,2,"date -d *2013-05-01 + $((7 - $(date -d *2013-05-01* +%u) % 7)) % 7 days* +*%Y-%m-%d*",59,"2075.5438804626465","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘2013-05-01 + 4 % 7 days’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
8861,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""${file##*/}""
done",30,"1452.4593353271484","0.2","0.4","llama3.3-70b","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
4874,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5798,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1859.370470046997","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7640,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1057.5037002563477","0","0.1","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7642,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1955.7552337646484","0","0.1","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
6986,"Experiment 1","InstallHtop","IaC",3,2,"# Install required build tools
apt update
apt install -y build-essential

# Download htop source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir -p /usr/local/htop310
tar -xzf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310 || exit
./autogen.sh
./configure
make
make install

# Add htop binary to the system path
ln -sf /usr/local/bin/htop /usr/local/htop310/htop

# Clean up
rm htop-3.1.0.tar.gz",190,"3165.109157562256","0","0.1","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"d. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' rm: cannot remove 'htop-3.1.0.tar.gz': No such file or directory ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","15.9"
8322,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 + 7 - $(date -d '2013-05-01' +%u) days"" +%Y-%m-%d",43,"3551.734209060669","0","0.1","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘2013-05-01 + 7 - 3 days’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
5734,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",143,"12588.644742965698","0.7","0.9","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","13.450000000000001"
5548,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",44,"2092.625856399536","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8862,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1753.9944648742676","0.7","0.9","llama3.3-70b","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
6141,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 esac
done",160,"3597.9018211364746","0","0.1","llama3.3-70b","arhīvs ir .7z",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.199999999999996"
5197,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Restore files that were deleted by git clean git checkout -- .gitignore data.log program.js #!/bin/bash # Ensure extundelete is installed if ! command -v extundelete &> /dev/null; then apt install -y extundelete fi # Replace /dev/sdXN with the actual partition where the files were deleted extundelete /dev/sdXN --restore-all",278,"7098.963260650635","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3," caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: extundelete: No such file or directory /dev/sdXN extundelete: No such file or directory when trying to open filesystem /dev/sdXN ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","19.349999999999998"
5589,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1450.5157470703125","0","0.1","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4890,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: ./*.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8432,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1361.163854598999","0.7","0.9","llama3.3-70b","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
4617,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",779,"14366.31989479065","0.2","0.4","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"find: Unknown argument to -type: ( ",False,"An image with extensions .apng was not deleted",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.7"
6153,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"3465.360403060913","0.7","0.9","llama3.3-70b","arhīvs ir .gz",1,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.55"
7277,"Experiment 1","Factorial","NL2Bash",2,2,"factorial() {
 local num=$1
 local result=1
 for ((i=2; i<=num; i++)); do
 result=$((result * i))
 done
 echo $result
}

echo ""623! = $(factorial 623)""",64,"1479.3727397918701","0.2","0.4","llama3.3-70b","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7169,"Experiment 1","HostHtml","IaC",1,2,"# Create the web root directory
mkdir -p /usr/html

# Create the index.html file
echo ""<!DOCTYPE html><html><head><title>Welcome</title></head><body><h1>Hello, World!</h1></body></html>"" > /usr/html/index.html

# Set appropriate permissions
chmod -R 755 /usr/html

# Remove the default Nginx site configuration
rm -f /etc/nginx/sites-enabled/default

# Create a new Nginx site configuration
cat > /etc/nginx/sites-available/my_site <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;

 server_name _;

 root /usr/html;
 index index.html;

 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF

# Enable the new site by creating a symbolic link
ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/

# Test Nginx configuration and restart the service
nginx -t && systemctl restart nginx",1458,"12457.233905792236","1","1","o1-mini","index.html patstāvīgs",1,"nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5713,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f2-);echo ""$USERNAME""",147,"11077.015399932861","0","0.1","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6103,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash;;# Find the first archive file matching archive.* in the current directory;file=$(find . -maxdepth 1 -type f -name 'archive.*' -print -quit);;if [ -z ""$file"" ]; then; echo ""No archive file named archive.* found in the current directory.""; exit 1;fi;;case ""$file"" in; *.tar.gz|*.tgz); tar -xzf ""$file"";;; *.tar.bz2|*.tbz2); tar -xjf ""$file"";;; *.tar.xz|*.txz); tar -xJf ""$file"";;; *.zip); unzip ""$file"";;; *.7z); 7z x ""$file"";;; *.gz); gunzip ""$file"";;; *.bz2); bunzip2 ""$file"";;; *.xz); unxz ""$file"";;; *); echo ""Unsupported archive format: $file""; exit 1;;;esac",692,"5174.609184265137","1","1","o1-mini","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
4857,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5564,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1067.7311420440674","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
5568,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1343.9648151397705","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
7218,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"3071.146249771118","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
4631,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",326,"4766.117334365845","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
7195,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed;apt update && apt install -y nginx;;# Create the default nginx site config;cat > /etc/nginx/sites-available/default <<EOF;server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files \$uri \$uri/ =404;; };};EOF;;# Create the html directory if it doesn't exist;mkdir -p /usr/html;;# Create a basic index.html if it doesn't exist;if [ ! -f /usr/html/index.html ]; then; cat > /usr/html/index.html <<EOF;<!DOCTYPE html>;<html>;<head>; <title>Welcome</title>;</head>;<body>; <h1>Welcome to nginx!</h1>;</body>;</html>;EOF;fi;;# Restart nginx to apply changes;systemctl restart nginx",213,"14360.984563827515","0.7","0.9","deepseek-v3","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5751,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"1371.0200786590576","0.2","0.4","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
6105,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash;;# Find the first archive file matching archive.* in the current directory;file=$(find . -maxdepth 1 -type f -name 'archive.*' -print -quit);;if [ -z ""$file"" ]; then; echo ""No archive file named archive.* found in the current directory.""; exit 1;fi;;case ""$file"" in; *.tar.gz|*.tgz); tar -xzf ""$file"";;; *.tar.bz2|*.tbz2); tar -xjf ""$file"";;; *.tar.xz|*.txz); tar -xJf ""$file"";;; *.zip); unzip ""$file"";;; *.7z); 7z x ""$file"";;; *.gz); gunzip ""$file"";;; *.bz2); bunzip2 ""$file"";;; *.xz); unxz ""$file"";;; *); echo ""Unsupported archive format: $file""; exit 1;;;esac",692,"5174.609184265137","1","1","o1-mini","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
5752,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"1371.0200786590576","0.2","0.4","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
4630,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",326,"4766.117334365845","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
4866,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: ./*.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6396,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1764.254093170166","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6397,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2347.381353378296","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
4912,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5507,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2657.7975749969482","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
7069,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash;;# Stop the current PostgreSQL 16 cluster;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;export DEBIAN_FRONTEND=noninteractive;apt-get update;apt-get install -y postgresql-17;;# Check if 17/main cluster already exists;if pg_lsclusters | grep -q '^17.*main'; then; echo ""Cluster 17/main already exists - removing it first""; pg_dropcluster 17 main --stop;fi;;# Perform the upgrade using pg_upgradecluster with --rename-conflicting option;pg_upgradecluster -v 17 16 main --rename-conflicting;;# Verify the upgrade was successful;if sudo -u postgres psql -c ""SELECT version();"" | grep -q 'PostgreSQL 17'; then; # Remove the old cluster after successful upgrade; pg_dropcluster 16 main --stop; # Start the new PostgreSQL 17 cluster; systemctl start postgresql@17-main; echo ""Upgrade completed successfully""; sudo -u postgres psql -c ""SELECT version();"";else; echo ""Upgrade failed - keeping old cluster""; systemctl start postgresql@16-main;fi",445,"21523.858070373535","0.2","0.4","deepseek-v3","Jāinstalē postgres 17",2,"W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. W: https://apt.postgresql.org/pub/repos/apt/dists/bookworm-pgdg/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. Unknown option: rename-conflicting ",False,"Old cluster was not removed after upgrading",0,0,0,0,"","9.5","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","43.05"
7643,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1955.7552337646484","0","0.1","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
4644,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4460.139036178589","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4815,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5756,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo $USERNAME",29,"1344.003677368164","0.7","0.9","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4921,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"jq: error (at <stdin>:1): Cannot index string with string *user* parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
5458,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in ./*.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",982,"6365.255355834961","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
6238,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",13,"851.8917560577393","0.7","0.9","gpt-3.5-turbo","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
4516,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"2020.2162265777588","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4517,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"2020.2162265777588","0.2","0.4","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7278,"Experiment 1","Factorial","NL2Bash",2,1,"#!/bin/bash

factorial() {
 local num=$1
 local result=1
 for ((i=2; i<=num; i++)); do
 result=$((result * i))
 done
 echo $result
}

echo $(factorial 623)",64,"2972.9084968566895","0.7","0.9","llama3.3-70b","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",1,0,1,0,"Line 12: Quote this to prevent word splitting. Line 12: Useless echo? Instead of 'echo $(cmd)', just use 'cmd'. ","2.5","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
5398,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[].Vulnerabilities[]?.VulnerabilityID' | sort -u | xargs);if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",934,"16701.20644569397","0","0.1","deepseek-r1","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5762,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo ""$USERNAME""",29,"948.2383728027344","0.7","0.9","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4927,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5393,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .VulnID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",79,"2149.759292602539","0.2","0.4","llama3.3-70b","Projekts bez ievainojamībām",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5739,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"2147.5472450256348","0","0.1","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
7211,"Experiment 1","VerifyFile","IaC",1,1,"# Import the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the file against its signature
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",95,"1964.7493362426758","0.2","0.4","gpt-4o","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
7644,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1955.7552337646484","0","0.1","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7517,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"1666.6936874389648","0.2","0.4","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
4556,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"1655.280351638794","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4557,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"1655.280351638794","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
6313,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"858.7601184844971","0.2","0.4","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
7071,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash;;# Stop the current PostgreSQL 16 cluster;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;apt update;apt install -y postgresql-17;;# Check if 17/main cluster already exists;if pg_lsclusters | grep -q '17/main'; then; echo ""Cluster 17/main already exists - removing it first""; pg_dropcluster 17 main --stop;fi;;# Create a new cluster for PostgreSQL 17 (temporarily);pg_createcluster 17 main --start --port=5433;;# Stop the new cluster to prepare for upgrade;systemctl stop postgresql@17-main;;# Perform the upgrade using pg_upgradecluster;pg_upgradecluster -v 17 -m upgrade 16 main;;# Verify the upgrade was successful before removing old cluster;if [ $? -eq 0 ]; then; # Remove the old cluster; pg_dropcluster 16 main --stop; # Update default port back to 5432 if needed; sed -i 's/port = 5433/port = 5432/' /etc/postgresql/17/main/postgresql.conf; # Restart the new cluster; systemctl restart postgresql@17-main; # Update alternatives if they exist; if [ -f /etc/alternatives/pg_config ]; then; update-alternatives --auto pg_config; fi; if [ -f /etc/alternatives/pg_ctl ]; then; update-alternatives --auto pg_ctl; fi; if [ -f /etc/alternatives/postgresql ]; then; update-alternatives --auto postgresql; fi; echo ""PostgreSQL upgrade from 16 to 17 completed successfully"";else; echo ""Upgrade failed - keeping PostgreSQL 16 cluster intact""; systemctl start postgresql@16-main;fi;chmod +x upgrade_postgres.sh;./upgrade_postgres.sh",555,"24500.84948539734","0.7","0.9","deepseek-v3","Jāinstalē postgres 17",2,"dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists chmod: cannot access 'upgrade_postgres.sh': No such file or directory /media/sf_scripts/UpgradePostgres_deepseek-v3_0.7_0.9_2.sh: line 53: ./upgrade_postgres.sh: No such file or directory ",False,"Old cluster was not removed after upgrading",1,0,0,0,"Line 26: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","9.0","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","66.35000000000001"
4713,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4558,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"1655.280351638794","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
5592,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"1446.8586444854736","0.2","0.4","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8495,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",150,"11584.298610687256","0","0.1","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7244,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1

if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",1648,"84885.16092300415","0.2","0.4","deepseek-r1","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
4562,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3361.6762161254883","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4563,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3361.6762161254883","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4720,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5633,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1643.474817276001","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5634,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1643.474817276001","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
6197,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"9391.114711761475","0.2","0.4","deepseek-v3","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
8508,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"847.6958274841309","0","0.1","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7146,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create the directory on the host if it doesn't exist;mkdir -p /usr/alpinedata;;# Run the Alpine container with the volume mounted;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",68,"7090.567588806152","0.7","0.9","deepseek-v3","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
7285,"Experiment 1","Factorial","NL2Bash",2,1,"#!/bin/bash

factorial() {
 local n=$1
 if (( n <= 1 )); then
 echo 1
 else
 echo $(( n * $(factorial $((n - 1))) ))
 fi
}

factorial 623",63,"10394.858837127686","0.7","0.9","deepseek-v3","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
4726,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5629,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1345.876932144165","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
4732,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7047,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL 16 service
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install -y postgresql-17

# Initialize a new cluster for PostgreSQL 17
pg_createcluster 17 main --start

# Upgrade the data from PostgreSQL 16 to 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 service
systemctl start postgresql@17-main

# Optionally, remove the old PostgreSQL 16 cluster
pg_dropcluster 16 main --stop",122,"3140.8851146698","0","0.1","gpt-4o","Jāinstalē postgres 17",2," apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","9.9"
8323,"Experiment 1","FindDate","NL2Bash",3,2,"for i in {1..7}; do 
 DATE=$(date -d ""2013-05-$i"" +%Y-%m-%d); 
 if [ $(date -d ""$DATE"" +%u) -eq 1 ]; then 
 echo $DATE; 
 break; 
 fi; 
done",73,"1557.807207107544","0","0.1","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"",False,"",0,1,1,0,"Line 4: Quote this to prevent word splitting. Line 5: Double quote to prevent globbing and word splitting. ","10.0","","NO_RISK","Print date of first Monday in May, 2013","12.45"
7048,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop both PostgreSQL 16 and 17 services
systemctl stop postgresql@16-main
systemctl stop postgresql@17-main

# Remove the existing PostgreSQL 17 cluster to avoid conflicts
pg_dropcluster 17 main --stop

# Recreate the PostgreSQL 17 cluster
pg_createcluster 17 main

# Upgrade the data from PostgreSQL 16 to 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 service
systemctl start postgresql@17-main

# Verify the upgrade by checking the status of the new cluster
pg_lsclusters

# Optionally, remove the old PostgreSQL 16 cluster if everything is working fine
pg_dropcluster 16 main --stop",156,"3799.7493743896484","0","0.1","gpt-4o","Jāinstalē postgres 17",2,"Error: specified cluster does not exist Error: no initdb program for version 17 found Error: cluster 16/main is already on version 16. (The newest version installed on this system is 16.) Assertion failed on job for postgresql@17-main.service. ",False,"Postgres 17 was not installed (based on *psql --version*)",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.200000000000001"
4886,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4730,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8666,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7279,"Experiment 1","Factorial","NL2Bash",2,2,"#!/bin/bash

factorial() {
 local num=$1
 local result=1
 for ((i=2; i<=num; i++)); do
 result=$((result * i))
 done
 echo ""$result""
}

factorial 623",62,"2487.3836040496826","0.7","0.9","llama3.3-70b","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
4701,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7694,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",2815,"131707.7341079712","0.7","0.9","deepseek-r1","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
7518,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"1666.6936874389648","0.2","0.4","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7519,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"1666.6936874389648","0.2","0.4","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
6022,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",1915,"22833.45365524292","0.2","0.4","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7282,"Experiment 1","Factorial","NL2Bash",2,1,"seq -s '*' 1 623 | bc",695,"48337.827920913696","0.7","0.9","deepseek-r1","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","3.8"
7280,"Experiment 1","Factorial","NL2Bash",2,1,"seq 623 | paste -sd '*' | bc",1020,"63401.22675895691","0","0.1","deepseek-r1","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","6.05"
7286,"Experiment 1","Factorial","NL2Bash",2,2,"#!/bin/bash

# Calculate factorial using bc for arbitrary precision
echo ""define f(x) { if (x <= 1) return (1); return (x * f(x-1)); } f(623);"" | bc
#!/bin/bash

fact=1
for ((i=1; i<=623; i++)); do
 fact=$(echo ""$fact * $i"" | bc)
done
echo ""$fact""",196,"14768.948793411255","0.7","0.9","deepseek-v3","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","-1"
7695,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+' | head -n 1 | awk '{print ""IP: "" $1}'",53,"9478.555679321289","0","0.1","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
5678,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",30,"2451.056480407715","0.7","0.9","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7142,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"5911.133766174316","0.2","0.4","deepseek-v3","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7064,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the PostgreSQL 16 service;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;pg_ctlcluster 17 main init;;# Use pg_upgrade to upgrade the data in link mode;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf' \;  -l /var/log/postgresql/upgrade.log;;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16/main;;# Start the PostgreSQL 17 service;systemctl start postgresql@17-main;;# Enable the PostgreSQL 17 service to start at boot;systemctl enable postgresql@17-main",223,"1925.4035949707031","0.2","0.4","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.450000000000001"
8392,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",41,"1068.2544708251953","0.2","0.4","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.25"
4705,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8670,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
7246,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Check if required files exist
if [[ ! -f data.tgz || ! -f data.tgz.asc ]]; then
 echo ""FAIL""
 exit 1
fi

# Create temporary GNUPG home
temp_dir=$(mktemp -d)
export GNUPGHOME=""$temp_dir""

# Import key from keyserver
if ! gpg --batch --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 &>/dev/null; then
 echo ""FAIL""
 rm -rf ""$temp_dir""
 exit 1
fi

# Verify signature and capture result
if gpg --batch --verify data.tgz.asc data.tgz &>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi

# Cleanup
rm -rf ""$temp_dir""",2399,"116611.03749275208","0.7","0.9","deepseek-r1","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","42.1"
7287,"Experiment 1","Factorial","NL2Bash",2,1,"factorial=1
for (( i=1; i<=623; i++ )); do
 factorial=$((factorial * i))
done
echo $factorial",40,"1061.201810836792","0","0.1","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7288,"Experiment 1","Factorial","NL2Bash",2,2,"factorial=1
for (( i=1; i<=623; i++ )); do
 factorial=$(echo ""$factorial * $i"" | bc)
done
echo $factorial",46,"1309.4069957733154","0","0.1","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,1,0,0,"Line 6: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
8671,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
6167,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Enable nullglob to prevent literal interpretation if no files match
shopt -s nullglob

# Find all files matching archive.* pattern
files=(archive.*)

# Check if exactly one file exists
if [[ ${#files[@]} -ne 1 ]]; then
 echo ""Error: Exactly one archive.* file must exist in the current directory"" >&2
 exit 1
fi

filename=""${files[0]}""

# Extract based on file extension
case ""$filename"" in
 *.tar.bz2|*.tbz2) tar xjf ""$filename"" ;;
 *.tar.gz|*.tgz) tar xzf ""$filename"" ;;
 *.tar.xz) tar xJf ""$filename"" ;;
 *.tar) tar xf ""$filename"" ;;
 *.zip) unzip ""$filename"" ;;
 *.gz)  gunzip ""$filename"" ;;
 *.bz2) bunzip2 ""$filename"" ;;
 *.rar) unrar x ""$filename"" ;;
 *.7z)  7z x ""$filename"" ;;
 *)
 echo ""Unsupported archive format: $filename"" >&2
 exit 1
 ;;
esac

echo ""Extracted $filename successfully""",1753,"16222.480058670044","0.2","0.4","deepseek-r1","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6300,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3072c -size -9216c",25,"1369.459867477417","0","0.1","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6295,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",355,"3470.8986282348633","1","1","o1-mini","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
7258,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>/dev/null | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1571.4502334594727","0.2","0.4","gpt-3.5-turbo","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
4707,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6980,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash

# Install required dependencies
apt update && apt install -y build-essential autoconf automake libncurses-dev

# Create the target directory
mkdir -p /usr/local/htop310

# Download and extract htop
cd /tmp || exit
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz
tar xzf htop-3.1.0.tar.gz
cd htop-3.1.0 || exit

# Compile and install
./autogen.sh
./configure --prefix=/usr/local/htop310
make -j""$(nproc)""
make install

# Add to PATH
echo ""export PATH=/usr/local/htop310/bin:\$PATH"" > /etc/profile.d/htop310.sh
chmod +x /etc/profile.d/htop310.sh
# shellcheck source=/dev/null
source /etc/profile.d/htop310.sh",314,"19015.41304588318","0","0.1","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","26.000000000000004"
7236,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796 && 
gpg --verify data.tgz.asc data.tgz && echo ""OK"" || echo ""FAIL""",65,"3672.297477722168","0.7","0.9","llama3.3-70b","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.650000000000002"
4797,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4798,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"grep: subdir: Is a directory ",False,"Users were found but the output should be alphabetically sorted.",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6962,"Experiment 1","InstallHtop","IaC",3,2,"mkdir -p /usr/local/htop310;cd /usr/local/htop310 || exit;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz;tar -xzf 3.1.0.tar.gz --strip-components=1;./autogen.sh;./configure --prefix=/usr/local/htop310;make;make install;;echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile.d/htop310.sh;source /etc/profile.d/htop310.sh",130,"2059.53049659729","0.2","0.4","gpt-4o","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,0,0,"Line 11: Expressions don't expand in single quotes, use double quotes for that. Line 12: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","6.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.9"
8672,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
4804,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6107,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3438.389539718628","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
5950,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"854.9337387084961","0.7","0.9","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4805,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"jq: error (at data1.txt:1): Cannot index string with string *user* parse error: Invalid numeric literal at line 1, column 17 ",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6969,"Experiment 1","InstallHtop","IaC",3,1,"cd /usr/local wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf 3.1.0.tar.gz mv htop-3.1.0 htop310 cd htop310 ./configure --prefix=/usr/local/htop310 make make install ln -s /usr/local/htop310/bin/htop /usr/local/bin/htop",112,"3456.946611404419","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,".... .......... .......... 81% 6.97M 0s 300K .......... .......... .......... .......... .......... 94% 8.87M 0s 350K .......... .........     100% 11.1M=0.2s 2025-04-03 04:18:55 (1.95 MB/s) - ‘3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_qwen_qwen2.5-coder-32b-instruct_0.2_0.4.sh: line 6: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,0,1,0,"Line 2: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","3.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","11.299999999999999"
6108,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3438.389539718628","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
9346,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;find /home -path ""*/public_html/wp-includes/version.php"" -exec grep -hPo ""^\\\$wp_version\\s*=\\s*'\\K[^']+"" {} + | while read -r version; do echo ""Found: $version""; done",3975,"189937.1166229248","0.7","0.9","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","12.1"
5426,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2335.8707427978516","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
4813,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5760,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo ""$USERNAME""",29,"948.2383728027344","0.7","0.9","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5761,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo ""$USERNAME""",29,"948.2383728027344","0.7","0.9","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8677,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8679,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
9326,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Search all home directories for WordPress installations;find /home -type d -name 'public_html' -o -type d -name 'www' | while read -r webroot; do; # Check if this directory contains WordPress; if [ -f ""$webroot/wp-includes/version.php"" ]; then; version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$webroot/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version (in $webroot)""; fi; fi; # Also check for WordPress in subdirectories; find ""$webroot"" -maxdepth 3 -type f -name 'version.php' | grep '/wp-includes/version.php$' | while read -r version_file; do; version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [ -n ""$version"" ]; then; wp_path=$(dirname ""$(dirname ""$version_file"")""); echo ""Found: $version (in $wp_path)""; fi; done;done",435,"27662.121772766113","0","0.1","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
4816,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8680,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8676,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
4787,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6160,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"2651.2489318847656","0.7","0.9","llama3.3-70b","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.550000000000004"
6972,"Experiment 1","InstallHtop","IaC",3,2,"cd /usr/local || exit wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf 3.1.0.tar.gz mv htop-3.1.0 htop310 cd htop310 || exit autoreconf -i ./configure --prefix=/usr/local/htop310 make make install echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile source /etc/profile",125,"3443.668842315674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,"is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:547: warning: configure is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' ",False,"Htop was installed but not added to path",0,2,0,0,"Line 11: Expressions don't expand in single quotes, use double quotes for that. Line 12: Not following: /etc/profile was not specified as input (see shellcheck -x). ","6.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","18.55"
6960,"Experiment 1","InstallHtop","IaC",3,2,"mkdir -p /usr/local/htop310
cd /usr/local/htop310 || exit
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xzf 3.1.0.tar.gz --strip-components=1
./autogen.sh
./configure --prefix=/usr/local/htop310
make
make install
echo ""export PATH=\$PATH:/usr/local/htop310/bin"" >> /etc/profile
source /etc/profile",119,"1652.8255939483643","0","0.1","gpt-4o","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,0,0,"Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","7.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.9"
9388,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all Wordpress installations under users' public_html directories;wp_sites=$(find /home/*/public_html/ -name wp-includes -type d 2>/dev/null);;# Loop through each Wordpress installation and extract the version;for site in $wp_sites; do; version=$(grep ""wp_version = "" $site/version.php 2>/dev/null | cut -d""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",117,"4264.639616012573","0.2","0.4","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.399999999999999"
9386,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;for user_home in /home/*/public_html; do; if [ -d ""$user_home/wp-includes"" ]; then; version=$(grep ""wp_version = "" ""$user_home/wp-includes/version.php"" | cut -d \' -f 2); echo ""Found: $version""; fi;done",77,"2154.310703277588","0","0.1","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.1"
4790,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4794,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4795,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5720,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2-);echo ""$USERNAME""",135,"11084.251880645752","0.2","0.4","deepseek-v3",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5721,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2-);echo ""$USERNAME""",135,"11084.251880645752","0.2","0.4","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5679,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",30,"2451.056480407715","0.7","0.9","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8650,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
4740,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8645,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
8647,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
4741,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6976,"Experiment 1","InstallHtop","IaC",3,2,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
mv htop-3.1.0 /usr/local/htop310
cd /usr/local/htop310/htop-3.1.0 || exit
./autogen.sh || exit
./configure --prefix=/usr/local/htop310 || exit
make || exit
make install || exit
echo ""export PATH=$PATH:/usr/local/htop310/bin"" >> /root/.bashrc
source /root/.bashrc",150,"1762.8283500671387","0.2","0.4","llama3.3-70b","Jāinstalē htop 3.1.0",1,"",False,"",0,1,0,0,"Line 12: Not following: /root/.bashrc was not specified as input (see shellcheck -x). ","12.0","","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","22.45"
5684,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env && echo ""$USERNAME""",1262,"21938.18426132202","0","0.1","deepseek-r1",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5683,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env && echo ""$USERNAME""",1262,"21938.18426132202","0","0.1","deepseek-r1",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5662,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"2146.8234062194824","0.2","0.4","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
4743,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6213,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"1057.229995727539","0","0.1","gpt-3.5-turbo","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
9379,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ] && [ -d ""$user/public_html"" ]; then; if [ -f ""$user/public_html/wp-includes/version.php"" ]; then; version=$(grep -oP 'Version: \K[0-9\.]+' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; else; echo ""Found: Unknown""; fi; fi; fi;done",127,"1761.1210346221924","0.2","0.4","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","46.8"
4744,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",True,"",0,0,0,0,"","9.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4745,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6974,"Experiment 1","InstallHtop","IaC",3,2,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
mv htop-3.1.0 /usr/local/htop310
cd /usr/local/htop310/htop-3.1.0 || exit
autoreconf -i
./configure --prefix=/usr/local/htop310
make
make install
ln -s /usr/local/htop310/bin/htop /usr/local/bin/htop",136,"1777.7180671691895","0","0.1","llama3.3-70b","Jāinstalē htop 3.1.0",1,"is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:547: warning: configure is generated without pkg.m4. 'make dist' target will be disabled. configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","15"
8651,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8708,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8709,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
9381,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user"" ]; then; for file in ""$user/public_html/wp-includes/version.php""; do; if [ -f ""$file"" ]; then; version=$(grep '$wp_version' ""$file"" | cut -d ""'"" -f2); echo ""Found: $version""; fi; done; fi;done",91,"1858.039140701294","0.7","0.9","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,1,0,1,"Line 4: Since you double quoted this, it will not word split, and the loop will only run once. Line 6: Expressions don't expand in single quotes, use double quotes for that. ","1.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","29.55"
7698,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+(?=/\d+)' | grep -v '127.0.0.1' | head -n 1 | awk '{print ""IP: "" $1}';ip -4 addr show $(ip route | awk '/default/ {print $5}') | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+' | head -n 1 | awk '{print ""IP: "" $1}'",199,"16604.663372039795","0","0.1","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"",0,0,1,0,"Line 3: Quote this to prevent word splitting. ","11.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","24.33"
5723,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2-);echo ""$USERNAME""",135,"11084.251880645752","0.2","0.4","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5724,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2-);echo ""$USERNAME""",135,"11084.251880645752","0.2","0.4","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8653,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6202,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1864.5775318145752","0.7","0.9","deepseek-v3","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
7666,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show $(ip route show default | awk '/default/ {print $5}') | awk '/inet / {print ""IP: ""$2}' | cut -d/ -f1",47,"2374.9797344207764","0.7","0.9","gpt-4o","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","11.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.73"
5709,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"2147.033452987671","0","0.1","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5706,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"2147.033452987671","0","0.1","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
6205,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1864.5775318145752","0.7","0.9","deepseek-v3","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
8654,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8656,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7680,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tail -n 1)""",41,"2024.146318435669","0","0.1","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
6979,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash;;# Install required dependencies;apt update && apt install -y build-essential autoconf automake libncurses-dev;;# Create the target directory;mkdir -p /usr/local/htop310;;# Download and extract htop;cd /tmp;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz;tar xzf htop-3.1.0.tar.gz;cd htop-3.1.0;;# Compile and install;./autogen.sh;./configure --prefix=/usr/local/htop310;make -j$(nproc);make install;;# Add to PATH;echo 'export PATH=/usr/local/htop310/bin:$PATH' > /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh;source /etc/profile.d/htop310.sh",216,"14287.331819534302","0","0.1","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,2,0,"Line 10: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 13: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 18: Quote this to prevent word splitting. Line 22: Expressions don't expand in single quotes, use double quotes for that. Line 24: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","3.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","21.4"
7546,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2369.699716567993","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
8655,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6470,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';NR==1 {; for (i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; };};NR > 1 {; gsub(/[,""]/, """", $col); sum += $col; count++;};END {; printf ""Mean: %.2f\n"", count ? sum/count : 0;}' products.csv",2393,"29831.347703933716","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6471,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';NR==1 {; for (i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; };};NR > 1 {; gsub(/[,""]/, """", $col); sum += $col; count++;};END {; printf ""Mean: %.2f\n"", count ? sum/count : 0;}' products.csv",2393,"29831.347703933716","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6472,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';NR==1 {; for (i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; };};NR > 1 {; gsub(/[,""]/, """", $col); sum += $col; count++;};END {; printf ""Mean: %.2f\n"", count ? sum/count : 0;}' products.csv",2393,"29831.347703933716","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
8713,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8714,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
6174,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""

# Extract based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) tar -xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar -xjf ""$file"" ;;
 *.tar.xz|*.txz) tar -xJf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.gz)  gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz)  unxz ""$file"" ;;
 *.7z)  7z x ""$file"" ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Check if extraction succeeded
if [[ $? -ne 0 ]]; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",1821,"46573.923110961914","0.7","0.9","deepseek-r1","arhīvs ir .xz",2,"",False,"",1,0,0,0,"Line 36: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","12.5","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
7145,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create the directory on the host if it doesn't exist;mkdir -p /usr/alpinedata;;# Run the Alpine container with the volume mounted;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",68,"7090.567588806152","0.7","0.9","deepseek-v3","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
6480,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; }; };};NR > 1 && $col != """" {; gsub(/,/, """", $col); sum += $col; count++;};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",955,"12679.79907989502","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","7.71"
6477,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; }; };};NR > 1 && $col != """" {; gsub(/,/, """", $col); sum += $col; count++;};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",955,"12679.79907989502","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","7.71"
7547,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2369.699716567993","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6478,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; }; };};NR > 1 && $col != """" {; gsub(/,/, """", $col); sum += $col; count++;};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",955,"12679.79907989502","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","7.71"
5731,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",143,"12588.644742965698","0.7","0.9","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","13.450000000000001"
8385,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"949.9225616455078","0","0.1","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
5431,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1846.451997756958","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
6483,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"" || $i == ""\""price\"""") {; col = i; }; };};NR > 1 {; if ($col != """") {; # Remove all non-numeric characters except decimal point; gsub(/[^0-9.]/, """", $col); # Handle empty strings after cleanup; if ($col != """") {; sum += $col; count++; }; };};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",1880,"19606.629133224487","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","7.25","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
6484,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"" || $i == ""\""price\"""") {; col = i; }; };};NR > 1 {; if ($col != """") {; # Remove all non-numeric characters except decimal point; gsub(/[^0-9.]/, """", $col); # Handle empty strings after cleanup; if ($col != """") {; sum += $col; count++; }; };};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",1880,"19606.629133224487","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"The mean value was not correctly calculated. Column may contain decimal point values",0,0,0,0,"","7.25","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
8715,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8716,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8684,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
4739,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6468,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; # Remove quotes and trim whitespace from header name; gsub(/[""]/, """", $i); header = tolower($i); sub(/^[ \t]+/, """", header); sub(/[ \t]+$/, """", header); if (header == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; # Remove currency symbols, commas, and quotes from the value; gsub(/[""$£,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",905,"9772.428274154663","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"The mean value was not correctly calculated. Column may contain decimal point values",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","14.35"
8688,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8689,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
6493,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",111,"10570.882320404053","0.7","0.9","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
8563,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/dev/stdin: line 2: export: `[section]=': not a valid identifier ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
7548,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2369.699716567993","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
8564,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
8565,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
8566,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"Variables were not set correctly. The file may also contain comments",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
6488,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",128,"11079.681873321533","0","0.1","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
7203,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl restart nginx",32,"1084.1476917266846","0.2","0.4","gpt-3.5-turbo","index.html patstāvīgs",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","5.550000000000001"
5603,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",25,"1552.9584884643555","0.7","0.9","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","7.2","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8549,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8572,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain comments",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
8569,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
8568,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
6508,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"2246.363878250122","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6407,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2247.920274734497","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6409,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",58,"1978.9774417877197","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.5100000000000002"
6435,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {printf *Mean: %.2f\n*, sum/count}' products.csv",38,"2246.554374694824","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
5661,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"2146.8234062194824","0.2","0.4","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
8567,"Experiment 1","LoadIniFile","NL2Bash",2,2,"false",130,"2908.8027477264404","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_gpt-4o_0.7_0.9_2.sh: line 9: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 7: The mentioned syntax error was in this while loop. Line 9: Couldn't parse this test expression. Fix to allow more checks. Line 9: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.700000000000003"
7629,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice.service -p ExecMainStatus --value | awk '{print ""exit code: "" $1}'",30,"6302.5219440460205","0.7","0.9","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7529,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1 | grep -oP 'status=\K\d+' | tail -n 1 | xargs -I {} echo ""exit code: {}""",49,"5026.4892578125","0.7","0.9","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","10.85"
7530,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1 | grep -oP 'status=\K\d+' | tail -n 1 | xargs -I {} echo ""exit code: {}""",49,"5026.4892578125","0.7","0.9","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","10.85"
6510,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1750.2200603485107","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6943,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
6511,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1750.2200603485107","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6512,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1750.2200603485107","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
5680,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env && echo ""$USERNAME""",1262,"21938.18426132202","0","0.1","deepseek-r1",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
8539,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"Variables were not set correctly. The file may also contain sections",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6520,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",39,"1146.3119983673096","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
8540,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,0,"","9.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8541,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,0,"","9.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7210,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",77,"1743.701696395874","0","0.1","gpt-4o","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
6404,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1545.0809001922607","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
8543,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8547,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8548,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7213,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",77,"1769.685983657837","0.7","0.9","gpt-4o","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
6412,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",58,"1978.9774417877197","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.5100000000000002"
8533,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8631,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
8632,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
8627,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
6416,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); gsub(/\./, """", $3); sub(/,/, ""."", $3); sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2059.1306686401367","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","5.09"
6414,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); gsub(/\./, """", $3); sub(/,/, ""."", $3); sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2059.1306686401367","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","5.09"
8641,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7219,"Experiment 1","VerifyFile","IaC",1,2,"# Fetch the key again gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Assuming you have the key in a file named key.asc gpg --import key.asc # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Try a different keyserver gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi",360,"8357.962608337402","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data gpg: can't open 'key.asc': No such file or directory gpg: Total number processed: 0 gpg: keyserver receive failed: No data ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","28.999999999999996"
7038,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",211,"3394.831418991089","0","0.1","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
7327,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1189.3136501312256","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7328,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1189.3136501312256","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7340,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",226,"2775.7558822631836","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7718,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: ""$4}' | awk '{print $2}'",42,"1241.2874698638916","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.77"
6399,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2347.381353378296","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
8342,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -mindepth 1 -perm -u+r -exec ls -l {} +",2321,"105315.66500663757","0.7","0.9","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
7226,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"2567.0931339263916","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
6448,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, 'NR>1 {sum+=$4; count++} END {print ""Mean: "" sum/count}' products.csv",37,"1940.981388092041","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
8609,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8610,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8611,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The file may also contain sections",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7224,"Experiment 1","VerifyFile","IaC",1,2,"# Fetch the key again gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Assuming you have the key in a file named key.asc gpg --import key.asc # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Try a different keyserver gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi",360,"7936.457872390747","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","28.999999999999996"
6452,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if(NR>1) sum+=$4; if(NR>1) count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",49,"2854.0730476379395","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
8612,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set. Variables may have empty values, those should also be set with an empty value",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8613,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[;#] ]] || [ -z ""$key"" ]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",165,"2453.500270843506","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0_0.1.sh: line 6: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 6: The mentioned syntax error was in this if expression. Line 6: Couldn't parse this test expression. Fix to allow more checks. Line 6: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7227,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 if gpg --list-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 > /dev/null 2>&1; then gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL* else echo *Key not found* fi",205,"5890.5956745147705","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data ",False,"The file was valid but OK was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","24.5"
6456,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='^|,[^,]*|""$[^""]*$""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",52,"1642.8415775299072","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.96"
8595,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8596,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5220,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -f .gitignore ]; then
 git init -q
 git clean -dfX
 rm -rf .git
else
 echo ""Error: No .gitignore file found in current directory"" >&2
 exit 1
fi",2067,"20073.819875717163","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
5265,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore {} >/dev/null 2>&1; then rm {}; fi' \;",36,"1159.7299575805664","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
4530,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -exec rm -f {} +",76,"1352.294921875","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
4531,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -exec rm -f {} +",76,"1352.294921875","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
6439,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, '$1~/^[0-9]+$/ {sum+=$2; count++} END {print ""Mean: "" sum/count}' products.csv",42,"2444.4854259490967","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
4559,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3361.6762161254883","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
8608,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
5424,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2335.8707427978516","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6420,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; }; NR>1 {; gsub(/,/, """", $col) # Remove commas for number formatting; sum += $col; count++; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",532,"4253.265857696533","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","8.45"
4569,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} \;",69,"3560.4944229125977","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
6418,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; }; NR>1 {; gsub(/,/, """", $col) # Remove commas for number formatting; sum += $col; count++; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",532,"4253.265857696533","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","8.45"
8584,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8386,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"949.9225616455078","0","0.1","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
6424,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; }; if (!col) {; print ""Mean: 0.00""; exit; }; }; NR>1 && col {; # Remove any commas and quotes; gsub(/["",]/, """", $col); # Replace comma decimal separators with dots if necessary; gsub(/,/, ""."", $col); if ($col ~ /^[0-9.]+$/) {; sum += $col; count++; }; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",1494,"11677.667140960693","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
5409,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort -u | tr '\n' ' ');;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",91,"3052.109956741333","0.2","0.4","deepseek-v3","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
7825,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","6.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5862,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f gcc *.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",1195,"13477.10919380188","0.2","0.4","deepseek-r1","nav neviena skripta",2,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","12.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5863,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f gcc *.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",1195,"13477.10919380188","0.2","0.4","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","12.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7826,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4.sh source destination [flag] ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7829,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"Error: Source directory does not exist ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7241,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --trust-model always --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",967,"60011.48819923401","0","0.1","deepseek-r1","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.9"
5866,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -f gcc ./*.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",615,"36493.422985076904","0.2","0.4","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8550,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8551,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7827,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4.sh source destination [flag] ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7828,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4.sh source destination [flag] ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5857,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",524,"31243.82448196411","0","0.1","deepseek-r1","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5859,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",524,"31243.82448196411","0","0.1","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7833,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4_2.sh source destination [single_flag] Valid flags: --sc, --sd, --dr, --dk, --dd, --sw ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
4973,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
7014,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Configure PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/12/main/postgresql.conf # Allow connections on the new port echo *host all  all  127.0.0.1/32  md5* >> /etc/postgresql/12/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",329,"7073.296308517456","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"e dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/12/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0.7_0.9.sh: line 14: /etc/postgresql/12/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
5892,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2045.0479984283447","0.2","0.4","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7834,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4_2.sh source destination [single_flag] Valid flags: --sc, --sd, --dr, --dk, --dd, --sw ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7835,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"Error: Source directory does not exist ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7831,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","6.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7250,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key if not already present
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 &>/dev/null

# Verify the signature and capture output
if gpg --verify data.tgz.asc data.tgz &>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",104,"10700.22177696228","0.2","0.4","deepseek-v3","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.25"
5898,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",87,"8874.232769012451","0.2","0.4","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5725,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo $USERNAME",14,"1648.5297679901123","0.7","0.9","deepseek-v3",".env datne are tikai USERNAME",1,"",False,"",0,2,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5726,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo $USERNAME",14,"1648.5297679901123","0.7","0.9","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,2,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: Double quote to prevent globbing and word splitting. ","6.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
7839,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7841,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"Error: Source and destination must be directories ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5908,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",90,"9074.62453842163","0.7","0.9","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
4953,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
7838,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7840,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
8414,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"head -n -5 data.md > temp.md && mv temp.md data.md",22,"872.4374771118164","0.7","0.9","gpt-4o","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
5881,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2545.571804046631","0","0.1","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7549,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1664.0357971191406","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
5884,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2545.571804046631","0","0.1","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7844,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7848,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5887,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",78,"8270.371675491333","0","0.1","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7846,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7152,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",55,"1165.3084754943848","0.2","0.4","gpt-3.5-turbo","Docker nav iedarbināts",3,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
5920,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

# Using find command to locate all bash scripts in the current directory
# Using xargs to execute shellcheck on each script and grep to count the lines containing ""warning""
warning_count=$(find . -type f -name ""*.sh"" -exec shellcheck {} \; | grep -c ""warning"")

echo ""Count warning: $warning_count""",80,"1442.976713180542","0.7","0.9","gpt-3.5-turbo","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5922,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

# Using find command to locate all bash scripts in the current directory
# Using xargs to execute shellcheck on each script and grep to count the lines containing ""warning""
warning_count=$(find . -type f -name ""*.sh"" -exec shellcheck {} \; | grep -c ""warning"")

echo ""Count warning: $warning_count""",80,"1442.976713180542","0.7","0.9","gpt-3.5-turbo","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7516,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -n 1 | awk '{print ""exit code: "" $1}'",58,"1809.6601963043213","0","0.1","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.18"
7573,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitCode myservice | sed 's/exit_code=//g' | xargs -I {} echo ""exit code: {}""",38,"1762.5432014465332","0.2","0.4","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
7818,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
6097,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find the archive file with the name pattern archive.*
file=$(ls archive.* 2>/dev/null | head -n 1)

if [ -z ""$file"" ]; then
 echo ""No archive file named archive.* found in the current directory.""
 exit 1
fi

case ""$file"" in
 *.tar.gz|*.tgz)
 tar -xzf ""$file""
 ;;
 *.tar.bz2|*.tbz2)
 tar -xjf ""$file""
 ;;
 *.tar.xz|*.txz)
 tar -xJf ""$file""
 ;;
 *.zip)
 unzip ""$file""
 ;;
 *.7z)
 7z x ""$file""
 ;;
 *.gz)
 gunzip ""$file""
 ;;
 *.bz2)
 bunzip2 ""$file""
 ;;
 *.xz)
 unxz ""$file""
 ;;
 *)
 echo ""Unsupported archive format: $file""
 exit 1
 ;;
esac",1003,"5970.0939655303955","1","1","o1-mini","arhīvs ir .tar.gz",1,"",False,"",0,1,0,0,"Line 4: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
5928,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash

# Using a for loop to iterate over each bash script in the current directory
# Using shellcheck to check for warnings and counting the output lines containing ""warning""
warning_count=0
for script in *.sh; do
 ((warning_count += $(shellcheck ""$script"" | grep -c ""warning"")))
done

echo ""Count warning: $warning_count""",84,"2249.9794960021973","0.7","0.9","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.65"
5929,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash

# Using a for loop to iterate over each bash script in the current directory
# Using shellcheck to check for warnings and counting the output lines containing ""warning""
warning_count=0
for script in *.sh; do
 ((warning_count += $(shellcheck ""$script"" | grep -c ""warning"")))
done

echo ""Count warning: $warning_count""",84,"2249.9794960021973","0.7","0.9","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.65"
7814,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"rsync: --sc/: unknown option rsync error: syntax or usage error (code 1) at main.c(1795) [client=3.2.7] ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5454,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in ./*.sh; do
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",444,"3579.9190998077393","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
7263,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash

# Import the public key from keyserver.ubuntu.com
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature of the file
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",101,"1591.5627479553223","0.7","0.9","gpt-3.5-turbo","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
5912,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1239.863634109497","0","0.1","gpt-3.5-turbo","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5913,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1239.863634109497","0","0.1","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5914,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1239.863634109497","0","0.1","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
6651,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",403,"18203.05299758911","0.2","0.4","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.549999999999999"
6652,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",403,"18203.05299758911","0.2","0.4","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.549999999999999"
6645,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | cut -d' ' -f1 | sort -u | wc -l",1300,"16519.474029541016","0","0.1","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.4"
6646,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | cut -d' ' -f1 | sort -u | wc -l",1300,"16519.474029541016","0","0.1","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.4"
6647,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"last -a | awk '/still logged in/ {print $1}' | sort -u | wc -l",464,"116746.25015258789","0","0.1","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",False,"The number of logged in users was not correctly counted.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Count number of users logged in","10.959999999999999"
6637,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1465.5787944793701","0.2","0.4","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6638,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1465.5787944793701","0.2","0.4","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
5779,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",48,"1456.9919109344482","0.2","0.4","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7813,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7816,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"rsync: --sc/: unknown option rsync error: syntax or usage error (code 1) at main.c(1795) [client=3.2.7] ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
6641,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1357.8014373779297","0.7","0.9","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6642,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1357.8014373779297","0.7","0.9","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6643,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1345.1287746429443","0.7","0.9","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
5926,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash

# Using a for loop to iterate over each bash script in the current directory
# Using shellcheck to check for warnings and counting the output lines containing ""warning""
warning_count=0
for script in *.sh; do
 ((warning_count += $(shellcheck ""$script"" | grep -c ""warning"")))
done

echo ""Count warning: $warning_count""",84,"2249.9794960021973","0.7","0.9","gpt-3.5-turbo","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.65"
5766,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length');echo ""Count warning: $count""",56,"1992.6517009735107","0","0.1","gpt-4o","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5767,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length');echo ""Count warning: $count""",56,"1992.6517009735107","0","0.1","gpt-4o","nav neviena skripta",2,"",False,"The script should have outputted *Count warning: 0* since there were no scripts to check.",0,0,0,0,"","9.8","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5685,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"eval ""$(grep -E -- '^USERNAME=' .env)"" && echo ""$USERNAME""",1366,"292757.8113079071","0","0.1","deepseek-r1",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","9.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
7815,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"rsync: --sd/: unknown option rsync error: syntax or usage error (code 1) at main.c(1795) [client=3.2.7] ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5773,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length // 0');echo ""Count warning: $count""",59,"1450.573444366455","0","0.1","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5774,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length // 0');echo ""Count warning: $count""",59,"1450.573444366455","0","0.1","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7817,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

handle_sw() {
 if [[ "" ${flags[@]} "" =~ "" --sw "" ]]; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if [[ "" ${flags[@]} "" =~ "" --dd "" ]]; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=""-a""
 if [[ "" ${flags[@]} "" =~ "" --dk "" ]]; then
 rsync_opts+="" --ignore-existing""
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if [[ "" ${flags[@]} "" =~ "" --sd "" ]]; then
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync $rsync_opts --progress ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",11180,"489493.92318725586","0","0.1","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"rsync: --sw/: unknown option rsync error: syntax or usage error (code 1) at main.c(1795) [client=3.2.7] ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,1,0,1,"Line 21: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 28: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 35: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 43: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). Line 44: Double quote to prevent globbing and word splitting. Line 47: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
6659,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w;users | tr ' ' '\n' | sort -u | wc -l",153,"9774.332523345947","0","0.1","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","12.05"
6660,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w;users | tr ' ' '\n' | sort -u | wc -l",153,"9774.332523345947","0","0.1","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","12.05"
6669,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"758.8369846343994","0.2","0.4","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6909,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"Unknown option: /usr/destination ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
5830,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -c ""warning:"")
echo ""Count warning: $count""",26,"4054.0614128112793","0.2","0.4","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5626,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1345.876932144165","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5939,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"946.0976123809814","0.2","0.4","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5943,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1145.0212001800537","0.2","0.4","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7822,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"rsync: [sender] change_dir */--sc* failed: No such file or directory (2) rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1338) [sender=3.2.7] ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5838,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1448.106050491333","0.2","0.4","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7823,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"rsync: [sender] change_dir */--sw* failed: No such file or directory (2) rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1338) [sender=3.2.7] ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
7819,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
8398,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",515,"27050.606727600098","0","0.1","deepseek-r1","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7046,"Experiment 1","SetupPostgres","IaC",2,2,"# To prevent the psql commands from prompting for input, you can use the -c flag with echo to pass the commands directly to psql non-interactively.;;# Install PostgreSQL;apt update;apt install postgresql;;# Start PostgreSQL service;systemctl start postgresql;;# Switch to postgres user;su - postgres;;# Create a new database;createdb -p 5433 storedb;;# Run init.sql on the database;psql -p 5433 -d storedb -f init.sql;;# Create a read-only user with access to ""common_data"" schema;echo ""CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';"" | psql -p 5433 -d storedb;echo ""GRANT USAGE ON SCHEMA common_data TO public_view;"" | psql -p 5433 -d storedb;echo ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"" | psql -p 5433 -d storedb",210,"2722.3947048187256","0.7","0.9","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","26.15"
7740,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;exec_pid=$(pgrep -f 'exec\.sh');;if [ -z ""$exec_pid"" ]; then; echo ""Error: exec.sh is not running."" >&2; exit 1;fi;;# Get descendant PIDs excluding the parent itself;descendants=$(pstree -p ""$exec_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+' | grep -v ""^${exec_pid}$"");;script_names=();for pid in $descendants; do; if [ -r ""/proc/$pid/cmdline"" ]; then; mapfile -d $'\0' args < ""/proc/$pid/cmdline""; for arg in ""${args[@]}""; do; if [[ ""$arg"" == *.sh ]]; then; script_names+=(""$(basename ""$arg"")""); fi; done; fi;done;;printf ""%s\n"" ""${script_names[@]}"" | sort -u",857,"44449.59044456482","0","0.1","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
5842,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -n {} \; | grep -c ""warning:"")
echo ""Count warning: $count""",46,"3558.030843734741","0.7","0.9","llama3.3-70b","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6899,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7574,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitCode myservice | sed 's/exit_code=//g' | xargs -I {} echo ""exit code: {}""",38,"1762.5432014465332","0.2","0.4","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
7289,"Experiment 1","Factorial","NL2Bash",2,1,"factorial=1
for (( i=1; i<=623; i++ )); do
 factorial=$((factorial * i))
done
echo $factorial",40,"1463.209867477417","0.2","0.4","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
5843,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -n {} \; | grep -c ""warning:"")
echo ""Count warning: $count""",46,"3558.030843734741","0.7","0.9","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"  Specify dialect (sh, bash, dash, ksh)  -S SEVERITY  --severity=SEVERITY Minimum severity of errors to consider (error, warning, info, style)  -V   --version   Print version information  -W NUM   --wiki-link-count=NUM  The number of wiki links to show, when applicable  -x   --external-sources  Allow 'source' outside of FILES    --help   Show this usage summary and exit ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8752,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"shuf -r -e 0 1 -n 75 | tr -d '\n'",664,"33181.27965927124","0","0.1","deepseek-r1","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6"
8758,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '01' < /dev/urandom | head -c 75; echo",26,"952.0537853240967","0.7","0.9","gpt-4o","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8756,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '01' < /dev/urandom | head -c 75; echo",26,"1054.2304515838623","0","0.1","gpt-4o","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8766,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '10' < /dev/urandom | fold -w 75 | head -n 1",30,"1263.7271881103516","0","0.1","llama3.3-70b","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
8399,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",689,"35263.19742202759","0.2","0.4","deepseek-r1","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8417,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i -e :a -e '$d;N;2,5ba' -e 'P;D' data.md",33,"1452.439546585083","0","0.1","qwen/qwen2.5-coder-32b-instruct","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","1.7"
6904,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7748,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;pid=$(pgrep -o exec.sh);[[ -z ""$pid"" ]] && { echo ""exec.sh not found"" >&2; exit 1; };;child_pids=$(pstree -p ""$pid"" | grep -o '([0-9]\+)' | tr -d '()');;declare -A scripts=();;for pid in $child_pids; do; [[ -e ""/proc/$pid/cmdline"" ]] || continue; while IFS= read -r -d '' arg; do; if [[ ""$arg"" == *.sh ]]; then; scripts[""$arg""]=1; fi; done < ""/proc/$pid/cmdline"";done;;printf ""%s\n"" ""${!scripts[@]}""",672,"36897.68600463867","0.7","0.9","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
5848,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -n *.sh 2>/dev/null | grep -c ""warning:"")
echo ""Count warning: $count""",33,"1847.5515842437744","0.7","0.9","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6901,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6903,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;if [ $# -lt 2 ]; then; echo ""Usage: $0 [options] source destination""; echo ""Options:""; echo "" --sc : copy from source (default)""; echo "" --sd : delete from source (move)""; echo "" --dr : replace same name in destination (default)""; echo "" --dk : keep same name in destination""; echo "" --dd : delete all existing in destination first""; echo "" --sw : swap contents of directories""; exit 1;fi;;# Initialize flags with default values;action=""cp"" # Default: copy (--sc);dest_behavior=""replace"" # Default: replace (--dr);delete_dest=false;swap=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); action=""cp""; shift;;; --sd); action=""mv""; shift;;; --dr); dest_behavior=""replace""; shift;;; --dk); dest_behavior=""keep""; shift;;; --dd); delete_dest=true; shift;;; --sw); swap=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Validate arguments;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap case;if [ ""$swap"" = true ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $destination""; mv ""$source""/* ""$temp_dir/""; mv ""$destination""/* ""$source/""; mv ""$temp_dir""/* ""$destination/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle delete destination case;if [ ""$delete_dest"" = true ]; then; echo ""Deleting all contents in destination directory $destination""; rm -rf ""${destination:?}/""* # :? prevents accidental deletion if variable is empty;fi;;# Perform the operation;echo ""Processing files from $source to $destination"";for item in ""$source""/*; do; item_name=$(basename ""$item""); dest_path=""$destination/$item_name""; if [ ""$dest_behavior"" = ""keep"" ] && [ -e ""$dest_path"" ]; then; echo ""Skipping $item_name (exists in destination)""; continue; fi; if [ ""$action"" = ""cp"" ]; then; echo ""Copying $item_name""; cp -r ""$item"" ""$destination/""; else; echo ""Moving $item_name""; mv ""$item"" ""$destination/""; fi;done;;echo ""Operation completed""",750,"37169.503927230835","0.2","0.4","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 59: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
5823,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -i ""warning:"" | wc -l)
echo ""Count warning: $count""",31,"2545.4046726226807","0","0.1","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",1,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","6.5","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5824,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -i ""warning:"" | wc -l)
echo ""Count warning: $count""",31,"2545.4046726226807","0","0.1","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",1,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6256,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep *result.log$* | wc -l",25,"1444.169282913208","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6257,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep *result.log$* | wc -l",25,"1444.169282913208","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6905,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6906,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"Unknown option: /usr/source ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7765,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I {} basename $(readlink -f /proc/{}/exe)",119,"3258.105993270874","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"ormation. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. ",False,"All child processes weren't listed",0,1,1,0,"Line 13: Double quote to prevent globbing and word splitting. Line 13: Quote this to prevent word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8893,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo *result = $(echo *$line* | rev)* done < *info.txt*",34,"1650.8007049560547","0","0.1","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8328,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 + $(( (8 - $(date -d ""2013-05-01"" +%u)) % 7 )) days"" +%Y-%m-%d",50,"6487.62059211731","0","0.1","deepseek-v3","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
7766,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I {} basename $(readlink -f /proc/{}/exe)",119,"3258.105993270874","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"ormation. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. ",False,"All child processes weren't listed",0,1,1,0,"Line 13: Double quote to prevent globbing and word splitting. Line 13: Quote this to prevent word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7526,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"status=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: $status""",29,"1457.7124118804932","0.7","0.9","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
5828,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1853.0542850494385","0","0.1","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6907,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"Unknown option: /usr/source ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7771,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | while read -r PID; do  if [ -e */proc/$PID/exe* ]; then basename *$(readlink -f */proc/$PID/exe*)*  fi done",146,"4274.969577789307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7767,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | while read -r PID; do  if [ -f */proc/$PID/exe* ]; then basename *$(readlink -f */proc/$PID/exe*)*  fi done",146,"3574.3801593780518","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
5789,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;count=$(shellcheck ./*.sh --format=json | jq '[.[] | select(.level==""warning"")] | length');echo ""Count warning: $count""",822,"7171.492338180542","1","1","o1-mini","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5710,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f2-);echo ""$USERNAME""",147,"11077.015399932861","0","0.1","deepseek-v3",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6908,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"Unknown option: /usr/source ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6910,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 source destination [--sc|--sd] [--dr|--dk|--dd] [--sw]""
 exit 1
fi

# Initialize variables
source_dir=""${1:?Source directory not specified}""
dest_dir=""${2:?Destination directory not specified}""
operation=""--sc"" # default operation
conflict_resolution=""--dr"" # default conflict resolution
swap_flag=0

# Process flags
for arg in ""${@:3}""; do
 case ""$arg"" in
 --sc|--sd)
 operation=""$arg""
 ;;
 --dr|--dk|--dd)
 conflict_resolution=""$arg""
 ;;
 --sw)
 swap_flag=1
 ;;
 *)
 echo ""Unknown option: $arg"" >&2
 exit 1
 ;;
 esac
done

# Validate directories
if [ ! -d ""$source_dir"" ]; then
 echo ""Source directory does not exist: $source_dir"" >&2
 exit 1
fi

if [ ! -d ""$dest_dir"" ]; then
 echo ""Destination directory does not exist: $dest_dir"" >&2
 exit 1
fi

# Handle swap operation
if [ $swap_flag -eq 1 ]; then
 temp_dir=$(mktemp -d) || exit 1
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" || exit 1
 mv -- ""$dest_dir""/* ""$source_dir/"" || exit 1
 mv -- ""$temp_dir""/* ""$dest_dir/"" || exit 1
 rmdir -- ""$temp_dir"" || exit 1
 exit 0
fi

# Handle destination preparation
case ""$conflict_resolution"" in
 --dd)
 rm -rf -- ""${dest_dir:?}""/* || exit 1
 ;;
esac

# Perform the main operation
shopt -s dotglob
case ""$operation"" in
 --sc)
 # Copy from source
 case ""$conflict_resolution"" in
 --dr)
 cp -rf -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  cp -rf -- ""$item"" ""${dest_dir:?}/"" || exit 1
  fi
 done
 ;;
 esac
 ;;
 --sd)
 # Move from source (delete from source)
 case ""$conflict_resolution"" in
 --dr)
 mv -f -- ""${source_dir:?}""/* ""${dest_dir:?}/"" || exit 1
 ;;
 --dk)
 for item in ""${source_dir:?}""/*; do
  dest_item=""${dest_dir:?}/$(basename -- ""$item"")""
  if [ ! -e ""$dest_item"" ]; then
  mv -f -- ""$item"" ""${dest_dir:?}/"" || exit 1
  else
  rm -rf -- ""$item"" || exit 1
  fi
 done
 ;;
 esac
 ;;
esac",955,"44013.05842399597","0.2","0.4","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7772,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | while read -r PID; do  if [ -e */proc/$PID/exe* ]; then basename *$(readlink -f */proc/$PID/exe*)*  fi done",146,"4274.969577789307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
6258,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rlZ *FAIL* /usr/results/ | grep -z *result.log$* | tr '\0' '\n' | grep -c *result.log$*",40,"1746.7904090881348","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
8329,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +$(( (8 - $(date -d ""2013-05-01"" +%u)) % 7 )) days"" +%Y-%m-%d",50,"6788.387298583984","0.2","0.4","deepseek-v3","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
8084,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""^$(date +""%b %e"")"" /var/log/auth.log \;| grep -E 'Failed password|authentication failure' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",6324,"284991.055727005","0.2","0.4","deepseek-r1","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.13"
8085,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""^$(date +""%b %e"")"" /var/log/auth.log \;| grep -E 'Failed password|authentication failure' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",6324,"284991.055727005","0.2","0.4","deepseek-r1","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.13"
7789,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child PIDs recursively;child_pids=$(pstree -p ""$parent_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Find all script processes among children;for pid in $parent_pid $child_pids; do; # Get the command line and check if it's a script; cmdline=$(cat ""/proc/$pid/cmdline"" | tr '\0' ' '); if [[ ""$cmdline"" =~ \.sh(\ |$) ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name""; fi;done | sort -u",334,"18600.563526153564","0","0.1","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",1,0,0,0,"Line 17: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7788,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{for(i=2; i<=NF; i++) {print $i}}'",44,"6486.410617828369","0.7","0.9","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.91"
7778,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[\(\)]//g'",42,"2354.665994644165","0","0.1","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
6912,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
7577,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitCode | awk -F '=' '{print ""exit code: "" $2}'",29,"2237.844944000244","0.2","0.4","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
7784,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[^a-zA-Z0-9_./-]*//g'",50,"1254.1680335998535","0.2","0.4","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
7786,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}'",31,"1553.8361072540283","0.7","0.9","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.45"
8086,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today --no-pager \;| grep -E 'Failed password|authentication failure|FAILED LOGIN' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }; /FAILED LOGIN/ {; for (i=1; i<=NF; i++) {; if ($i == ""FOR"") {; username = $(i+1);; gsub(/\x27|,/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3191,"151630.03635406494","0.2","0.4","deepseek-r1","Autorizācijas ar tty",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.18"
8400,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",689,"35263.19742202759","0.2","0.4","deepseek-r1","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8092,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today | grep -aEi 'authentication failure|Failed password|authentication error|FAILED SU' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+|sudo:.*?\K\buser\b=([^ ]+)|sudo:\s*\K\S+(?=.*auth)|FAILED SU.*?\K\S+$)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2411,"117325.65879821777","0.7","0.9","deepseek-r1","Autorizācijas ar tty",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.180000000000001"
5934,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1246.17600440979","0","0.1","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6913,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
6914,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
6915,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
5951,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"854.9337387084961","0.7","0.9","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8079,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"current_date=$(date +""%b %e"");zgrep -hE ""$current_date.*(Failed password|authentication failure)"" /var/log/auth.log* | {; while read -r line; do; if [[ ""$line"" == *""Failed password""* ]]; then; echo ""$line"" | sed -nE 's/.*Failed password for (invalid user )?([^ ]+).*/\2/p'; else; echo ""$line"" | grep -o 'user=[^ ]*' | cut -d= -f2; fi; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2570,"118893.9700126648","0","0.1","deepseek-r1","Autorizācijas ar ssh",2,"gzip: /var/log/auth.log*.gz: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.73"
6916,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
5931,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"988.5451793670654","0","0.1","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6911,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if source and destination directories are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default: copy from source;dest_behavior=""dr"" # Default: replace same name in destination;swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=""sc""; shift;;; --sd); copy_mode=""sd""; shift;;; --dr); dest_behavior=""dr""; shift;;; --dk); dest_behavior=""dk""; shift;;; --dd); dest_behavior=""dd""; shift;;; --sw); swap_flag=1; shift;;; *); # Assume remaining arguments are source and destination; if [ -z ""$source"" ]; then; source=""$1""; else; destination=""$1""; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$destination"" ]; then; echo ""Error: Both source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory '$source' does not exist""; exit 1;fi;;if [ ! -d ""$destination"" ]; then; echo ""Error: Destination directory '$destination' does not exist""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); mv ""$source""/* ""$temp_dir/"" 2>/dev/null; mv ""$destination""/* ""$source/"" 2>/dev/null; mv ""$temp_dir""/* ""$destination/"" 2>/dev/null; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior;case ""$dest_behavior"" in; ""dd""); # Delete all existing in destination; rm -rf ""$destination""/*;;;esac;;# Handle copy/move operation;case ""$copy_mode"" in; ""sc""); # Copy from source; case ""$dest_behavior"" in; ""dr""); cp -rf ""$source""/* ""$destination/"";;; ""dk""); # Copy only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  cp -rf ""$file"" ""$destination/"";  fi; done;;; esac;;; ""sd""); # Move (delete from source); case ""$dest_behavior"" in; ""dr""); mv -f ""$source""/* ""$destination/"" 2>/dev/null;;; ""dk""); # Move only if file doesn't exist in destination; for file in ""$source""/*; do;  dest_file=""$destination/$(basename ""$file"")"";  if [ ! -e ""$dest_file"" ]; then;  mv -f ""$file"" ""$destination/"" 2>/dev/null;  else;  rm -rf ""$file"";  fi; done;;; esac;;;esac",966,"47306.81848526001","0.7","0.9","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 92: Use *${var:?}* to ensure this never expands to /* . ","11.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","169.20000000000002"
8082,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"current_date=$(date +""%b %_d"");zgrep -hE -i ""$current_date.*(failed password|authentication failure|failed login|authentication error|user unknown|invalid user)"" /var/log/auth.log* 2>/dev/null | {; while read -r line; do; user=$(echo ""$line"" | sed -nE \; -e 's/.*[Ff]ailed [Pp]assword (for|during) (invalid user )?([^ ]+).*/\3/p' \; -e 's/.*[Aa]uthentication failure.* (user|ruser)=([^ ]+).*/\2/p' \; -e 's/.*FAILED LOGIN .* FOR (\x27)?([^ ]+).*/\2/p' \; -e 's/.*Invalid user ([^ ]+) from.*/\1/p' \; -e 's/.* user ([^ ]+) .*authentication failure.*/\1/p' \; -e 's/.*[Ee]rror: ([^ ]+) authentication failure.*/\1/p'); [ -n ""$user"" ] && echo ""$user""; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",5415,"253107.13052749634","0","0.1","deepseek-r1","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6919,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6920,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8915,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",37,"1048.9766597747803","0.7","0.9","gpt-3.5-turbo","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8910,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",38,"1151.1263847351074","0","0.1","gpt-3.5-turbo","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8902,"Experiment 1","PrintBackwards","NL2Bash",2,1,"rev info.txt | while read -r line; do echo ""result = $line""; done",25,"2253.1967163085938","0.7","0.9","llama3.3-70b","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","11.7"
8903,"Experiment 1","PrintBackwards","NL2Bash",2,1,"rev info.txt | while read -r line; do echo ""result = $line""; done",25,"2253.1967163085938","0.7","0.9","llama3.3-70b","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","11.7"
4817,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6921,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8165,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check all auth logs including rotated ones;log_files=(/var/log/auth.log /var/log/auth.log.[0-9] /var/log/auth.log.[0-9].gz);;# Patterns for different types of failed authentication;patterns=(; ""Failed password""; ""authentication failure""; ""FAILED LOGIN""; ""invalid user""; ""user unknown"";);;# Get today's date in log format (e.g., ""Jan 1"");today=$(date '+%b %e');;# Temporary file for storing results;temp_file=$(mktemp);;for log in ""${log_files[@]}""; do; if [ -f ""$log"" ]; then; if [[ ""$log"" == *.gz ]]; then; zgrep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; else; grep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; fi; fi;done;;# Extract usernames from logs and count;count=$(awk '{; if (/invalid user|user unknown/) {; for(i=1; i<=NF; i++) if ($i == ""user"") {print $(i+1); break}; } else if (/authentication failure/) {; for(i=1; i<=NF; i++) if ($i == ""user="") {print $(i+1); break}; } else {; for(i=1; i<=NF; i++) if ($i == ""for"") {print $(i+1); break}; };}' ""$temp_file"" | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count"";rm ""$temp_file""",540,"27681.88762664795","0.2","0.4","deepseek-v3","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6922,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6917,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7797,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child processes recursively;child_pids=$(pstree -p ""$parent_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Check each process for script execution;echo ""Child scripts launched by exec.sh or its children:"";for pid in $parent_pid $child_pids; do; # Get the command line and check if it's a script; cmdline=$(cat /proc/""$pid""/cmdline | tr '\0' ' '); if [[ ""$cmdline"" =~ \.sh$ ]] || [[ ""$cmdline"" =~ ^/bin/bash ]] || [[ ""$cmdline"" =~ ^/bin/sh ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name (PID: $pid)""; fi;done | sort -u",377,"22214.258909225464","0.7","0.9","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",1,0,0,0,"Line 18: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7578,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitCode | awk -F '=' '{print ""exit code: "" $2}'",29,"2237.844944000244","0.2","0.4","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
8397,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",515,"27050.606727600098","0","0.1","deepseek-r1","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8167,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -E ""user=|user "" | \; sed -E 's/.*(user=|user )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",242,"14895.362615585327","0.7","0.9","deepseek-v3","Autorizācijas ar tty",1,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8635,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6888,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
7800,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child processes recursively using ps;child_pids=$(ps --ppid ""$parent_pid"" -o pid=);all_pids=""$parent_pid $child_pids"";;# Expand to include grandchildren;for pid in $child_pids; do; all_pids=""$all_pids $(ps --ppid ""$pid"" -o pid=)"";done;;# Check each process for script execution;echo ""Child scripts launched by exec.sh or its children:"";for pid in $all_pids; do; # Get the command line without using cat; if [[ -f ""/proc/$pid/cmdline"" ]]; then; cmdline=$(tr '\0' ' ' < ""/proc/$pid/cmdline""); # Match script files or bash/sh executions with script arguments; if [[ ""$cmdline"" =~ \.sh(\ |$) ]] || ;  [[ ""$cmdline"" =~ ^(/bin/bash|/bin/sh)\ .*\.sh ]] || ;  [[ ""$cmdline"" =~ ^(/bin/bash|/bin/sh)\ .*-c\ .*\.sh ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $NF}')""); echo ""$script_name (PID: $pid)""; fi; fi;done | sort -u",458,"24047.45626449585","0.7","0.9","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
4560,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3361.6762161254883","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
8171,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Find all auth log files (including rotated ones);log_files=();possible_locations=(; ""/var/log/auth.log""; ""/var/log/auth.log.1""; ""/var/log/auth.log.*.gz""; ""/var/log/secure""; ""/var/log/secure.*"";);;for loc in ""${possible_locations[@]}""; do; for file in $loc; do; if [ -f ""$file"" ] || [[ ""$file"" == *.gz ]]; then; log_files+=(""$file""); fi; done;done;;if [ ${#log_files[@]} -eq 0 ]; then; echo ""Users: 0 (no auth logs found)""; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(zgrep -h ""$(date '+%b %e')"" ""${log_files[@]}"" 2>/dev/null | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -E ""user=|user |for |login failed"" | \; sed -E 's/.*(user=|user |for )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",419,"20934.237241744995","0.7","0.9","deepseek-v3","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6889,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A file was deleted from destination but not replaced with same name file in source (with --sd --dd passed)",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
8157,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -i ""password\|authentication"" | \; awk '{print $9, $10, $11}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",240,"14896.313667297363","0","0.1","deepseek-v3","Autorizācijas ar ssh",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6890,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
6891,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
5469,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"3794.7933673858643","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"Script names with spaces are not supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
7811,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process id of the exec.sh script;exec_pid=$(pgrep -f ""exec.sh"");;# List all child processes of the exec.sh script;pids=$(pgrep -P ""$exec_pid"");;# Loop through each child process and find the script name;while IFS= read -r pid; do; cmd=$(ps -p ""$pid"" -o cmd --no-headers); script_name=$(echo ""$cmd"" | awk '{print $1}'); echo ""$script_name"";done <<< ""$pids""",120,"1754.8131942749023","0.7","0.9","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8637,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6892,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
7580,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitCode | awk -F '=' '{print ""exit code: "" $2}'",29,"2237.844944000244","0.2","0.4","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
7812,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process id of the exec.sh script;exec_pid=$(pgrep -f ""exec.sh"");;# List all child processes of the exec.sh script;pids=$(pgrep -P ""$exec_pid"");;# Loop through each child process and find the script name;while IFS= read -r pid; do; cmd=$(ps -p ""$pid"" -o cmd --no-headers); script_name=$(echo ""$cmd"" | awk '{print $1}'); echo ""$script_name"";done <<< ""$pids""",120,"1754.8131942749023","0.7","0.9","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8158,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check for auth log files (Debian typically uses auth.log or secure);LOG_FILES=();[ -f /var/log/auth.log ] && LOG_FILES+=(/var/log/auth.log);[ -f /var/log/secure ] && LOG_FILES+=(/var/log/secure);[ -f /var/log/syslog ] && LOG_FILES+=(/var/log/syslog);;if [ ${#LOG_FILES[@]} -eq 0 ]; then; echo ""Error: No authentication log files found"" >&2; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(grep -h ""$(date '+%b %e')"" ""${LOG_FILES[@]}"" | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -iE ""password|authentication|login|sshd"" | \; awk 'match($0, /user(name)?=([^ ]+)/, a) {print a[2]} ;  match($0, /for( invalid user)? ([^ ]+)/, a) {print a[2]} ;  /FAILED/ {for(i=1;i<=NF;i++) if ($i==""for"") print $(i+1)}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",448,"23656.993865966797","0","0.1","deepseek-v3","Autorizācijas ar tty",1,"Error: No authentication log files found ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
4629,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",326,"4766.117334365845","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
7787,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{for(i=2; i<=NF; i++) {print $i}}'",44,"6486.410617828369","0.7","0.9","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.91"
8182,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",52,"1175.840139389038","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8183,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",52,"1175.840139389038","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
6887,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags;copy_mode=""sc"" # Default is copy (sc);dest_behavior=""dr"" # Default is replace (dr);swap_flag=0;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc|--sd); copy_mode=""${1#--}""; shift;;; --dr|--dk|--dd); dest_behavior=""${1#--}""; shift;;; --sw); swap_flag=1; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""$1""; elif [ -z ""$dest"" ]; then; dest=""$1""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Validate source and destination;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ $swap_flag -eq 1 ]; then; temp_dir=$(mktemp -d); echo ""Swapping contents between $source and $dest""; mv ""$source""/* ""$temp_dir/""; mv ""$dest""/* ""$source/""; mv ""$temp_dir""/* ""$dest/""; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination behavior first;case ""$dest_behavior"" in; dd); echo ""Deleting all contents in destination before operation""; rm -rf ""$dest""/*;;;esac;;# Handle the copy/delete operation;case ""$copy_mode"" in; sc); echo ""Copying contents from $source to $dest""; case ""$dest_behavior"" in; dr); cp -rf ""$source""/* ""$dest/"";;; dk); # Copy only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  cp -rf ""$item"" ""$dest/"";  fi; done;;; esac;;; sd); echo ""Moving contents from $source to $dest""; case ""$dest_behavior"" in; dr); mv -f ""$source""/* ""$dest/"";;; dk); # Move only if file doesn't exist in destination; for item in ""$source""/*; do;  dest_item=""$dest/$(basename ""$item"")"";  if [ ! -e ""$dest_item"" ]; then;  mv -f ""$item"" ""$dest/"";  fi; done;;; esac;;;esac;;echo ""Operation completed""",958,"46600.99673271179","0","0.1","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,2,0,"Line 60: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 61: Assigning an array to a string! Assign as array, or use * instead of @ to concatenate. Line 86: Use *${var:?}* to ensure this never expands to /* . Line 104: Use *${var:?}* to ensure this never expands to /* . Line 112: Use *${var:?}* to ensure this never expands to / . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","184.65"
8186,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep 'authentication failure' /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1149.799108505249","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
6893,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","10.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6895,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",True,"",0,0,0,0,"","10.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6897,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",True,"",0,0,0,0,"","10.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8772,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"tr -dc '01' < /dev/urandom | head -c 75; echo",87,"9183.810472488403","0.2","0.4","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8774,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"tr -dc '01' < /dev/urandom | head -c 75; echo",81,"7976.5942096710205","0.7","0.9","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8190,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep 'Failed password' /var/log/auth.log* | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",55,"1967.5228595733643","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.99"
8638,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6898,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,0,0,"","10.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8175,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",62,"2249.5899200439453","0","0.1","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
7847,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"Error: Source and destination must be directories ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
6935,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
8102,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/' /var/log/auth.log | \;awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",61,"1853.7108898162842","0.2","0.4","gpt-4o","Autorizācijas ar su un sudo",2,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.870000000000001"
7857,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8387,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",41,"1279.0284156799316","0","0.1","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.25"
6938,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
7149,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Since the directory already exists, we can skip creating it and try running the container again
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",48,"1606.7397594451904","0","0.1","gpt-3.5-turbo","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7582,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitStatus myservice | sed 's/ExitStatus=//g' | xargs -I {} echo ""exit code: {}""",38,"1760.8323097229004","0.7","0.9","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
7583,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitStatus myservice | sed 's/ExitStatus=//g' | xargs -I {} echo ""exit code: {}""",38,"1760.8323097229004","0.7","0.9","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
7586,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitStatus | awk -F '=' '{print ""exit code: "" $2}'",29,"3067.7237510681152","0.7","0.9","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
8108,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/auth.log | grep ""Failed password"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",67,"1760.4641914367676","0.7","0.9","gpt-4o","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
7867,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7868,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6939,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
8111,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/{auth.log,secure} 2>/dev/null | grep -E ""Failed password|FAILED LOGIN"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",81,"2879.3625831604004","0.7","0.9","gpt-4o","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
7873,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7874,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7588,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitStatus | awk -F '=' '{print ""exit code: "" $2}'",29,"3067.7237510681152","0.7","0.9","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
6260,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep -c *result.log*",22,"1244.6153163909912","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
8097,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/ {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",57,"1856.4846515655518","0","0.1","gpt-4o","Autorizācijas ar ssh",2,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.540000000000001"
7567,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"false",30,"1756.3908100128174","0","0.1","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
5415,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep VulnerabilityID | awk '{print $2}' | xargs -n1 | awk '{printf ""%s "", $0}' | { IFS= read -r codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",86,"2147.3283767700195","0","0.1","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.559999999999999"
6936,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
9402,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh -C root@""$1"" ""MYSQL_PWD=TEST mysqldump -u TEST_USER --no-tablespaces TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB -q",729,"38475.831508636475","0.2","0.4","deepseek-r1","jāpārnes datubāze",1,"",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
8099,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep -E ""authentication failure|Failed password|login"" | awk '{for(i=1;i<=NF;i++) if($i ~ /user=/) {split($i,a,""=""); print a[2]}}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",92,"3073.8134384155273","0","0.1","gpt-4o","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.39"
7108,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest",29,"949.2454528808594","0.7","0.9","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
4659,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",103,"4968.51921081543","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
8100,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep -E ""authentication failure|Failed password|login"" | awk '{for(i=1;i<=NF;i++) if($i ~ /user=/) {split($i,a,""=""); print a[2]}}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",92,"3073.8134384155273","0","0.1","gpt-4o","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.39"
6941,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
8145,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $1}' | sort | uniq -d | awk 'NR>2 {a[$1]++} END {for (i in a) if (a[i]>=3) b++; print b}')""",77,"1950.272560119629","0.2","0.4","llama3.3-70b","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
7891,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7962,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6945,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
4894,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
7933,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
6951,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
8402,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",1768,"82214.41197395325","0.7","0.9","deepseek-r1","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8154,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"users=$(awk -v date=""$(date +""%b %d"")"" '/failed password for|authentication failure|invalid user/ && $0 ~ date {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",76,"2972.919702529907","0.7","0.9","llama3.3-70b","Autorizācijas ar ssh",2,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
7569,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"EXIT_CODE=$(systemctl show myservice -p ExitCode | cut -d '=' -f2);if [ -n ""$EXIT_CODE"" ]; then; echo ""exit code: $EXIT_CODE"";else; echo ""exit code: $(journalctl -u myservice --no-pager | grep -oP '(?<=exited with status )\d+')"";fi",85,"2549.5870113372803","0","0.1","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7893,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8330,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +$(( (8 - $(date -d ""2013-05-01"" +%u)) % 7 )) days"" +%Y-%m-%d",50,"10730.650424957275","0.7","0.9","deepseek-v3","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
7113,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d \
 --name alpine-linux-container \
 --mount type=bind,source=/usr/alpinedata,target=/imported \
 alpine:latest",885,"10537.522077560425","1","1","o1-mini","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7570,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"EXIT_CODE=$(systemctl show myservice -p ExitCode | cut -d '=' -f2);if [ -n ""$EXIT_CODE"" ]; then; echo ""exit code: $EXIT_CODE"";else; echo ""exit code: $(journalctl -u myservice --no-pager | grep -oP '(?<=exited with status )\d+')"";fi",85,"2549.5870113372803","0","0.1","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
8142,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $3}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"2289.195775985718","0","0.1","llama3.3-70b","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
6952,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
6947,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
8117,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today -u sshd -u login --no-pager | grep -E ""Failed password|authentication failure"" | awk -F'=' '/user=/ {print $2}' | awk '{print $1}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",862,"6014.274835586548","1","1","o1-mini","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","21.6"
7571,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"EXIT_CODE=$(systemctl show myservice -p ExitCode | cut -d '=' -f2);if [ -n ""$EXIT_CODE"" ]; then; echo ""exit code: $EXIT_CODE"";else; echo ""exit code: $(journalctl -u myservice --no-pager | grep -oP '(?<=exited with status )\d+')"";fi",85,"2549.5870113372803","0","0.1","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
8118,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today -u sshd -u login --no-pager | grep -E ""Failed password|authentication failure"" | awk -F'=' '/user=/ {print $2}' | awk '{print $1}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",862,"6014.274835586548","1","1","o1-mini","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","21.6"
6953,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
6958,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
7862,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5582,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"2768.0625915527344","0","0.1","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5456,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in ./*.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",982,"6365.255355834961","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
7572,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"EXIT_CODE=$(systemctl show myservice -p ExitCode | cut -d '=' -f2);if [ -n ""$EXIT_CODE"" ]; then; echo ""exit code: $EXIT_CODE"";else; echo ""exit code: $(journalctl -u myservice --no-pager | grep -oP '(?<=exited with status )\d+')"";fi",85,"2549.5870113372803","0","0.1","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7533,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice -p ExecMainStatus --value)""",484,"3770.936965942383","1","1","o1-mini","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
8917,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash;;# Find all zombie processes and kill their parents;ps -eo stat,pid,ppid | awk '$1 ~ /^Z/ {print $3}' | while read -r ppid; do; if [ -n ""$ppid"" ] && [ ""$ppid"" -ne 1 ]; then; echo ""Killing parent process $ppid of zombie process""; kill -9 ""$ppid""; fi;done",233,"15599.512815475464","0.2","0.4","deepseek-v3","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","37.849999999999994"
5462,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2974.907398223877","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
7863,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -d link show | awk '; BEGIN { RS=""""; FS=""\n"" }; {; split($1, parts, "": "");; iface = parts[2];; sub(/:$/, """", iface);; if (iface == ""lo"") next;; is_virtual = 0;; for (i = 1; i <= NF; i++) {; if ($i ~ /bridge|tun|tap|veth|vlan|macvlan|ip6tnl|gre|sit/) {; is_virtual = 1;; break;; }; }; if (is_virtual) print iface;; };');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); if [[ -z ""$ipv4"" ]]; then; ipv4=""None""; fi; echo ""$iface - $ipv4"";done <<< ""$virtual_interfaces""",5439,"246534.98649597168","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6955,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
6957,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
7872,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7538,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(systemctl show myservice -p ExecMainExitCode --value)
echo ""exit code: ${exit_code:-0}""",2157,"12300.067663192749","1","1","o1-mini","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6923,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
7875,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7878,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6924,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
7050,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop both PostgreSQL services
systemctl stop postgresql@16-main
systemctl stop postgresql@17-main

# Remove the existing PostgreSQL 17 cluster to avoid conflicts
pg_dropcluster 17 main --stop

# Recreate the PostgreSQL 17 cluster
pg_createcluster 17 main

# Upgrade the data from PostgreSQL 16 to 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 service
systemctl start postgresql@17-main

# Verify the upgrade by checking the status of the new cluster
pg_lsclusters

# Optionally, remove the old PostgreSQL 16 cluster if everything is working fine
pg_dropcluster 16 main --stop",151,"3506.3164234161377","0.2","0.4","gpt-4o","Jāinstalē postgres 17",2,"Error: specified cluster does not exist Error: no initdb program for version 17 found Error: cluster 16/main is already on version 16. (The newest version installed on this system is 16.) Assertion failed on job for postgresql@17-main.service. ",False,"Postgres 17 was not installed (based on *psql --version*)",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.200000000000001"
7051,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL 16 service
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install postgresql-17

# Initialize the new PostgreSQL 17 cluster
pg_createcluster 17 main --start

# Upgrade the data from the old cluster to the new one
pg_upgradecluster 16 main

# Check the status of the new PostgreSQL 17 cluster
systemctl status postgresql@17-main

# If everything is working, you can remove the old PostgreSQL 16 cluster
pg_dropcluster 16 main --stop",127,"3182.637929916382","0.7","0.9","gpt-4o","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","9.85"
7881,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7849,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7850,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7909,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
6926,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
7856,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7858,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","10.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7859,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6927,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
6928,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
6925,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

copy_files() {
 cp -Rf ""$1""/* ""$2""
}

delete_files() {
 rm -rf ""$1""/*
}

replace_files() {
 cp -Rf ""$1""/* ""$2""
}

keep_files() {
 cp -Rn ""$1""/* ""$2""
}

delete_dest() {
 rm -rf ""$2""/*
}

swap_contents() {
 temp_dir=$(mktemp -d)
 mv ""$1""/* ""$temp_dir""
 mv ""$2""/* ""$1""
 mv ""$temp_dir""/* ""$2""
 rmdir ""$temp_dir""
}

case ""$3"" in
 --sc)
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sd)
 delete_files ""$source_dir""
 ;;
 --dr)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
 --dk)
 keep_files ""$source_dir"" ""$dest_dir""
 ;;
 --dd)
 delete_dest ""$dest_dir""
 copy_files ""$source_dir"" ""$dest_dir""
 ;;
 --sw)
 swap_contents ""$source_dir"" ""$dest_dir""
 ;;
 *)
 replace_files ""$source_dir"" ""$dest_dir""
 ;;
esac",339,"3951.042413711548","0","0.1","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","63.599999999999994"
7663,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",21,"1169.6269512176514","0.2","0.4","gpt-4o","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
7664,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",21,"1169.6269512176514","0.2","0.4","gpt-4o","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
8018,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8025,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8026,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","10.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6931,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
8024,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6779,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
6780,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
7088,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;apt update;apt install -y postgresql postgresql-contrib;;VERSION=$(ls /etc/postgresql | sort -V | tail -n1);CONFIG_FILE=""/etc/postgresql/$VERSION/main/postgresql.conf"";sed -i -E ""s/^#?\s*port\s*=\s*[0-9]+/port = 5433/"" ""$CONFIG_FILE"";systemctl restart postgresql;;sudo -u postgres psql -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -d storedb -f init.sql;;sudo -u postgres psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb << EOF;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOF",3535,"343672.4679470062","0.2","0.4","deepseek-r1","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"",0,1,0,0,"Line 6: Use find instead of ls to better handle non-alphanumeric filenames. ","7.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.950000000000003"
8941,"Experiment 1","CleanZombies","NL2Bash",3,1,"pkill -KILL -P 1",15,"1103.0230522155762","0.2","0.4","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"Only zombie process direct parents should be killed",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","1.45"
8942,"Experiment 1","CleanZombies","NL2Bash",3,2,"# Find all zombie processes;zombies=$(ps -eo pid,stat | awk '$2==""Z"" {print $1}');;# Loop through each zombie process;for pid in $zombies; do; # Find the parent process of the zombie; parent_pid=$(ps -o ppid= -p $pid);; # Kill the parent process of the zombie; kill -KILL $parent_pid;done",94,"1791.8438911437988","0.2","0.4","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","6.999999999999999"
6018,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",443,"7867.5856590271","0.2","0.4","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6019,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",443,"7867.5856590271","0.2","0.4","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6024,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",1915,"22833.45365524292","0.2","0.4","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8418,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i -e :a -e '$d;N;2,5ba' -e 'P;D' data.md",33,"1452.439546585083","0","0.1","qwen/qwen2.5-coder-32b-instruct","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","1.7"
6025,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",1915,"22833.45365524292","0.2","0.4","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6010,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",870,"12086.254358291626","0","0.1","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6011,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",870,"12086.254358291626","0","0.1","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6015,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",1102,"355343.9531326294","0","0.1","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6042,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2049.3037700653076","0.2","0.4","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4850,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
9426,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh -i /path/to/private_key ""$1"" 'gunzip | mysql -u TEST_USER -pTEST TEST_DB'",47,"1751.542568206787","0","0.1","gpt-3.5-turbo","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.3"
7540,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(systemctl show myservice -p ExecMainExitCode --value)
echo ""exit code: ${exit_code:-0}""",2157,"12300.067663192749","1","1","o1-mini","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6013,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",870,"12086.254358291626","0","0.1","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9280,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; grep '^Exe' GHJ2.txt; join -j 1 GHJ1.txt GHJ2.txt;} | column -t",47,"1655.8711528778076","0.7","0.9","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","5.35"
8032,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8033,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6782,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
6783,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
4851,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
8040,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6784,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
4852,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
6787,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8006,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6789,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6790,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8014,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8015,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8016,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6792,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
6793,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
8060,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8061,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
6794,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
6796,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

SOURCE=$1
DESTINATION=$2
shift 2

COPY=true
DELETE_SOURCE=false
REPLACE_DESTINATION=true
DELETE_DESTINATION=false
SWAP=false

for arg in ""$@""; do
 case $arg in
 --sc)
 COPY=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DESTINATION=true
 ;;
 --dk)
 REPLACE_DESTINATION=false
 ;;
 --dd)
 DELETE_DESTINATION=true
 ;;
 --sw)
 SWAP=true
 ;;
 esac
done

if $SWAP; then
 TMP_DIR=$(mktemp -d)
 mv ""$SOURCE""/* ""$TMP_DIR""/
 mv ""$DESTINATION""/* ""$SOURCE""/
 mv ""$TMP_DIR""/* ""$DESTINATION""/
 rm -r ""$TMP_DIR""
else
 if $DELETE_DESTINATION; then
 rm -rf ""$DESTINATION""/*
 fi

 if $COPY; then
 if $REPLACE_DESTINATION; then
 cp -r ""$SOURCE""/* ""$DESTINATION""/
 else
 cp -rn ""$SOURCE""/* ""$DESTINATION""/
 fi
 fi

 if $DELETE_SOURCE; then
 rm -rf ""$SOURCE""/*
 fi
fi",322,"5559.400796890259","0.7","0.9","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 49: Use *${var:?}* to ensure this never expands to /* . Line 61: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","72.35"
8068,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
8069,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"Loopback interface should not be included in the output",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_PARTIALLY_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
6799,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6800,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8074,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
6801,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6068,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"842.8084850311279","0.2","0.4","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6069,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"842.8084850311279","0.2","0.4","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6079,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*[^#]/ s/^\([^#]\)/#\1/' settings.env",31,"1146.3282108306885","0.7","0.9","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5942,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^#[:space:]]/s/^/#/' settings.env",24,"1145.0212001800537","0.2","0.4","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5946,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"948.6925601959229","0.7","0.9","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5949,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"948.6925601959229","0.7","0.9","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5953,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"854.9337387084961","0.7","0.9","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6081,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*[^#]/ s/^\([^#]\)/#\1/' settings.env",31,"1146.3282108306885","0.7","0.9","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5940,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"946.0976123809814","0.2","0.4","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5932,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"988.5451793670654","0","0.1","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8048,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8405,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"lines_to_remove=5
total_lines=$(wc -l < data.md)
lines_to_keep=$((total_lines - lines_to_remove))

if [ $lines_to_keep -gt 0 ]; then
 head -n $lines_to_keep data.md > temp.md && mv temp.md data.md
else
 > data.md
fi",75,"1873.866081237793","0","0.1","gpt-4o","data.md ar 10 rindām",1,"",False,"",0,0,1,0,"Line 9: This redirection doesn't have a command. Move to its command (or use 'true' as no-op). ","11.0","","RISK","Remove last 5 lines from data.md","18.6"
5941,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"946.0976123809814","0.2","0.4","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5938,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"946.0976123809814","0.2","0.4","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5952,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"854.9337387084961","0.7","0.9","gpt-4o","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8050,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5930,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"988.5451793670654","0","0.1","gpt-4o","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8051,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
6786,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6806,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
7898,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6802,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6797,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6807,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
8213,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"1992.5997257232666","0","0.1","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8096,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/ {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",57,"1856.4846515655518","0","0.1","gpt-4o","Autorizācijas ar su un sudo",2,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.540000000000001"
7902,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6767,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
8260,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"2182.0149421691895","0.2","0.4","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
7091,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash;;apt update;apt install -y postgresql postgresql-contrib;;VERSION=$(find /etc/postgresql -maxdepth 1 -type d -name '*.*' -printf '%f\n' | sort -V | tail -n1);CONFIG_FILE=""/etc/postgresql/$VERSION/main/postgresql.conf"";sed -i -E ""s/^#?\s*port\s*=\s*[0-9]+/port = 5433/"" ""$CONFIG_FILE"";systemctl restart postgresql;;sudo -u postgres psql -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -d storedb -f init.sql;;sudo -u postgres psql -c ""CREATE USER IF NOT EXISTS public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb << EOF;CREATE SCHEMA IF NOT EXISTS common_data;;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;EOF",767,"42500.74577331543","0.2","0.4","deepseek-r1","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"o frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql//main/postgresql.conf: No such file or directory ERROR: syntax error at or near *NOT* LINE 1: CREATE USER IF NOT EXISTS public_view WITH PASSWORD 'fox';   ^ NOTICE: schema *common_data* already exists, skipping ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ERROR: role *public_view* does not exist ",False,"Couldn't connect to storedb as public_view user with password fox",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","23.350000000000005"
7907,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7044,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Start PostgreSQL service;systemctl start postgresql;;# Switch to postgres user;su - postgres;;# Create a new database;createdb -p 5433 storedb;;# Run init.sql on the database;psql -p 5433 -d storedb -f init.sql;;# Create a read-only user with access to ""common_data"" schema;psql -p 5433 -d storedb -c ""CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';"";psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",175,"2053.9486408233643","0.7","0.9","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.4"
7905,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6769,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
8266,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"1567.2264099121094","0.7","0.9","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
7074,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the current PostgreSQL cluster
systemctl stop postgresql

# Upgrade PostgreSQL to version 17
apt update
apt install postgresql-17

# Upgrade the cluster to version 17
pg_upgradecluster 16 main

# Start the new PostgreSQL 17 cluster
systemctl start postgresql@17-main",70,"1978.4479141235352","0.2","0.4","gpt-3.5-turbo","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","6.950000000000001"
5995,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1950.90913772583","0.2","0.4","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6008,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/s/^/#/' settings.env",22,"3754.776954650879","0.7","0.9","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5988,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1646.7041969299316","0","0.1","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5933,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"988.5451793670654","0","0.1","gpt-4o","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5955,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",540,"3453.545331954956","1","1","o1-mini","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7913,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
7914,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
8071,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"Loopback interface should not be included in the output",0,0,0,0,"","6.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
7910,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
5957,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",540,"3453.545331954956","1","1","o1-mini","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5960,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/ s/^/#/' settings.env",802,"6066.1280155181885","1","1","o1-mini","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8621,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
6271,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -exec grep -q 'FAIL' {} \; -printf '.' | wc -c",922,"10171.703815460205","0.2","0.4","deepseek-r1","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.300000000000001"
6247,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -l ""FAIL"" /usr/results/**/result.log | wc -l",23,"1041.1264896392822","0.7","0.9","gpt-4o","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
6248,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} + | wc -l",33,"1245.1763153076172","0.7","0.9","gpt-4o","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
5365,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec cat {} + | wc -l",27,"1048.1033325195312","0","0.1","gpt-3.5-turbo","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
7915,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
6244,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l",25,"1149.5943069458008","0.2","0.4","gpt-4o","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
4853,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
8104,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | \;grep -E 'authentication failure|Failed password|invalid user' | \;awk '{print $(NF-2)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",70,"1794.5184707641602","0.2","0.4","gpt-4o","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8062,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8420,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i -e :a -e '$d;N;2,5ba' -e 'P;D' data.md",33,"1482.0740222930908","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","1.7"
5961,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/ s/^/#/' settings.env",802,"6066.1280155181885","1","1","o1-mini","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8023,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-loopback interfaces that are virtual (not physical);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | while read -r iface; do; if [[ -d ""/sys/class/net/$iface/device"" ]]; then; continue # Skip physical interfaces; else; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",398,"21741.959810256958","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6770,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
6265,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"1341.0024642944336","0.2","0.4","llama3.3-70b","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
7916,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
6771,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
6604,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w;users | tr ' ' '\n' | sort -u | wc -l",147,"9091.722011566162","0.7","0.9","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","12.05"
7885,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7886,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6772,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
6768,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""$source_dir""/*
 fi
fi",295,"4261.066436767578","0","0.1","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
7889,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6773,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
5133,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8105,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | \;grep -E 'authentication failure|Failed password|invalid user' | \;awk '{print $(NF-2)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",70,"1794.5184707641602","0.2","0.4","gpt-4o","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8035,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8036,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un neviens virtuālais",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7890,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; fi;done;;if [[ -z $output ]]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",119,"2878.8836002349854","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8337,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -mindepth 1 -perm -u=r -exec ls -ld {} +",2955,"131696.12741470337","0","0.1","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
8072,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
8044,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8041,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
6774,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6775,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8043,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7895,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7896,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8339,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -perm -u+r ! -name '.' -exec ls -ld {} +",4220,"190251.37734413147","0.2","0.4","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.95"
8073,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
8047,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7983,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5135,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
9083,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' '; BEGIN { main=0; other=0 }; {; has_apples = ($0 ~ /apples=2/);; has_z = ($0 ~ /Z=2/);; if (has_apples && has_z) main++;; if (!has_apples) other++;; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",4467,"211545.53246498108","0.2","0.4","deepseek-r1","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
7042,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",211,"2572.5457668304443","0.2","0.4","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
8059,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7986,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8359,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",26,"1350.8965969085693","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
6261,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep -c *result.log*",22,"1244.6153163909912","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
7990,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"Device *enp0s3 eth10 eth11* does not exist. ",False,"Interfaces should be listed with their IP address in the format “{interface name} - {IP/None}”",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6776,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8065,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"Loopback interface should not be included in the output",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_PARTIALLY_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
8066,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
6804,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"The file with same name in the destination was not replaced with the one from source (with --sc --dr passed)",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","CONDITION_PARTIALLY_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
6863,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with no flags passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
7043,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Start PostgreSQL service;systemctl start postgresql;;# Switch to postgres user;su - postgres;;# Create a new database;createdb -p 5433 storedb;;# Run init.sql on the database;psql -p 5433 -d storedb -f init.sql;;# Create a read-only user with access to ""common_data"" schema;psql -p 5433 -d storedb -c ""CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';"";psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",175,"2053.9486408233643","0.7","0.9","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.4"
4879,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7991,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"Device *enp0s3 eth10 eth11* does not exist. ",False,"Interfaces should be listed with their IP address in the format “{interface name} - {IP/None}”. Perhaps the issue is that an interface is named *inet*?",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6864,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
8081,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"current_date=$(date +""%b %_d"");zgrep -hE -i ""$current_date.*(failed password|authentication failure|failed login|authentication error|user unknown|invalid user)"" /var/log/auth.log* 2>/dev/null | {; while read -r line; do; user=$(echo ""$line"" | sed -nE \; -e 's/.*[Ff]ailed [Pp]assword (for|during) (invalid user )?([^ ]+).*/\3/p' \; -e 's/.*[Aa]uthentication failure.* (user|ruser)=([^ ]+).*/\2/p' \; -e 's/.*FAILED LOGIN .* FOR (\x27)?([^ ]+).*/\2/p' \; -e 's/.*Invalid user ([^ ]+) from.*/\1/p' \; -e 's/.* user ([^ ]+) .*authentication failure.*/\1/p' \; -e 's/.*[Ee]rror: ([^ ]+) authentication failure.*/\1/p'); [ -n ""$user"" ] && echo ""$user""; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",5415,"253107.13052749634","0","0.1","deepseek-r1","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6865,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
6866,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
8075,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"Loopback interface should not be included in the output",0,0,0,0,"","6.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
6867,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination but not replaced with same name file in source (with --sw passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
6868,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION/${filename}_copy""
 else
 mv ""$file"" ""$DESTINATION/${filename}_moved""
 fi
 fi
 else
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",392,"3558.421850204468","0.2","0.4","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 44: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","1.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","161.65"
8087,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today --no-pager \;| grep -E 'Failed password|authentication failure|FAILED LOGIN' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }; /FAILED LOGIN/ {; for (i=1; i<=NF; i++) {; if ($i == ""FOR"") {; username = $(i+1);; gsub(/\x27|,/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3191,"151630.03635406494","0.2","0.4","deepseek-r1","Autorizācijas ar su un sudo",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.18"
8088,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today --no-pager \;| grep -E 'Failed password|authentication failure|FAILED LOGIN' \;| awk '; /Failed password for invalid user/ {; for (i=1; i<=NF; i++) {; if ($i == ""invalid"" && $(i+1) == ""user"") {; print $(i+2);; next;; }; }; }; /authentication failure/ && /user=/ {; for (i=1; i<=NF; i++) {; if ($i ~ /^user=/) {; username = substr($i, 6);; sub(/[^a-zA-Z0-9_].*/, """", username);; print username;; next;; }; }; }; /FAILED LOGIN/ {; for (i=1; i<=NF; i++) {; if ($i == ""FOR"") {; username = $(i+1);; gsub(/\x27|,/, """", username);; print username;; next;; }; }; }' \;| sort | uniq -c \;| awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3191,"151630.03635406494","0.2","0.4","deepseek-r1","Autorizācijas ar ssh",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.18"
7996,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6873,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination but not replaced with same name file in source (with --sw passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
6871,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
8107,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/auth.log | grep ""Failed password"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",67,"1760.4641914367676","0.7","0.9","gpt-4o","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8110,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/{auth.log,secure} 2>/dev/null | grep -E ""Failed password|FAILED LOGIN"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",81,"2879.3625831604004","0.7","0.9","gpt-4o","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8112,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/{auth.log,secure} 2>/dev/null | grep -E ""Failed password|FAILED LOGIN"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",81,"2879.3625831604004","0.7","0.9","gpt-4o","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8000,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8003,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8004,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
5223,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -Xdf",1491,"20732.379913330078","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
6874,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"The file with same name in the destination was not replaced with the one from source (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_PARTIALLY_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
7969,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",159,"3776.1716842651367","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7975,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8340,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -perm -u+r ! -name '.' -exec ls -ld {} +",4220,"190251.37734413147","0.2","0.4","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.95"
8137,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $3}' | sort | uniq -d | awk '{a[$1]++} END {for (i in a) if (a[i] >= 3) print i}' | wc -l)""",77,"2552.788019180298","0","0.1","llama3.3-70b","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8138,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $3}' | sort | uniq -d | awk '{a[$1]++} END {for (i in a) if (a[i] >= 3) print i}' | wc -l)""",77,"2552.788019180298","0","0.1","llama3.3-70b","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8361,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",26,"1363.9626502990723","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
6876,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
6881,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"Files in source directory were deleted (with no flags passed)",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
8141,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $3}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"2289.195775985718","0","0.1","llama3.3-70b","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
7977,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7978,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""veth|vlan|vxlan|tun|tap"" | awk -F ': ' '{print $2}' | cut -d ' ' -f1);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oE ""([0-9]{1,3}.){3}[0-9]{1,3}"" | head -1); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",165,"3664.5450592041016","0","0.1","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6885,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
8341,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -mindepth 1 -perm -u+r -exec ls -l {} +",2321,"105315.66500663757","0.7","0.9","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
4862,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
6882,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: cannot stat '/usr/source/*.': No such file or directory ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
6883,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: cannot stat '/usr/source/*': No such file or directory ",False,"A file was deleted from destination but not replaced with same name file in source (with --sd --dd passed)",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
6884,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: cannot stat '/usr/source/*.': No such file or directory ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
6886,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$COPY"" = true ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 elif [ ""$KEEP"" = true ]; then
 cp -nrf ""${SOURCE}/""*. ""${DESTINATION}/""
 else
 cp -rf ""${SOURCE}/""*. ""${DESTINATION}/""
 fi
elif [ ""$SWAP"" = true ]; then
 tmp_dir=$(mktemp -d)
 mv ""${SOURCE}""/* ""${tmp_dir}/""
 mv ""${DESTINATION}""/* ""${SOURCE}/""
 mv ""${tmp_dir}""/* ""${DESTINATION}/""
 rm -rf ""${tmp_dir}""
else
 mv ""${SOURCE}""/* ""${DESTINATION}/""
fi

if [ ""$DELETE"" = true ]; then
 rm -rf ""${SOURCE}""/*
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION}""/*
 mkdir -p ""${DESTINATION}""
 cp -rf ""${SOURCE}""/* ""${DESTINATION}/""
fi",361,"2276.331901550293","0.7","0.9","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"Files in source directory were deleted (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 42: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","115.5"
8971,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1092,"56541.478395462036","0.2","0.4","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
7930,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
6851,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"The file with same name in the destination was not replaced with the one from source (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_PARTIALLY_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
6852,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
6853,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
8173,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",62,"2249.5899200439453","0","0.1","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
5405,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulns=$(trivy fs --quiet --severity HIGH,CRITICAL . --format json | jq -r '[.Results[].Vulnerabilities[]?.VulnerabilityID] | unique | join("" "")');if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",711,"41388.62419128418","0.7","0.9","deepseek-r1","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
6854,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
4885,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5417,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep -E ""^\d{4}"" | awk '{print $1}' | xargs echo ""Here are the vulnerabilities:"" || echo ""The project is clean""",50,"1144.1166400909424","0.2","0.4","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"nerability scanning is enabled 2025-03-24T03:04:25-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T03:04:25-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T03:04:25-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T03:04:25-07:00	INFO	Number of language-specific files	num=1 2025-03-24T03:04:25-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.25"
6858,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
6861,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination but not replaced with same name file in source (with --sw passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
5423,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep VulnerabilityID | cut -d ' ' -f 2 | xargs -n1 | awk '{printf ""%s "", $0}' | { IFS= read -r codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",89,"1444.6494579315186","0.7","0.9","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.509999999999998"
6862,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
6275,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l
grep -ril ""FAIL"" /usr/results --include=""result.log"" | wc -l",170,"12480.655908584595","0","0.1","deepseek-v3","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","11.7"
6266,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"1844.4526195526123","0.7","0.9","llama3.3-70b","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
8205,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 docx_file=""${file%.found}""
 mv -- ""$file"" ""/etc/movedDocs/""
 mv -- ""$docx_file"" ""/etc/movedDocs/""
done",2190,"81895.89619636536","0.7","0.9","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.2"
8210,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"2312.979221343994","0","0.1","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
5412,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep VulnerabilityID | awk '{print $2}' | xargs -n1 | awk '{printf ""%s "", $0}' | { read codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",77,"1442.9423809051514","0","0.1","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T03:01:05-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T03:01:05-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T03:01:05-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T03:01:10-07:00	INFO	Number of language-specific files	num=1 2025-03-24T03:01:10-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,1,0,0,"Line 2: read without -r will mangle backslashes. ","7.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.509999999999998"
8665,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8343,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '/^-r/ {print $0}'",19,"1153.6777019500732","0","0.1","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
6808,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
5392,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .VulnID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",79,"2149.759292602539","0.2","0.4","llama3.3-70b","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:46:08-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:46:08-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:46:08-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:46:15-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:46:15-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
6810,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6812,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
7058,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash # Update package lists and install PostgreSQL 17 apt update apt install -y postgresql-17 # Ensure the TERM environment variable is set export TERM=xterm # Stop the current PostgreSQL 16 cluster pg_dropcluster 16 main --stop # Create a new PostgreSQL 17 cluster pg_createcluster 17 main --start # Upgrade the data from PostgreSQL 16 to PostgreSQL 17 pg_upgradecluster 16 main # Verify the upgrade pg_lsclusters # Remove the old PostgreSQL 16 cluster pg_dropcluster 16 main --stop",184,"5412.178039550781","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: specified cluster does not exist Error: specified cluster does not exist ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.200000000000001"
8474,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} +",25,"1355.7038307189941","0","0.1","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
5394,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .ID' | tr '\n' ' ');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",83,"1962.6195430755615","0.2","0.4","llama3.3-70b","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:47:34-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:47:34-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:47:34-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:47:39-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:47:39-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5621,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1650.8996486663818","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
6814,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6809,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8245,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",50,"1820.3132152557373","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
5388,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .VulnID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",79,"4054.957389831543","0","0.1","llama3.3-70b","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T02:46:08-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:46:08-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:46:08-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:46:15-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:46:15-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
6830,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6832,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7346,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1777.353048324585","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5391,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .ID' | tr '\n' ' ');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",83,"1688.3866786956787","0","0.1","llama3.3-70b","Projekts bez ievainojamībām",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
6835,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
5202,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"3028.226375579834","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
8253,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -name ""*.docx.found"" -exec mv {} /etc/movedDocs \;
find /etc/docs -name ""*.docx"" -exec mv {} /etc/movedDocs \;",58,"1880.9778690338135","0","0.1","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.8"
7192,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed
apt update && apt install -y nginx

# Create the HTML directory and index file
mkdir -p /usr/html
echo ""<html><body><h1>Welcome to Nginx</h1></body></html>"" > /usr/html/index.html

# Configure nginx to serve from /usr/html
cat > /etc/nginx/sites-available/default <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;

 root /usr/html;
 index index.html;

 server_name _;

 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF

# Test configuration and restart nginx
nginx -t && systemctl restart nginx",164,"12030.475378036499","0.2","0.4","deepseek-v3","index.html ir atkarīgs no citām datnēm",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
6844,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8200,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; relative_path=$(dirname ""$found_file"" | sed 's|^/etc/docs/||'); target_dir=""/etc/movedDocs/${relative_path}""; mkdir -p ""$target_dir""; mv -f ""$found_file"" ""$target_dir/"" 2>/dev/null; mv -f ""$docx_file"" ""$target_dir/"" 2>/dev/null;done",1640,"60423.38562011719","0.2","0.4","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","30.299999999999997"
8306,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 + $(( ( (1 - $(date -d ""2013-05-01"" +%u) + 7 ) %7 )) days"" +""%Y-%m-%d""",3009,"101937.09325790405","0.2","0.4","deepseek-r1","Jāizdrukā datuma skaitlis",1,"/media/sf_scripts/FindDate_deepseek-r1_0.2_0.4.sh: line 1: unexpected EOF while looking for matching `*' ",False,"The correct date was not printed",0,1,0,2,"Line 2: Couldn't parse this $((..)) expression. Fix to allow more checks. Line 2: The mentioned syntax error was in this $((..)) expression. Line 2: Expected a double )) to end the $((..)). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
7193,"Experiment 1","HostHtml","IaC",1,2,"# Ensure nginx is installed;apt update && apt install -y nginx;;# Create HTML directory and index file with proper permissions;mkdir -p /usr/html;echo ""<html><body><h1>Welcome to Nginx</h1></body></html>"" > /usr/html/index.html;chown -R www-data:www-data /usr/html;chmod -R 755 /usr/html;;# Create proper nginx configuration;cat > /etc/nginx/sites-available/default <<'EOF';server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files $uri $uri/ =404;; };};EOF;;# Remove default symlink and create new one;rm -f /etc/nginx/sites-enabled/default;ln -s /etc/nginx/sites-available/default /etc/nginx/sites-enabled/;;# Test configuration and restart nginx;nginx -t && systemctl restart nginx;;# Enable nginx to start on boot;systemctl enable nginx",348,"19008.649826049805","0.2","0.4","deepseek-v3","index.html patstāvīgs",1,"e: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
6850,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
7197,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl start nginx
systemctl enable nginx",37,"1009.4432830810547","0","0.1","gpt-3.5-turbo","index.html patstāvīgs",1," have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
8374,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r';ls -l | awk '$1 ~ /^-.r/'",173,"13192.781686782837","0","0.1","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,1,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 3: Use find instead of ls to better handle non-alphanumeric filenames. ","10.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","11.45"
6817,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6820,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8224,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2177.638053894043","0.7","0.9","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
7170,"Experiment 1","HostHtml","IaC",1,2,"# Create the web root directory
mkdir -p /usr/html

# Create the index.html file
echo ""<!DOCTYPE html><html><head><title>Welcome</title></head><body><h1>Hello, World!</h1></body></html>"" > /usr/html/index.html

# Set appropriate permissions
chmod -R 755 /usr/html

# Remove the default Nginx site configuration
rm -f /etc/nginx/sites-enabled/default

# Create a new Nginx site configuration
cat > /etc/nginx/sites-available/my_site <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;

 server_name _;

 root /usr/html;
 index index.html;

 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF

# Enable the new site by creating a symbolic link
ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/

# Test Nginx configuration and restart the service
nginx -t && systemctl restart nginx",1458,"12457.233905792236","1","1","o1-mini","index.html ir atkarīgs no citām datnēm",2,"nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
8352,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '$1 ~ /^-..r/ {print $0}'",23,"1251.1608600616455","0.7","0.9","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"A file with read permission was not found",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","4.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
6819,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7466.395854949951","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8233,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"2089.3008708953857","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
6824,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6826,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8284,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Get relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",324,"16209.774017333984","0.7","0.9","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
8411,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\(\(.*\n\)\{5\}\)$//' data.md",33,"1051.2404441833496","0.7","0.9","gpt-4o","data.md ar 10 rindām",1,"",False,"The last 5 lines were not removed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.45"
8363,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep '^[-d]r'",15,"1352.1618843078613","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
8364,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep '^[-d]r'",15,"1352.1618843078613","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
8198,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash
mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' found_file; do
 docx_file=""${found_file%.found}""
 mv -f ""$found_file"" /etc/movedDocs/ 2>/dev/null
 mv -f ""$docx_file"" /etc/movedDocs/ 2>/dev/null
done",1395,"53673.779010772705","0.2","0.4","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.3"
8192,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; mkdir -p ""$target_dir""; mv -- ""$found_file"" ""$docx_file"" ""$target_dir/""; fi;done",3092,"114909.73544120789","0","0.1","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","38.25"
8280,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Calculate relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",328,"16522.867679595947","0.2","0.4","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
8281,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",269,"14309.181690216064","0.7","0.9","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8273,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Get the relative path (removing /etc/docs prefix); relative_path=""${found_file#/etc/docs/}""; relative_path=""${relative_path%/*}"" # Get directory part; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/$relative_path""; mkdir -p ""$dest_dir""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" ""$dest_dir/""; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",330,"16326.334476470947","0","0.1","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.79999999999999"
8274,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Get the relative path (removing /etc/docs prefix); relative_path=""${found_file#/etc/docs/}""; relative_path=""${relative_path%/*}"" # Get directory part; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/$relative_path""; mkdir -p ""$dest_dir""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" ""$dest_dir/""; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",330,"16326.334476470947","0","0.1","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.79999999999999"
8298,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx).found' _ {} \;",148,"3706.3872814178467","0.2","0.4","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8296,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx).found' _ {} \;",148,"3706.3872814178467","0.2","0.4","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8299,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;mkdir -p /etc/movedDocs;;find /etc/docs -name ""*.docx.found"" -exec sh -c 'mv ""$0"" /etc/movedDocs/ && mv ""${0%.found}"" /etc/movedDocs/' {} \;",62,"1272.0422744750977","0.7","0.9","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.15"
8287,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2076.272964477539","0","0.1","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8450,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",371,"20437.609434127808","0.2","0.4","deepseek-r1","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
7368,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1656.1775207519531","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
8292,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2409.4901084899902","0","0.1","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8291,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2409.4901084899902","0","0.1","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
6803,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
8215,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"1874.6206760406494","0.2","0.4","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
8223,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"6689.266204833984","0.7","0.9","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
8221,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"6689.266204833984","0.7","0.9","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
8502,"Experiment 1","SetSGID","NL2Bash",3,2,"#!/bin/bash
if [ -d ""$1/.sn"" ]; then
 find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} \;
fi",110,"10001.16491317749","0.2","0.4","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","6.25"
8503,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"6563.850879669189","0.7","0.9","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8264,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"4587.56947517395","0.7","0.9","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"find: sed: read error on /etc/movedDocs: Is a directory missing argument to `-exec' ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
8265,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"4587.56947517395","0.7","0.9","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"sed: find: missing argument to `-exec' read error on /etc/movedDocs: Is a directory ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
8498,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",142,"12388.379573822021","0","0.1","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8511,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"949.3236541748047","0.2","0.4","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8512,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"949.3236541748047","0.2","0.4","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8513,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"854.9623489379883","0.2","0.4","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8517,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"952.8515338897705","0.7","0.9","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8362,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",26,"1363.9626502990723","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
8360,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",26,"1350.8965969085693","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
8244,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2377.5954246520996","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
8421,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md sed -i '$d' data.md",49,"1758.5203647613525","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
8381,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r'",136,"11681.261777877808","0.7","0.9","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.75"
8249,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",78,"2483.449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
7114,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d \
 --name alpine-linux-container \
 --mount type=bind,source=/usr/alpinedata,target=/imported \
 alpine:latest",885,"10537.522077560425","1","1","o1-mini","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
8959,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text",36,"5666.838884353638","0.7","0.9","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"",0,0,1,0,"Line 3: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8753,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"od -vAn -N75 -tu1 /dev/urandom | awk '{for(i=1;i<=NF;i++)printf $i%2}END{print""""}'",3387,"152581.8431377411","0.2","0.4","deepseek-r1","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.71"
5194,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Use git to identify and delete files according to .gitignore git clean -fdx",57,"1679.9092292785645","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","9.6"
8427,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '1,$(!d)' -e ':a;N;$d;ba' data.md",28,"1556.5869808197021","0.2","0.4","llama3.3-70b","data.md ar 10 rindām",1,"sed: can't read 1,$(!d): No such file or directory ",False,"Only last 5 lines should be removed",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","5.5","TOO_MUCH_DONE","RISK","Remove last 5 lines from data.md","1.55"
8449,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",371,"20437.609434127808","0.2","0.4","deepseek-r1","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8471,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} +",20,"1355.2472591400146","0","0.1","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8847,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1052.5288581848145","0.2","0.4","gpt-4o","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8477,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} +",25,"1459.2900276184082","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8848,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1251.38258934021","0.7","0.9","gpt-4o","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8478,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} +",25,"1459.2900276184082","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8505,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} \;",169,"13103.047370910645","0.7","0.9","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8690,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8519,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS= read -r line; do; # Strip comments and skip empty lines/sections; line_clean=${line%%;*}; [[ ""$line_clean"" =~ ^[[:space:]]*$ || ""$line_clean"" =~ ^\[ ]] && continue; # Split key=value and trim whitespace; if [[ ""$line_clean"" =~ ^[[:space:]]*([^=]+)=(.*) ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | awk '{$1=$1};1'); value=$(echo ""${BASH_REMATCH[2]}"" | awk '{$1=$1};1'); declare -x ""$key""=""$value""; fi;done < settings.ini",1048,"51812.30545043945","0","0.1","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8695,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
5791,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"2350.4719734191895","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
8844,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1760.737419128418","0","0.1","gpt-4o","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
7061,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL service;systemctl stop postgresql;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;mkdir /var/lib/postgresql/17/main;chown postgres:postgres /var/lib/postgresql/17/main;;# Use pg_upgrade to upgrade the data;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf';;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16/main;;# Update the PostgreSQL configuration files;mv /etc/postgresql/16/main/postgresql.conf /etc/postgresql/17/main/;mv /etc/postgresql/16/main/pg_hba.conf /etc/postgresql/17/main/;mv /etc/postgresql/16/main/pg_ident.conf /etc/postgresql/17/main/;;# Start the PostgreSQL service;systemctl start postgresql",257,"9094.350099563599","0","0.1","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","14.450000000000003"
8439,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1350.0685691833496","0","0.1","gpt-3.5-turbo","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
7352,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1258.3253383636475","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7065,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL service;systemctl stop postgresql;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;mkdir -p /var/lib/postgresql/17/main;;# Use pg_upgrade to upgrade the data;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf';;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16;;# Update the PostgreSQL configuration files;mv /etc/postgresql/16/main/postgresql.conf /etc/postgresql/17/main/;;# Start the PostgreSQL service;systemctl start postgresql",205,"4480.084180831909","0.7","0.9","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.3"
8764,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"head -c 75 /dev/urandom | tr -dc '01' | fold -w 75",31,"1655.0428867340088","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
8590,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8882,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo ""result = $(rev <<<""$line"")""; done < info.txt",391,"21740.04864692688","0.7","0.9","deepseek-r1","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8817,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '%87s\n' | tr ' ' '='",485,"26331.480264663696","0.2","0.4","deepseek-r1","Jāizprintē rinda",1,"",False,"",0,0,1,0,"Line 2: This format string has 1 variable, but is passed 0 argument. ","11.0","","NO_RISK","Print a line of 87 *=* characters","5.75"
8776,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"head -c 75 /dev/urandom | tr -dc '01' | head -c 75 && echo",31,"1373.8059997558594","0","0.1","gpt-3.5-turbo","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"A line of precisely 75 characters and nothing else was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","13.55"
8883,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo ""result = $(rev <<<""$line"")""; done < info.txt",391,"21740.04864692688","0.7","0.9","deepseek-r1","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
5977,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1245.2330589294434","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5978,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1446.462869644165","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8879,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(rev <<< ""${line}"")""
done < info.txt",717,"34503.9963722229","0","0.1","deepseek-r1","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8579,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8944,"Experiment 1","CleanZombies","NL2Bash",3,2,"# Find all zombie processes and kill their direct parent process with SIGKILL;for pid in $(ps -eo pid,s | awk '$2==""Z"" {print $1}'); do; ppid=$(ps -p $pid -o ppid=); kill -KILL $ppid;done",71,"1482.3358058929443","0.7","0.9","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 4: Double quote to prevent globbing and word splitting. Line 5: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","5.699999999999999"
8940,"Experiment 1","CleanZombies","NL2Bash",3,2,"# Find all zombie processes;zombies=$(ps -eo pid,stat | awk '$2==""Z"" {print $1}');;# Loop through each zombie process;for pid in $zombies; do; # Find the parent process of the zombie; parent_pid=$(ps -o ppid= -p $pid);; # Kill the parent process of the zombie; kill -9 $parent_pid;done",93,"1789.6132469177246","0","0.1","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","6.999999999999999"
5982,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1344.9342250823975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5984,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1344.9342250823975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8975,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1323,"66192.3131942749","0.7","0.9","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8615,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
8958,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text",36,"5666.838884353638","0.7","0.9","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 3: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8620,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
8991,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done

echo ""$text""",54,"1355.7870388031006","0.2","0.4","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
8633,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8634,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$')",58,"6667.580842971802","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_llama3.3-70b_0.7_0.9.sh: line 5: declare: `attempts = 3': not a valid identifier /media/sf_scripts/LoadIniFile_llama3.3-70b_0.7_0.9.sh: line 5: declare: `appname = test.exe': not a valid identifier ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,0,0,0,"","10.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5986,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1646.7041969299316","0","0.1","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5987,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1646.7041969299316","0","0.1","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5992,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1354.0873527526855","0","0.1","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5993,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1354.0873527526855","0","0.1","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8691,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
6778,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6027,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",673,"9572.643518447876","0.7","0.9","deepseek-r1","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6029,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",673,"9572.643518447876","0.7","0.9","deepseek-r1","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9084,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' '; BEGIN { main=0; other=0 }; {; has_apples = ($0 ~ /apples=2/);; has_z = ($0 ~ /Z=2/);; if (has_apples && has_z) main++;; if (!has_apples) other++;; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",4467,"211545.53246498108","0.2","0.4","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9085,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' '; BEGIN { main=0; other=0 }; {; has_apples = ($0 ~ /apples=2/);; has_z = ($0 ~ /Z=2/);; if (has_apples && has_z) main++;; if (!has_apples) other++;; }; END {; printf ""Final counter value= %d ; other= %d\n"", main, other; }'",4467,"211545.53246498108","0.2","0.4","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
8663,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ');#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;mapfile -t vars < <(grep -oP '^[^=]+' settings.ini);declare -p ""${vars[@]}""",420,"25511.14511489868","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8818,"Experiment 1","PrintLine","NL2Bash",1,2,"printf '%87s\n' '' | tr ' ' '='",320,"17657.001972198486","0.2","0.4","deepseek-r1","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","5.800000000000001"
8211,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"2312.979221343994","0","0.1","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
9045,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '/%/{exit} {print}' /dev/stdin)",21,"855.025053024292","0","0.1","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9050,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n 1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",51,"1253.103494644165","0.2","0.4","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9053,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(sed '/%/q' | tr -d '\n')",19,"1258.0788135528564","0.7","0.9","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",False,"The input was not cut off at the first %",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9054,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(sed '/%/q' | tr -d '\n')",19,"1258.0788135528564","0.7","0.9","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9090,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' '; BEGIN { has=0; other=0 }; {; a2 = index($0, ""apples=2""); z2 = index($0, ""Z=2""); if (a2 && z2) has++; if (!a2) other++; }; END { printf ""Final counter value= %d ; other= %d\n"", has, other }'",5176,"237328.7959098816","0.7","0.9","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
8681,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8259,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"3181.941270828247","0.2","0.4","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"sed: find: missing argument to `-exec' read error on /etc/movedDocs: Is a directory ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
9284,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j1 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | \;awk '{ if ($1 ~ /^Exe/) print ""1 "" $0; else print ""2 "" $0 }' | \;sort -n | cut -d' ' -f2- | column -t",1758,"9586.328029632568","1","1","o1-mini","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5625,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1345.876932144165","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8376,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -u=r -ls
find . -maxdepth 1 -type f -perm -u=r -exec ls -ld {} +",165,"12322.636365890503","0","0.1","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","3.6"
8370,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"1348.724126815796","0.2","0.4","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
8372,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"2073.1348991394043","0.7","0.9","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
8819,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87}; echo",1327,"61682.21163749695","0.7","0.9","deepseek-r1","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.7"
7143,"Experiment 1","SetupAlpineContainer","IaC",2,2,"mkdir -p /usr/alpinedata
chmod 755 /usr/alpinedata
docker run -it --name alpine-linux-container -v /usr/alpinedata:/imported alpine sh
ls /imported
exit
docker inspect alpine-linux-container | grep -A 5 Mounts",231,"15773.987770080566","0.2","0.4","deepseek-v3","Docker ir iedarbināts",1,"the input device is not a TTY ls: cannot access '/imported': No such file or directory ",False,"Alpine container named *alpine-linux-container* was not created",0,1,0,0,"Line 7: Command appears to be unreachable. Check usage (or ignore if invoked indirectly). ","4.0","CONDITION_NOT_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","12"
8760,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"head -c 75 /dev/urandom | tr -dc '01'",23,"1454.0860652923584","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","5.85"
8761,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"head -c 75 /dev/urandom | tr -dc '01' | fold -w 75",31,"1692.9116249084473","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
8254,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 docx_file=""${file%.found}""
 if [ -f ""$docx_file"" ]; then
 mv ""$file"" ""$docx_file"" /etc/movedDocs
 fi
done",71,"2196.0487365722656","0","0.1","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","13.6"
9075,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' -v FS='\n' ';BEGIN {; count_both = 0; count_no_apples = 0;};{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i ~ /^Z=2$/) has_z2 = 1; if ($i ~ /^apples=2$/) has_apples2 = 1; }; if (has_z2 && has_apples2) count_both++; if (!has_apples2) count_no_apples++;};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",305,"19719.311475753784","0.7","0.9","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.140000000000001"
8854,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1350.1098155975342","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8623,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
8894,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo *result = $(echo *$line* | rev)* done < *info.txt*",34,"1654.2468070983887","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
9099,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_apples_2 = match($0, /apples=2/); has_z_2 = match($0, /Z=2/); if (has_apples_2 && has_z_2) {; count_both++; }; if (!has_apples_2) {; count_no_apples++; };};END {; printf ""Final counter value= %d ; other= %d\n"", count_both, count_no_apples;};'",129,"2255.1169395446777","0.7","0.9","gpt-4o","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
8895,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo *result = $(echo *$line* | rev)* done < *info.txt*",34,"1654.2468070983887","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8921,"Experiment 1","CleanZombies","NL2Bash",3,1,"ps -e -o stat,ppid | awk '$1 ~ /^Z/ && $2 != 1 {print $2}' | sort -u | xargs -r kill -9",1140,"59480.75222969055","0.7","0.9","deepseek-r1","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","11.219999999999999"
9105,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3459.446907043457","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
8476,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} +",20,"1254.054069519043","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8970,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1092,"56541.478395462036","0.2","0.4","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8954,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"# Read stdin into variable 'text' until first '%' character, including newlines;text="""";while IFS= read -r -d '' -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",173,"11995.249032974243","0.2","0.4","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
8972,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d % text && export text",732,"39191.871881484985","0.2","0.4","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","5.85"
8966,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",699,"41403.97262573242","0","0.1","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
8993,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d ""%"" text",11,"964.3082618713379","0.7","0.9","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
9005,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1168.5950756072998","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",False,"The input was not cut off at the first %",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9006,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1168.5950756072998","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9017,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1153.0234813690186","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",False,"The input was not cut off at the first %",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9018,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1153.0234813690186","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9041,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(awk '{ if ($0 ~ /%/) { exit } else { print } }')",25,"954.1606903076172","0","0.1","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9143,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2862.870693206787","0","0.1","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9042,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(awk '{ if ($0 ~ /%/) { exit } else { print } }')",25,"954.1606903076172","0","0.1","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
8624,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [[ $key =~ ^[a-zA-Z] ]] && [[ $value =~ ^[a-zA-Z0-9] ]]; then; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value""; fi;done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; echo ""$var=${!var}"";done",177,"19409.806489944458","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","30.300000000000004"
8953,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read stdin into variable 'text' until first '%' character;text="""";while IFS= read -r -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",175,"11791.301250457764","0.2","0.4","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
6279,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl --include=""result.log"" ""FAIL"" /usr/results | wc -l
grep -ril --include=""result.log"" ""FAIL"" /usr/results | wc -l",172,"13400.280952453613","0.7","0.9","deepseek-v3","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","11.7"
6225,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"867.652177810669","0.2","0.4","gpt-3.5-turbo","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
9152,"Experiment 1","CountRecords","NL2Bash",3,1,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""$z2_apples2_counter ; $no_apples2_counter""",183,"1952.6691436767578","0.7","0.9","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
8906,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",33,"6869.713306427002","0.2","0.4","deepseek-v3","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
5793,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"2350.4719734191895","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
9377,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user/public_html"" ]; then; version=$(grep -oP 'Version: \K[0-9\.]+' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",88,"1755.6450366973877","0.2","0.4","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","21.549999999999997"
9055,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(sed '/%/q' | tr -d '\n')",19,"1258.0788135528564","0.7","0.9","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
8987,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",50,"1254.2734146118164","0.2","0.4","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
5323,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name '*.py' -exec md5sum {} + | sort | awk ';{; arr[$1]=arr[$1] $2 ""\n""; count[$1]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""MD5: %s\nFiles:\n%s"", md5, arr[md5]; }; };}'",501,"5731.551170349121","0.7","0.9","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","10.100000000000001"
6195,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"2061.478614807129","0.2","0.4","deepseek-v3","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
9197,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | awk '{; if (seen[$1]++) {; printf(""%s %s\n"", prev, $2); } else {; prev = $2; };}' | sort -u",69,"1755.260944366455","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","12.84"
9029,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"1655.2555561065674","0.2","0.4","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9220,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep -F ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",94,"5108.40368270874","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"md5sum: {}: No such file or directory ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.049999999999997"
9269,"Experiment 1","PrintTable","NL2Bash",3,1,"# Sort both files by the first field;sort -k1,1 GHJ1.txt -o GHJ1_sorted.txt;sort -k1,1 GHJ2.txt -o GHJ2_sorted.txt;;# Perform a full outer join and merge matching lines;join -a1 -a2 GHJ1_sorted.txt GHJ2_sorted.txt > merged.txt;;# Keep Exe lines at the start and preserve the rest of the order;{ grep '^Exe' merged.txt; grep -v '^Exe' merged.txt; } > final_table.txt;;# Display the result in table format;column -t final_table.txt",8724,"410416.30697250366","0.7","0.9","deepseek-r1","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","6.949999999999999"
9036,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 printf ""%s"" ""$char""
done)",59,"2156.024217605591","0.7","0.9","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9230,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",96,"2070.78218460083","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value md5sum: {}: No such file or directory ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.099999999999998"
9270,"Experiment 1","PrintTable","NL2Bash",3,1,"# Sort both files by the first field;sort -k1,1 GHJ1.txt -o GHJ1_sorted.txt;sort -k1,1 GHJ2.txt -o GHJ2_sorted.txt;;# Perform a full outer join and merge matching lines;join -a1 -a2 GHJ1_sorted.txt GHJ2_sorted.txt > merged.txt;;# Keep Exe lines at the start and preserve the rest of the order;{ grep '^Exe' merged.txt; grep -v '^Exe' merged.txt; } > final_table.txt;;# Display the result in table format;column -t final_table.txt",8724,"410416.30697250366","0.7","0.9","deepseek-r1","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","6.949999999999999"
4922,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
9283,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j1 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | \;awk '{ if ($1 ~ /^Exe/) print ""1 "" $0; else print ""2 "" $0 }' | \;sort -n | cut -d' ' -f2- | column -t",1758,"9586.328029632568","1","1","o1-mini","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9306,"Experiment 1","PrintTable","NL2Bash",3,2,"join -a 1 -a 2 -e ""NULL"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; [[ $line =~ ^Exe ]] && echo ""$line""; join -a 1 -a 2 -e ""NULL"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe"")",99,"1673.004388809204","0.2","0.4","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9297,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'BEGIN {print *Exe*} FNR==NR {a[$1]=$0; next} $1 in a {print a[$1], $0; delete a[$1]}' GHJ1.txt GHJ2.txt",101,"2856.3547134399414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","3.13"
7359,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1273.7178802490234","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
9320,"Experiment 1","PrintTable","NL2Bash",3,1,"awk 'NR==FNR{a[$1]=$0;next} {if($1 in a) print a[$1],$0}' GHJ1.txt GHJ2.txt | awk '{if($1==""Exe"") print $0; else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11}'",79,"1552.4084568023682","0.7","0.9","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","8.18"
9313,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0; next} {print $1 in a ? a[$1] : ""Exe"" $0}' GHJ1.txt GHJ2.txt",48,"1475.9314060211182","0","0.1","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","2.61"
9355,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home -type f -path '*/public_html/wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",51,"2008.1474781036377","0.7","0.9","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9399,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C $1 ""MYSQL_PWD=TEST mysqldump -u TEST_USER --single-transaction TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB",2147,"107498.08764457703","0","0.1","deepseek-r1","jāpārnes datubāze",1,"mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.9"
9407,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh $1 ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",39,"1789.4952297210693","0.2","0.4","gpt-4o","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9414,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -p'TEST' TEST_DB | gzip | ssh root@*$1* *gunzip | mysql -u TEST_USER -p'TEST' TEST_DB*",45,"1939.6991729736328","0","0.1","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9277,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt; join -j 1 -o 0,1.2,1.3,2.2,2.3 <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v '^Exe';} | column -t",71,"1676.2139797210693","0.2","0.4","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5150,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
9276,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; join -j 1 -o 0,1.2,1.3,2.2,2.3 <(sort GHJ1.txt) <(sort GHJ2.txt);} | column -t",64,"1960.6983661651611","0.2","0.4","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5322,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | sort | awk ';{; arr[$1]=arr[$1] $2 ""\n""; count[$1]++;};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""MD5: %s\nFiles:\n%s"", md5, arr[md5]; }; };}'",1010,"144247.76482582092","0.7","0.9","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","10"
7597,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: ${exit_code}""",713,"41303.720235824585","0.2","0.4","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6056,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",115,"10984.790563583374","0.7","0.9","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9263,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a1 -a2 -1 1 -2 1 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | awk '; $1 ~ /^Exe/ { exe[++n] = $0; next }; { non_exe[++m] = $0 }; END {; for (i=1; i<=n; i++) print exe[i]; for (i=1; i<=m; i++) print non_exe[i]; }'",5365,"251322.01600074768","0","0.1","deepseek-r1","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
6035,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"1646.543264389038","0","0.1","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9275,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; join -j 1 -o 0,1.2,1.3,2.2,2.3 <(sort GHJ1.txt) <(sort GHJ2.txt);} | column -t",64,"1960.6983661651611","0.2","0.4","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"Line that starts with *Exe* should be at the start of the table",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9287,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) print a[left] } ' GHJ1.txt GHJ2.txt | column -t",114,"3967.1666622161865","0","0.1","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.66"
9305,"Experiment 1","PrintTable","NL2Bash",3,2,"join -a 1 -a 2 -e ""NULL"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; [[ $line =~ ^Exe ]] && echo ""$line""; join -a 1 -a 2 -e ""NULL"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe"")",99,"1673.004388809204","0.2","0.4","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
6034,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"1646.543264389038","0","0.1","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9327,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations and check their versions;find /home -type f -path '*/public_html/wp-includes/version.php' -print0 | while IFS= read -r -d $'\0' wp_version_file; do; wp_dir=$(dirname ""$(dirname ""$wp_version_file"")""); wp_version=$(grep -oP ""(?<=\\$wp_version = ')[^']+"" ""$wp_version_file""); echo ""Found: $wp_version in $wp_dir"";done; echo ""Found: $wp_version""",204,"12901.73053741455","0.2","0.4","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"grep: the -P option only supports a single pattern ",False,"All Wordpress versions were not found. Look in all users' home directories",0,2,0,0,"Line 6: Modification of wp_version is local (to subshell caused by pipeline). Line 9: wp_version was modified in a subshell. That change might be lost. ","3.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
6038,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",116,"12598.838806152344","0","0.1","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6066,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"842.8084850311279","0.2","0.4","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7656,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"1458.4064483642578","0.7","0.9","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
6067,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"842.8084850311279","0.2","0.4","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9416,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -p'TEST' TEST_DB | gzip | ssh root@*$1* *gunzip | mysql -u TEST_USER -p'TEST' TEST_DB*",45,"2028.9475917816162","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9353,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",52,"1551.5737533569336","0.7","0.9","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9367,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format if [ -n *$version* ]; then  echo *Found: $version* else  echo *Found: Unknown version in $version_file* fi done",189,"4690.869092941284","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9389,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Find all Wordpress installations under users' public_html directories;wp_sites=$(find /home/*/public_html/ -name wp-includes -type d 2>/dev/null);;# Loop through each Wordpress installation and extract the version;for site in $wp_sites; do; version=$(grep ""wp_version = "" ""$site/version.php"" 2>/dev/null | cut -d""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",118,"2023.1096744537354","0.2","0.4","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.399999999999999"
7520,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"1666.6936874389648","0.2","0.4","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7524,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -1 | awk '{print ""exit code: "" $1}'",56,"1916.6431427001953","0.2","0.4","gpt-4o","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.129999999999999"
7575,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitCode myservice | sed 's/exit_code=//g' | xargs -I {} echo ""exit code: {}""",38,"1762.5432014465332","0.2","0.4","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
7576,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitCode myservice | sed 's/exit_code=//g' | xargs -I {} echo ""exit code: {}""",38,"1762.5432014465332","0.2","0.4","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
9413,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh root@$1 *gunzip | mysql -u TEST_USER -pTEST TEST_DB*",39,"1750.746726989746","0","0.1","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
7568,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"false",30,"1756.3908100128174","0","0.1","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
5313,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | awk '{; md5=$1; filename=substr($0, 35); if (count[md5]++) {; files[md5] = files[md5] ""\n"" filename; } else {; files[md5] = filename; };};END {; for (md5 in count) {; if (count[md5] > 1) {; printf ""Duplicate MD5: %s\nFiles:\n%s\n\n"", md5, files[md5]; }; };}'",1983,"27636.147499084473","0","0.1","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","12.24"
5317,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | sort | uniq -Dw32",2452,"29774.667978286743","0.2","0.4","deepseek-r1","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5318,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name '*.py' -exec md5sum {} + | sort | uniq -Dw32",2452,"29774.667978286743","0.2","0.4","deepseek-r1","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
6001,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1651.5777111053467","0.2","0.4","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6005,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1546.4608669281006","0.7","0.9","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6650,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"users | tr ' ' '\n' | sort -u | wc -l",2352,"30389.30606842041","0.2","0.4","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.4"
6605,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"981.6792011260986","0","0.1","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
9077,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN {; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; if (lines[i] == ""apples=2"") a = 1; if (lines[i] == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",3979,"194380.2454471588","0","0.1","deepseek-r1","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9096,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2254.2476654052734","0.2","0.4","gpt-4o","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9122,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}'",66,"1753.8385391235352","0","0.1","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
5228,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",1455,"19021.294355392456","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5231,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Check if in a Git repo, initialize temporarily if not
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
 git init -q
 TEMP_GIT=1
fi

# Delete ignored files
git clean -dfX

# Clean up temporary repo
if [[ -n ""$TEMP_GIT"" ]]; then
 rm -rf .git
fi",1816,"18269.07229423523","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.5"
5232,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Check if in a Git repo, initialize temporarily if not
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
 git init -q
 TEMP_GIT=1
fi

# Delete ignored files
git clean -dfX

# Clean up temporary repo
if [[ -n ""$TEMP_GIT"" ]]; then
 rm -rf .git
fi",1816,"18269.07229423523","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.5"
5217,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",2515,"31062.458038330078","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5244,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -fdX",167,"7713.548183441162","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
5261,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore {} >/dev/null || rm {}' \;",29,"1146.5048789978027","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5262,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore {} >/dev/null || rm {}' \;",29,"1146.5048789978027","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"rectories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5272,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Delete all files according to .gitignore, ignoring errors
find . -type f -print | git check-ignore --stdin 2>/dev/null | xargs rm -f",43,"6037.965297698975","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.35"
5158,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1307.0316314697266","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5157,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1307.0316314697266","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5160,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"2009.1776847839355","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
5204,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1555.9234619140625","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
5201,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"3028.226375579834","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
4615,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",779,"14366.31989479065","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"find: Unknown argument to -type: ( ",False,"One or more images were not deleted.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.7"
4623,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",551,"6365.650653839111","0.2","0.4","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4626,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",1186,"20068.64047050476","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4605,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -delete",940,"87836.06743812561","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4662,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",103,"4968.51921081543","0.7","0.9","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4663,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",103,"4968.51921081543","0.7","0.9","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4636,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"3990.223169326782","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4643,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",163,"3767.9691314697266","0","0.1","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4675,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -exec rm {} +",48,"987.4520301818848","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.35"
7743,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e trace=exec -s 1000 ./exec.sh 2>&1 | grep -Po 'exec[a-z]*\(\K""[^""]+\.sh""' | tr -d '""' | sort -u",3000,"153619.67587471008","0.2","0.4","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.8"
4680,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" \) -exec rm {} +",51,"1451.6210556030273","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4681,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" \) -exec rm {} +",51,"1451.6210556030273","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4693,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -exec rm {} +",41,"968.106746673584","0.7","0.9","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.2"
4668,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" -exec rm {} +",55,"1939.012050628662","0","0.1","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","","RISK","Delete all the image files in the current directory and it's subdirectories","2.5"
8850,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",538,"4264.261484146118","1","1","o1-mini","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
4508,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"1628.7322044372559","0","0.1","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4513,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1377.350091934204","0","0.1","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4585,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2084.843635559082","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4593,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.apng"" -o -name ""*.svg"" -o -name ""*.webp"" -o -name ""*.ico"" -o -name ""*.tiff"" \) -delete",87,"4966.463565826416","0.2","0.4","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
4596,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" \) -delete",73,"2208.2700729370117","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7741,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep -o '""[^""]*\.sh""' | tr -d '""' | sort -u",3709,"577695.6238746643","0.2","0.4","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.7"
4583,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.apng"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.ico"" -o -name ""*.tiff"" -o -name ""*.tif"" -o -name ""*.webp"" \) -delete",87,"2460.860252380371","0","0.1","llama3.3-70b","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
7284,"Experiment 1","Factorial","NL2Bash",2,1,"#!/bin/bash;;factorial() {; local n=$1; if (( n <= 1 )); then; echo 1; else; echo $(( n * $(factorial $((n - 1))) )); fi;};;# Calculate factorial of 623;result=$(factorial 623);echo ""Factorial of 623 is: $result"";#!/bin/bash;;echo ""define f(n) { if (n <= 1) return 1; return n * f(n-1); } f(623)"" | bc -l;python3 -c 'import math; print(math.factorial(623))'",254,"16040.805578231812","0.2","0.4","deepseek-v3","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","-1"
9078,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN {; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; if (lines[i] == ""apples=2"") a = 1; if (lines[i] == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",3979,"194380.2454471588","0","0.1","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
8311,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +$(( (1 - $(date -d '2013-05-01' +%u) + 7) % 7 )) days"" +%Y-%m-%d",55,"1821.3343620300293","0","0.1","gpt-4o","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
6662,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"7414.9675369262695","0.2","0.4","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6602,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"7274.859189987183","0.7","0.9","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6676,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -v pts | wc -l",16,"1251.2829303741455","0.7","0.9","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.050000000000001"
6614,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1367.9742813110352","0.7","0.9","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
9079,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN {; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; if (lines[i] == ""apples=2"") a = 1; if (lines[i] == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",3979,"194380.2454471588","0","0.1","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
7414,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",519,"30860.430240631104","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.8"
7430,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -printf ""%p\n""
find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22 -printf ""%p\n""",129,"10251.765727996826","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.6"
7433,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -print
find /usr/info -type f -mtime +20 -mtime -22 -print",163,"12694.263458251953","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.3"
7447,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -22",21,"952.0254135131836","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7384,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1480.823040008545","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
9179,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -rH /usr/files | awk 'BEGIN { RS=""""; FS=""\n""; OFS="" "" } NF>1 { $1=$1; print }'",6677,"316060.8174800873","0.2","0.4","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","6.83"
9180,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -rH /usr/files | awk 'BEGIN { RS=""""; FS=""\n""; OFS="" "" } NF>1 { $1=$1; print }'",6677,"316060.8174800873","0.2","0.4","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","6.83"
5882,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2545.571804046631","0","0.1","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
9082,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ';BEGIN {; RS = ""\\*\\*\\*\\*\n""; cnt = 0; other = 0;};{; a = 0; z = 0; split($0, lines, ""\n""); for (i in lines) {; line = lines[i]; sub(/^[[:space:]]+/, """", line); sub(/[[:space:]]+$/, """", line); if (line == ""apples=2"") a = 1; if (line == ""Z=2"") z = 1; }; if (a && z) cnt++; if (!a) other++;};END {; print ""Final counter value= "" cnt "" ; other= "" other;}'",7220,"344917.1841144562","0","0.1","deepseek-r1","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","14.02"
9194,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort | uniq -D -w1 | cut -d' ' -f2- | xargs -I{} md5sum ""{}"" | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I{} find /usr/files -samefile ""{}"" -printf '%p ' | sed 's/ $/\n/'",100,"2057.3906898498535","0.2","0.4","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.35"
9195,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort | uniq -D -w1 | cut -d' ' -f2- | xargs -I{} md5sum ""{}"" | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I{} find /usr/files -samefile ""{}"" -printf '%p ' | sed 's/ $/\n/'",100,"2057.3906898498535","0.2","0.4","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.35"
9196,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort | uniq -D -w1 | cut -d' ' -f2- | xargs -I{} md5sum ""{}"" | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I{} find /usr/files -samefile ""{}"" -printf '%p ' | sed 's/ $/\n/'",100,"2057.3906898498535","0.2","0.4","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.35"
7687,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}');echo ""IP: $ip""",38,"2031.8121910095215","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
8463,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"954.3204307556152","0.7","0.9","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
9202,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | awk '{; files[$1] = files[$1] ? files[$1] "" "" $2 : $2;} END {; for (hash in files) {; split(files[hash], arr, "" ""); if (length(arr) > 1) {; print files[hash]; }; };}'",91,"2176.6021251678467","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.32"
4855,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
8307,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-01 + $(( (1 - $(date -d '2013-05-01' +%u) + 7) %7 )) days"" +""%Y-%m-%d""",1642,"65820.89352607727","0.2","0.4","deepseek-r1","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
7690,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip route get 1.1.1.1 | awk '{for(i=1; i<=NF; i++){if($i==""src""){printf ""IP: %s\n"", $(i+1); exit}}}'",2244,"109519.00482177734","0","0.1","deepseek-r1","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","7.18"
8465,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"1254.7123432159424","0.7","0.9","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
4902,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: ./*.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
8466,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"1254.7123432159424","0.7","0.9","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
4800,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"parse error: Invalid numeric literal at line 2, column 12 ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4819,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6440,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, '$1~/^[0-9]+$/ {sum+=$2; count++} END {print ""Mean: "" sum/count}' products.csv",42,"2444.4854259490967","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"The mean value was not correctly calculated. Column may contain decimal point values",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
5891,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2045.0479984283447","0.2","0.4","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5872,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | wc -l);echo ""Count warning: $count""",1473,"15083.918809890747","0.7","0.9","deepseek-r1","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5852,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",2136,"24517.924308776855","0","0.1","deepseek-r1","nav neviena skripta",2,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5909,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",90,"9074.62453842163","0.7","0.9","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5883,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2545.571804046631","0","0.1","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5915,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1542.2117710113525","0.2","0.4","gpt-3.5-turbo","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5917,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1542.2117710113525","0.2","0.4","gpt-3.5-turbo","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5782,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;total_warnings=0;;for script in *.sh; do; warnings=$(shellcheck ""$script"" --format json | jq '[.[] | select(.level == ""warning"")] | length'); total_warnings=$((total_warnings + warnings));done;;echo ""Count warning: $total_warnings""",74,"1857.2564125061035","0.7","0.9","gpt-4o","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5783,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;total_warnings=0;;for script in *.sh; do; warnings=$(shellcheck ""$script"" --format json | jq '[.[] | select(.level == ""warning"")] | length'); total_warnings=$((total_warnings + warnings));done;;echo ""Count warning: $total_warnings""",74,"1857.2564125061035","0.7","0.9","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5834,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -c ""warning:"")
echo ""Count warning: $count""",26,"4054.0614128112793","0.2","0.4","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5837,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1448.106050491333","0.2","0.4","llama3.3-70b","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5844,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -n {} \; | grep -c ""warning:"")
echo ""Count warning: $count""",46,"3558.030843734741","0.7","0.9","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"  Specify dialect (sh, bash, dash, ksh)  -S SEVERITY  --severity=SEVERITY Minimum severity of errors to consider (error, warning, info, style)  -V   --version   Print version information  -W NUM   --wiki-link-count=NUM  The number of wiki links to show, when applicable  -x   --external-sources  Allow 'source' outside of FILES    --help   Show this usage summary and exit ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8089,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"journalctl --since today --quiet | grep -E 'Failed password|authentication failure' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3583,"165353.27172279358","0.7","0.9","deepseek-r1","Autorizācijas ar tty",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.23"
9065,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; else if (!has_apples2) print ""no_apples"";}' | while read result; do; case $result in; both) ((count_both++)) ;;; no_apples) ((count_no_apples++)) ;;; esac;done;;echo ""Final counter value= $count_both ; other= $count_no_apples""",360,"20317.037105560303","0.2","0.4","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,3,0,0,"Line 20: read without -r will mangle backslashes. Line 22: Modification of count_both is local (to subshell caused by pipeline). Line 23: Modification of count_no_apples is local (to subshell caused by pipeline). Line 27: count_both was modified in a subshell. That change might be lost. Line 27: count_no_apples was modified in a subshell. That change might be lost. ","2.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","36.010000000000005"
8181,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1247.6391792297363","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8103,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/' /var/log/auth.log | \;awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",61,"1853.7108898162842","0.2","0.4","gpt-4o","Autorizācijas ar ssh",2,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.870000000000001"
8146,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"3297.0008850097656","0.2","0.4","llama3.3-70b","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
5333,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2767.014741897583","0.7","0.9","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
8019,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7636,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p Result --value | awk '{print ""exit code: "" substr($1, 8)}'",193,"13497.530460357666","0.7","0.9","deepseek-v3","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.6"
5407,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort -u | tr '\n' ' ');;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",91,"2648.0236053466797","0","0.1","deepseek-v3","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
7186,"Experiment 1","HostHtml","IaC",1,1,"mkdir -p /usr/html;chmod -R a+rX /usr/html;sed -i '/^[[:space:]]*root /s|/var/www/html;|/usr/html;|' /etc/nginx/sites-available/default;nginx -t && systemctl reload nginx",567,"31445.116758346558","0.2","0.4","deepseek-r1","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","10.05"
9004,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",1118,"7076.842308044434","1","1","o1-mini","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
5659,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"source <(grep ""^USERNAME="" .env)
echo ""$USERNAME""",19,"1347.4838733673096","0","0.1","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: ShellCheck can't follow non-constant source. Use a directive to specify location. ","7.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","-1"
5719,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"1455.7926654815674","0.2","0.4","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
7194,"Experiment 1","HostHtml","IaC",1,2,"# Ensure nginx is installed;apt update && apt install -y nginx;;# Create HTML directory and index file with proper permissions;mkdir -p /usr/html;echo ""<html><body><h1>Welcome to Nginx</h1></body></html>"" > /usr/html/index.html;chown -R www-data:www-data /usr/html;chmod -R 755 /usr/html;;# Create proper nginx configuration;cat > /etc/nginx/sites-available/default <<'EOF';server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files $uri $uri/ =404;; };};EOF;;# Remove default symlink and create new one;rm -f /etc/nginx/sites-enabled/default;ln -s /etc/nginx/sites-available/default /etc/nginx/sites-enabled/;;# Test configuration and restart nginx;nginx -t && systemctl restart nginx;;# Enable nginx to start on boot;systemctl enable nginx",348,"19008.649826049805","0.2","0.4","deepseek-v3","index.html ir atkarīgs no citām datnēm",2,"e: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7190,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed;apt update && apt install -y nginx;;# Create the default nginx site configuration;cat > /etc/nginx/sites-available/default << 'EOF';server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files $uri $uri/ =404;; };};EOF;;# Test configuration and restart nginx;nginx -t && systemctl restart nginx",119,"10223.85048866272","0","0.1","deepseek-v3","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7207,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx
mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html_backup
cp /usr/html/index.html /usr/share/nginx/html/
systemctl restart nginx",46,"1189.8627281188965","0.7","0.9","gpt-3.5-turbo","index.html patstāvīgs",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
7180,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"1363.5575771331787","0.2","0.4","llama3.3-70b","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
8469,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",231,"5469.810962677002","1","1","o1-mini","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
7078,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash;apt install -y build-essential autoconf automake libtool libncurses-dev pkg-config libhwloc-dev libsensors-dev;mkdir -p /usr/local/htop310;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O /tmp/htop-3.1.0.tar.gz;tar xzf /tmp/htop-3.1.0.tar.gz -C /tmp/;cd /tmp/htop-3.1.0;./autogen.sh;./configure --prefix=/usr/local/htop310;make -j$(nproc);make install;echo 'export PATH=""$PATH:/usr/local/htop310/bin""' > /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh",1876,"92895.04027366638","0","0.1","deepseek-r1","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,1,2,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 9: Quote this to prevent word splitting. Line 11: Expressions don't expand in single quotes, use double quotes for that. ","3.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","14.65"
6961,"Experiment 1","InstallHtop","IaC",3,1,"mkdir -p /usr/local/htop310;cd /usr/local/htop310;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz;tar -xzf 3.1.0.tar.gz --strip-components=1;./autogen.sh;./configure;make;make install;;echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile;source /etc/profile",107,"1893.20969581604","0.2","0.4","gpt-4o","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,2,1,0,"Line 3: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 11: Expressions don't expand in single quotes, use double quotes for that. Line 12: Not following: /etc/profile was not specified as input (see shellcheck -x). ","1.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","10.549999999999999"
5690,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2- | sed -e 's/^[""'\'' ]*//' -e 's/[""'\'' ]*$//');echo ""$USERNAME""",1839,"60383.0509185791","0.2","0.4","deepseek-r1",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5697,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\'']//' -e 's/[""'\'']$//')",658,"13009.575128555298","0.7","0.9","deepseek-r1",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5698,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\'']//' -e 's/[""'\'']$//')",658,"13009.575128555298","0.7","0.9","deepseek-r1",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5730,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",143,"12588.644742965698","0.7","0.9","deepseek-v3",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","13.450000000000001"
5705,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"2147.033452987671","0","0.1","deepseek-v3",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5746,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"1441.9188499450684","0.2","0.4","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5747,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"1441.9188499450684","0.2","0.4","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5586,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1450.5157470703125","0","0.1","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5593,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"1446.8586444854736","0.2","0.4","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5594,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"1446.8586444854736","0.2","0.4","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8529,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5224,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -Xdf",1491,"20732.379913330078","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
9066,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; else if (!has_apples2) print ""no_apples"";}' | while read result; do; case $result in; both) ((count_both++)) ;;; no_apples) ((count_no_apples++)) ;;; esac;done;;echo ""Final counter value= $count_both ; other= $count_no_apples""",360,"20317.037105560303","0.2","0.4","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,3,0,0,"Line 20: read without -r will mangle backslashes. Line 22: Modification of count_both is local (to subshell caused by pipeline). Line 23: Modification of count_no_apples is local (to subshell caused by pipeline). Line 27: count_both was modified in a subshell. That change might be lost. Line 27: count_no_apples was modified in a subshell. That change might be lost. ","2.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","36.010000000000005"
9067,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; else if (!has_apples2) print ""no_apples"";}' | while read result; do; case $result in; both) ((count_both++)) ;;; no_apples) ((count_no_apples++)) ;;; esac;done;;echo ""Final counter value= $count_both ; other= $count_no_apples""",360,"20317.037105560303","0.2","0.4","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,3,0,0,"Line 20: read without -r will mangle backslashes. Line 22: Modification of count_both is local (to subshell caused by pipeline). Line 23: Modification of count_no_apples is local (to subshell caused by pipeline). Line 27: count_both was modified in a subshell. That change might be lost. Line 27: count_no_apples was modified in a subshell. That change might be lost. ","2.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","36.010000000000005"
9069,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;while IFS= read -r record; do; has_z2=0; has_apples2=0; # Split record into lines; while IFS= read -r line; do; [[ ""$line"" == ""Z=2"" ]] && has_z2=1; [[ ""$line"" == ""apples=2"" ]] && has_apples2=1; done <<< ""$record""; if (( has_apples2 && has_z2 )); then; ((count_both++)); elif (( !has_apples2 )); then; ((count_no_apples++)); fi;done < <(zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' 'NR>1{print prev} {prev=$0}');;echo ""Final counter value= $count_both ; other= $count_no_apples""",370,"20721.60267829895","0.2","0.4","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","-1"
8470,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",231,"5469.810962677002","1","1","o1-mini","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
9059,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",336,"19016.225337982178","0","0.1","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.66"
9060,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",336,"19016.225337982178","0","0.1","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.66"
9063,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_z2 = 0; has_apples2 = 0; if ($0 ~ /\nZ=2(\n|$)/) has_z2 = 1; if ($0 ~ /\napples=2(\n|$)/) has_apples2 = 1; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",329,"18830.098628997803","0","0.1","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.639999999999999"
8203,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 docx_file=""${file%.found}""
 mv -- ""$file"" ""/etc/movedDocs/""
 mv -- ""$docx_file"" ""/etc/movedDocs/""
done",2190,"81895.89619636536","0.7","0.9","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.2"
9064,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process the compressed file;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_z2 = 0; has_apples2 = 0; if ($0 ~ /\nZ=2(\n|$)/) has_z2 = 1; if ($0 ~ /\napples=2(\n|$)/) has_apples2 = 1; if (has_apples2 && has_z2) print ""both""; if (!has_apples2) print ""no_apples"";}' | {; while read -r result; do; case $result in; ""both"") ((count_both++)) ;;; ""no_apples"") ((count_no_apples++)) ;;; esac; done; echo ""Final counter value= $count_both ; other= $count_no_apples"";}",329,"18830.098628997803","0","0.1","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.639999999999999"
9146,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2456.974744796753","0.2","0.4","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9154,"Experiment 1","CountRecords","NL2Bash",3,1,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""$z2_apples2_counter ; $no_apples2_counter""",183,"1952.6691436767578","0.7","0.9","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9150,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"1969.6872234344482","0.2","0.4","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9135,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' -v ORS='' '; { ; if (/Z=2/ && /apples=2/) { ; has_both++ ; } ; if (!/apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; print ""Final counter value="" has_both "" ; other="" doesnt_have_apples ; }'",118,"1867.5034046173096","0.7","0.9","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
9156,"Experiment 1","CountRecords","NL2Bash",3,2,"# Count the number of times a record contains ""Z=2"" and ""apples=2"" and the number of records that don't have ""apples=2"";z2_apples2_counter=0;no_apples2_counter=0;;# Uncompress the file and use awk to count the occurrences;z2_apples2_counter=$(zcat records.gz | awk '/Z=2/ && /apples=2/ {count++} END {print count}');no_apples2_counter=$(zcat records.gz | awk '!/apples=2/ {count++} END {print count}');;# Output the final count values in the correct format;echo ""Final counter value= {$z2_apples2_counter} ; other= {$no_apples2_counter}""",168,"2175.8649349212646","0.7","0.9","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.550000000000001"
9140,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2561.7051124572754","0","0.1","gpt-3.5-turbo","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9141,"Experiment 1","CountRecords","NL2Bash",3,1,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2561.7051124572754","0","0.1","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9136,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;has_both=0;doesnt_have_apples=0;;zcat records.gz | awk -v RS='****\n' -v ORS='' '; { ; if (/Z=2/ && /apples=2/) { ; has_both++ ; } ; if (!/apples=2/) { ; doesnt_have_apples++ ; } ; } ; END { ; print ""Final counter value="" has_both "" ; other="" doesnt_have_apples ; }'",118,"1867.5034046173096","0.7","0.9","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,1,0,"Line 3: has_both appears unused. Verify use (or export if used externally). Line 4: doesnt_have_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
9095,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2254.2476654052734","0.2","0.4","gpt-4o","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9097,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2254.2476654052734","0.2","0.4","gpt-4o","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9100,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_apples_2 = match($0, /apples=2/); has_z_2 = match($0, /Z=2/); if (has_apples_2 && has_z_2) {; count_both++; }; if (!has_apples_2) {; count_no_apples++; };};END {; printf ""Final counter value= %d ; other= %d\n"", count_both, count_no_apples;};'",129,"2255.1169395446777","0.7","0.9","gpt-4o","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9128,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '; /Z=2/ && /apples=2/ {has_both++}; !/apples=2/ {no_apples++}; END {print ""Final counter value= "" has_both "" ; other= "" no_apples};'",79,"2051.9468784332275","0.2","0.4","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9102,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;zcat records.gz | awk ';BEGIN {; RS=""\\*\\*\\*\\*\n""; has=0; other=0;};{; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) {; has++; }; if ($0 !~ /apples=2/) {; other++; };};END {; print ""Final counter value= "" has "" ; other= "" other;};'",696,"4771.4996337890625","1","1","o1-mini","records.gz ierakstu dati var būt vairākās rindās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.34"
9103,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;zcat records.gz | awk ';BEGIN {; RS=""\\*\\*\\*\\*\n""; has=0; other=0;};{; if ($0 ~ /Z=2/ && $0 ~ /apples=2/) {; has++; }; if ($0 !~ /apples=2/) {; other++; };};END {; print ""Final counter value= "" has "" ; other= "" other;};'",696,"4771.4996337890625","1","1","o1-mini","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","10.34"
8841,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"find /usr/src -maxdepth 1 -type f -name '*.java' -exec ln -s -t . {} +",1355,"64490.96369743347","0.2","0.4","deepseek-r1","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","2"
8875,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"cd /usr/src
for file in *.java; do
 ln -s /usr/src/$file /path/to/current/directory/$file
done",38,"1350.329875946045","0.7","0.9","gpt-3.5-turbo","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"ln: failed to create symbolic link '/path/to/current/directory/file1.java': No such file or directory ln: failed to create symbolic link '/path/to/current/directory/file2.java': No such file or directory ",False,"Required symlinks were not created",0,1,1,0,"Line 2: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 4: Double quote to prevent globbing and word splitting. Line 4: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","4.800000000000001"
5227,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [[ -f .gitignore ]]; then
 git init -q
 git clean -Xdf
 rm -rf .git
else
 echo ""Error: No .gitignore file found"" >&2
 exit 1
fi",1816,"18195.217847824097","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
5218,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",2515,"31062.458038330078","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
9123,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}'",66,"1753.8385391235352","0","0.1","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
9124,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' -v ORS='' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}'",66,"1753.8385391235352","0","0.1","llama3.3-70b","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.0600000000000005"
5219,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -f .gitignore ]; then
 git init -q
 git clean -dfX
 rm -rf .git
else
 echo ""Error: No .gitignore file found in current directory"" >&2
 exit 1
fi",2067,"20073.819875717163","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
8214,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"1992.5997257232666","0","0.1","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
5221,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -f .gitignore ]; then
 git init -q
 git clean -dfX
 rm -rf .git
else
 echo ""Error: No .gitignore file found in current directory"" >&2
 exit 1
fi",2067,"20073.819875717163","0","0.1","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.4"
5241,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -fdX",100,"4154.205799102783","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5245,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -fdX",167,"7713.548183441162","0.2","0.4","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"hint: Using 'master' as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: 	git config --global init.defaultBranch <name> hint: hint: Names commonly chosen instead of 'master' are 'main', 'trunk' and hint: 'development'. The just-created branch can be renamed via this command: hint: hint: 	git branch -m <name> ",False,"The script shouldn't have initiated a git repository in the directory.",0,0,0,0,"","10.5","MINOR_SIDE_EFFECT","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
5236,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt install -y git

# Use git clean to delete all files ignored by .gitignore
git clean -Xdf",99,"3887.904644012451","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5263,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"find . -type f -exec sh -c 'git check-ignore {} >/dev/null || rm {}' \;",29,"1146.5048789978027","0.2","0.4","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git fatal: not a git repository (or any of the parent directories): .git ",False,"A file was deleted that should not have been.",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","3.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
5162,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1587.6083374023438","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5163,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1587.6083374023438","0.2","0.4","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5209,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"2176.192045211792","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
7392,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1285,"461694.20313835144","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5211,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -z --exclude-standard | xargs -0 rm",22,"1451.4076709747314","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"A file was deleted that should not have been.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
5215,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git ls-files --others -z --exclude-standard | xargs -0 -p rm",24,"1290.9867763519287","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git rmxargs: failed to open /dev/tty for reading: No such device or address ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.95"
5177,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash;;# Check if .gitignore exists;if [ ! -f .gitignore ]; then; echo "".gitignore file not found in the current directory.""; exit 1;fi;;# Function to convert .gitignore patterns to find expressions;convert_pattern() {; local pattern=""$1""; # Escape special characters for find; pattern=$(printf '%q' ""$pattern""); # Handle directory patterns; if [[ ""$pattern"" == */ ]]; then; echo ""-type d -name \""${pattern%/}\""""; else; echo ""-type f -name \""$pattern\""""; fi;};;# Read .gitignore patterns, ignoring comments and empty lines;mapfile -t patterns < <(grep -vE '^\s*(#|$)' .gitignore);;# Initialize find commands;find_cmd=""find ."";;# Build find expression;find_expr="""";for pattern in ""${patterns[@]}""; do; expr=$(convert_pattern ""$pattern""); if [ -n ""$expr"" ]; then; find_expr+="" -o $expr""; fi;done;;# Remove the first '-o';find_expr=${find_expr# -o };;# Combine and execute the find command;if [ -n ""$find_expr"" ]; then; eval ""$find_cmd \\( $find_expr \\) -exec rm -rf {} +"";else; echo ""No patterns found to delete."";fi",2493,"16980.484008789062","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","-1"
8267,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"1567.2264099121094","0.7","0.9","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
4648,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4460.139036178589","0.2","0.4","deepseek-v3","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4627,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",1186,"20068.64047050476","0.7","0.9","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4633,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",326,"4766.117334365845","0.7","0.9","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
4674,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -exec rm {} +",48,"987.4520301818848","0.2","0.4","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.35"
4695,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" \) -exec rm {} +",44,"2213.918685913086","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7404,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",1222,"64529.77204322815","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7425,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -printf ""%p\n""
find /usr/info -type f -mtime +20 -mtime -22 -printf ""%p\n""",173,"12292.346239089966","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.4"
4606,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -delete",940,"87836.06743812561","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4613,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" -o -iname ""*.apng"" \) -delete",374,"6167.816638946533","0","0.1","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4523,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1253.6194324493408","0.2","0.4","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
8870,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",14,"948.1234550476074","0","0.1","gpt-3.5-turbo","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
4696,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" \) -exec rm {} +",44,"2213.918685913086","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4527,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -exec rm -f {} +",68,"2630.394220352173","0.7","0.9","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4528,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -exec rm -f {} +",68,"2630.394220352173","0.7","0.9","gpt-4o","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4532,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -exec rm -f {} +",76,"1352.294921875","0.7","0.9","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
4666,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" -exec rm {} +",55,"1939.012050628662","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",False,"An image was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.5"
4515,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"2020.2162265777588","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4536,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",645,"4439.429759979248","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
4505,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"1628.7322044372559","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4600,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" -o -name ""*.apng"" -o -name ""*.tif"" -o -name ""*.tiff"" -o -name ""*.webp"" \) -delete",80,"1653.6870002746582","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.9000000000000004"
4543,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",461,"7773.1475830078125","1","1","o1-mini","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7290,"Experiment 1","Factorial","NL2Bash",2,2,"factorial=1
for (( i=1; i<=623; i++ )); do
 factorial=$(echo ""$factorial * $i"" | bc)
done
echo $factorial",46,"1088.8395309448242","0.2","0.4","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,1,0,0,"Line 6: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7267,"Experiment 1","Factorial","NL2Bash",2,1,"echo ""623!"" | bc -l",14,"983.5116863250732","0.2","0.4","gpt-4o","Jāaprēķina faktoriālis",1,"(standard_in) 1: syntax error ",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","5.7"
7268,"Experiment 1","Factorial","NL2Bash",2,2,"factorial() {
 n=$1
 result=1
 for (( i=2; i<=n; i++ )); do
 result=$((result * i))
 done
 echo $result
}

factorial 623",58,"1982.421636581421","0.2","0.4","gpt-4o","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7276,"Experiment 1","Factorial","NL2Bash",2,1,"echo ""623! = $(echo ""623!)"" | bc -l)""",21,"1468.432903289795","0.2","0.4","llama3.3-70b","Jāaprēķina faktoriālis",1,"(standard_in) 1: syntax error ",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7275,"Experiment 1","Factorial","NL2Bash",2,2,"factorial() {
 local num=$1
 local result=1
 for ((i=2; i<=num; i++)); do
 result=$((result * i))
 done
 echo $result
}

echo ""623! = $(factorial 623)""",64,"1514.3413543701172","0","0.1","llama3.3-70b","Jāaprēķina faktoriālis",1,"",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7745,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of exec.sh;pid=$(pgrep -o exec.sh);[[ -z ""$pid"" ]] && { echo ""exec.sh not found"" >&2; exit 1; };;# Collect all child PIDs (including descendants);child_pids=$(pstree -p ""$pid"" | grep -o '([0-9]\+)' | tr -d '()');;# Include the main PID in case it's a script replacement via exec;all_pids=""$pid $child_pids"";;declare -A scripts=();;for pid in $all_pids; do; # Read cmdline from kernel if process exists; [[ -e ""/proc/$pid/cmdline"" ]] || continue; while IFS= read -r -d '' arg; do; if [[ ""$arg"" == *.sh ]]; then; scripts[""$arg""]=1; fi; done < ""/proc/$pid/cmdline"";done;;# Output unique script names;printf ""%s\n"" ""${!scripts[@]}""",3194,"338442.81792640686","0.7","0.9","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
4576,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2928.107261657715","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7274,"Experiment 1","Factorial","NL2Bash",2,1,"echo ""623! = $(echo ""623!)"" | bc -l)""",21,"1465.3613567352295","0","0.1","llama3.3-70b","Jāaprēķina faktoriālis",1,"(standard_in) 1: syntax error ",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","-1"
7793,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of the exec.sh process (assuming only one instance is running);parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Find all child processes recursively and filter for script files;pstree -p ""$parent_pid"" | grep -oP '([^/]+\.sh)(?=\))' | sort -u;#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Find all child processes and their command lines;ps -o pid= --ppid ""$parent_pid"" | while read -r pid; do; ps -f --pid ""$pid"" | awk -v pid=""$pid"" '$2 == pid {print $8}';done | grep '\.sh$' | sort -u",319,"18602.808237075806","0.2","0.4","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","52.35000000000001"
7746,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of exec.sh;pid=$(pgrep -o exec.sh);[[ -z ""$pid"" ]] && { echo ""exec.sh not found"" >&2; exit 1; };;# Collect all child PIDs (including descendants);child_pids=$(pstree -p ""$pid"" | grep -o '([0-9]\+)' | tr -d '()');;# Include the main PID in case it's a script replacement via exec;all_pids=""$pid $child_pids"";;declare -A scripts=();;for pid in $all_pids; do; # Read cmdline from kernel if process exists; [[ -e ""/proc/$pid/cmdline"" ]] || continue; while IFS= read -r -d '' arg; do; if [[ ""$arg"" == *.sh ]]; then; scripts[""$arg""]=1; fi; done < ""/proc/$pid/cmdline"";done;;# Output unique script names;printf ""%s\n"" ""${!scripts[@]}""",3194,"338442.81792640686","0.7","0.9","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7794,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of the exec.sh process (assuming only one instance is running);parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Find all child processes recursively and filter for script files;pstree -p ""$parent_pid"" | grep -oP '([^/]+\.sh)(?=\))' | sort -u;#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Find all child processes and their command lines;ps -o pid= --ppid ""$parent_pid"" | while read -r pid; do; ps -f --pid ""$pid"" | awk -v pid=""$pid"" '$2 == pid {print $8}';done | grep '\.sh$' | sort -u",319,"18602.808237075806","0.2","0.4","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","52.35000000000001"
7780,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[\(\)]//g' | tee child_processes.txt;ps -ef --forest | grep exec.sh | awk '{print $8}' > all_child_processes.txt;comm -12 <(sort child_processes.txt) <(sort all_child_processes.txt) > common_processes.txt;cat all_child_processes.txt",99,"2856.2114238739014","0","0.1","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 3: Consider using pgrep instead of grepping ps output. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7737,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the PID of exec.sh;exec_pid=$(pgrep -f 'exec\.sh');;if [ -z ""$exec_pid"" ]; then; echo ""Error: exec.sh is not running."" >&2; exit 1;fi;;# Get all descendant PIDs using pstree;descendants=$(pstree -p ""$exec_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Collect all .sh scripts from cmdline arguments;script_names=();for pid in $descendants; do; if [ -r ""/proc/$pid/cmdline"" ]; then; mapfile -d $'\0' args < ""/proc/$pid/cmdline""; for arg in ""${args[@]}""; do; if [[ ""$arg"" == *.sh ]]; then; script_names+=(""$arg""); fi; done; fi;done;;# Output unique script names;printf ""%s\n"" ""${script_names[@]}"" | sort -u",4529,"616381.6757202148","0","0.1","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"The parent process itself should not be included in the output",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7790,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child PIDs recursively;child_pids=$(pstree -p ""$parent_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Find all script processes among children;for pid in $parent_pid $child_pids; do; # Get the command line and check if it's a script; cmdline=$(cat ""/proc/$pid/cmdline"" | tr '\0' ' '); if [[ ""$cmdline"" =~ \.sh(\ |$) ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name""; fi;done | sort -u",334,"18600.563526153564","0","0.1","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",1,0,0,0,"Line 17: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7795,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the PID of the exec.sh process;parent_pid=$(pgrep -f 'exec.sh');;if [[ -z ""$parent_pid"" ]]; then; echo ""Error: exec.sh process not found""; exit 1;fi;;# Function to recursively get child processes;get_children() {; local pid=$1; ps -o pid= --ppid ""$pid"" | while read -r child_pid; do; echo ""$child_pid""; get_children ""$child_pid""; done;};;# Get all child PIDs including the parent;all_pids=($(get_children ""$parent_pid"") ""$parent_pid"");;# Get command names and filter for scripts;for pid in ""${all_pids[@]}""; do; ps -o cmd= -p ""$pid"" | grep -E '\.sh$' | awk '{print $1}';done | sort -u",328,"18927.515268325806","0.2","0.4","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,1,0,"Line 21: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7805,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P $pid);;# List the names of all child scripts launched by exec.sh script or its child processes;for child_pid in $children; do; cmdline=$(tr -d '\0' < /proc/$child_pid/cmdline); echo ""Child script name: $cmdline"";done",108,"1552.175760269165","0.2","0.4","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All indirect child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.25"
7798,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the PID of the exec.sh process;parent_pid=$(pgrep -f exec.sh);;if [[ -z ""$parent_pid"" ]]; then; echo ""exec.sh is not running""; exit 1;fi;;# Get all child processes recursively;child_pids=$(pstree -p ""$parent_pid"" | grep -o '([0-9]\+)' | grep -o '[0-9]\+');;# Check each process for script execution;echo ""Child scripts launched by exec.sh or its children:"";for pid in $parent_pid $child_pids; do; # Get the command line and check if it's a script; cmdline=$(cat /proc/""$pid""/cmdline | tr '\0' ' '); if [[ ""$cmdline"" =~ \.sh$ ]] || [[ ""$cmdline"" =~ ^/bin/bash ]] || [[ ""$cmdline"" =~ ^/bin/sh ]]; then; script_name=$(basename ""$(echo ""$cmdline"" | awk '{print $1}')""); echo ""$script_name (PID: $pid)""; fi;done | sort -u",377,"22214.258909225464","0.7","0.9","deepseek-v3","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",1,0,0,0,"Line 18: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7426,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -printf ""%p\n""
find /usr/info -type f -mtime +20 -mtime -22 -printf ""%p\n""",173,"12292.346239089966","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.4"
7753,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter out the script names;pstree -p $exec_pid | grep -oP '\(\d+\) \K[^ ]+' | grep -v '^('",73,"2251.2035369873047","0.2","0.4","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","9.500000000000002"
7809,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process id of the exec.sh script;exec_pid=$(pgrep -f ""exec.sh"");;# List all child processes of the exec.sh script;pids=$(pgrep -P $exec_pid);;# Loop through each child process and find the script name;for pid in $pids; do; cmd=$(ps -p $pid -o cmd --no-headers); script_name=$(echo $cmd | awk '{print $1}'); echo $script_name;done",112,"2056.8864345550537","0.7","0.9","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.549999999999999"
7802,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P $pid);;# List the names of all child scripts launched by exec.sh script or its child processes;for child_pid in $children; do; cmdline=$(tr -d '\0' < /proc/$child_pid/cmdline); echo ""Child script name: $cmdline"";done",108,"1654.1774272918701","0","0.1","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All indirect child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.25"
7754,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter out the script names;pstree -p $exec_pid | grep -oP '\(\d+\) \K[^ ]+' | grep -v '^('",73,"2251.2035369873047","0.2","0.4","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","9.500000000000002"
7781,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/(//g; s/)//g'",44,"1747.4963665008545","0.2","0.4","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
7785,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}'",31,"1553.8361072540283","0.7","0.9","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.45"
8462,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"958.6553573608398","0.2","0.4","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
7764,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash

# Find the PID(s) of exec.sh
mapfile -t pids < <(pgrep -f ""/path/to/exec.sh"")

# Function to recursively find child PIDs
get_child_pids() {
 local parent_pid=$1
 local children
 children=$(pgrep -P ""$parent_pid"")
 for child in $children; do
 echo ""$child""
 get_child_pids ""$child""
 done
}

# Collect all child PIDs
all_child_pids=()
for pid in ""${pids[@]}""; do
 while IFS= read -r child_pid; do
 all_child_pids+=(""$child_pid"")
 done < <(get_child_pids ""$pid"")
done

# Remove duplicate PIDs
unique_pids=($(printf ""%s\n"" ""${all_child_pids[@]}"" | sort -u))

# Get the script names from the collected PIDs
for pid in ""${unique_pids[@]}""; do
 cmd=$(ps -p ""$pid"" -o cmd=)
 if [[ ""$cmd"" =~ \.sh$ ]]; then
 echo ""$cmd""
 fi
done",1672,"9685.621976852417","1","1","o1-mini","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,1,0,"Line 26: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
8305,"Experiment 1","FindDate","NL2Bash",3,1,"LC_ALL=C ncal -M May 2013 | awk '/^Mo/ {print $2}'",2343,"82169.81983184814","0","0.1","deepseek-r1","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","6.12"
8333,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +(1-$(date -d 2013-05-01 +%u)) days""",34,"5254.383563995361","0.2","0.4","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.4"
8334,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-01 +$((8 - $(date -d 2013-05-01 +%u))) days""",36,"1156.5423011779785","0.2","0.4","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
8335,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +(1 - $(date -d 2013-05-01 +%u)) days"" ""+%Y-%m-%d""",42,"7498.126268386841","0.7","0.9","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
8336,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-01 +(8 - $(date -d 2013-05-01 +%u)) days"" ""+%Y-%m-%d""",42,"1156.4862728118896","0.7","0.9","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
8331,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +(1-$(date -d 2013-05-01 +%u)) days""",34,"8798.307418823242","0","0.1","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.4"
8332,"Experiment 1","FindDate","NL2Bash",3,2,"date -d ""2013-05-01 +$((8 - $(date -d 2013-05-01 +%u))) days""",36,"1156.2106609344482","0","0.1","gpt-3.5-turbo","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
7401,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1043,"56745.805740356445","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7782,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/(//g; s/)//g'",44,"1747.4963665008545","0.2","0.4","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
7777,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[\(\)]//g'",42,"2354.665994644165","0","0.1","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
7377,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1757.6930522918701","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7378,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1757.6930522918701","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
9181,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -rH /usr/files | awk 'BEGIN { RS=""""; FS=""\n""; OFS="" "" } NF>1 { $1=$1; print }'",6677,"316060.8174800873","0.2","0.4","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","6.83"
7434,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -print
find /usr/info -type f -mtime +20 -mtime -22 -print",163,"12694.263458251953","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.3"
7448,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -22",21,"952.0254135131836","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7458,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21 -mtime -22",21,"1252.8879642486572","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7329,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1189.3136501312256","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7330,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1189.3136501312256","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7331,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1272.4463939666748","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7332,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1272.4463939666748","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7370,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1656.1775207519531","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
9184,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -r /usr/files | awk -v RS= '{$1=$1}1' OFS=' '",4018,"191226.31740570068","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"Building file list - Building file list \ Building file list | Building file list / Building file list - Building file list \ Building file list | Building file list / Building file list - Progress [0/8] 0% Progress [1/8] 12% Progress [2/8] 25% Progress [3/8] 37% Progress [4/8] 50% Progress [5/8] 62% Progress [6/8] 75% Progress [7/8] 87%      ",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.960000000000001"
9187,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"fdupes -rq /usr/files | awk -v RS= '{gsub(/\n/, "" "")} NR>1 {print """"} {printf ""%s"", $0} END {print """"}'",1977,"98565.35053253174","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
9232,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",96,"2070.78218460083","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value md5sum: {}: No such file or directory ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.099999999999998"
9309,"Experiment 1","PrintTable","NL2Bash",3,2,"(join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep ""^Exe"") | column -t",90,"10806.246995925903","0.7","0.9","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"Line that starts with *Exe* should be at the start of the table",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
7371,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"2375.4961490631104","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7335,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",605,"4372.336626052856","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7339,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",226,"2775.7558822631836","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7341,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",226,"2775.7558822631836","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4835,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
9168,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and full checksum; size=$(stat -c '%s' ""$file""); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and checksum; unique_id=""${device}:${inode}:${size}:${checksum}""; # Store file path with its unique_id; echo ""$file"" >> ""$tmpdir/${unique_id}.txt"";done;;# Process each group of potentially identical files;find ""$tmpdir"" -type f -name '*.txt' -print0 | while IFS= read -r -d $'\0' group; do; # Count files in this group; count=$(wc -l < ""$group""); # If we have multiple files, print them; if [ ""$count"" -gt 1 ]; then; # Read all files in the group into an array; mapfile -t files < ""$group""; # Print all files in the group on one line; printf '%s\n' ""${files[*]}""; fi;done;;# Clean up;rm -rf ""$tmpdir""",512,"26759.291648864746","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9169,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and process them;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and full checksum; size=$(stat -c '%s' ""$file""); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and checksum; unique_id=""${device}:${inode}:${size}:${checksum}""; # Store file path with its unique_id; echo ""$file"" >> ""$tmpdir/${unique_id}.txt"";done;;# Process each group of potentially identical files;find ""$tmpdir"" -type f -name '*.txt' -print0 | while IFS= read -r -d $'\0' group; do; # Count files in this group; count=$(wc -l < ""$group""); # If we have multiple files, print them; if [ ""$count"" -gt 1 ]; then; # Read all files in the group into an array; mapfile -t files < ""$group""; # Print all files in the group on one line; printf '%s\n' ""${files[*]}""; fi;done;;# Clean up;rm -rf ""$tmpdir""",512,"26759.291648864746","0.2","0.4","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
5062,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
9172,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and partial checksum; id=""${device}:${inode}:${size}:${checksum}""; # Append file path to the identifier's record; echo ""$file"" >> ""$tmpdir/$id"";done;;# Output files with identical identifiers (including hard links);for idfile in ""$tmpdir""/*; do; # Only show groups with more than one file; if [ $(wc -l < ""$idfile"") -gt 1 ]; then; # Replace newlines with spaces; tr '\n' ' ' < ""$idfile""; echo # Add newline after each group; fi;done;;# Clean up;rm -rf ""$tmpdir""",499,"26644.14930343628","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 26: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9241,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"952.8834819793701","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
9243,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1581.3758373260498","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
5070,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 723e020..0a9d677 develop -> origin/develop ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
9174,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d) || exit 1;;# Process each file;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get unique identifier (device + inode) to detect hard links; file_id=$(stat -c '%d:%i' -- ""$file""); # Get full file checksum (SHA-256); checksum=$(sha256sum -- ""$file"" | cut -d' ' -f1); # Store file path under both identifiers; echo ""$file"" >> ""$tmpdir/by_id_$file_id""; echo ""$file"" >> ""$tmpdir/by_hash_$checksum"";done;;# Output duplicate groups;{; # Find hard link duplicates (same inode); find ""$tmpdir"" -name 'by_id_*' -type f -size +0c | while read -r idfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$idfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done; # Find content duplicates (same hash); find ""$tmpdir"" -name 'by_hash_*' -type f -size +0c | while read -r hashfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$hashfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done;} | sort -u;;# Clean up;rm -rf ""$tmpdir""",629,"32976.28211975098","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9175,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d) || exit 1;;# Process each file;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get unique identifier (device + inode) to detect hard links; file_id=$(stat -c '%d:%i' -- ""$file""); # Get full file checksum (SHA-256); checksum=$(sha256sum -- ""$file"" | cut -d' ' -f1); # Store file path under both identifiers; echo ""$file"" >> ""$tmpdir/by_id_$file_id""; echo ""$file"" >> ""$tmpdir/by_hash_$checksum"";done;;# Output duplicate groups;{; # Find hard link duplicates (same inode); find ""$tmpdir"" -name 'by_id_*' -type f -size +0c | while read -r idfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$idfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done; # Find content duplicates (same hash); find ""$tmpdir"" -name 'by_hash_*' -type f -size +0c | while read -r hashfile; do; files=(); while IFS= read -r -d '' file; do; files+=(""$file""); done < <(tr '\n' '\0' < ""$hashfile""); if [ ""${#files[@]}"" -gt 1 ]; then; printf '%s ' ""${files[@]}""; printf '\n'; fi; done;} | sort -u;;# Clean up;rm -rf ""$tmpdir""",629,"32976.28211975098","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9158,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d '' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as a checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier for potential duplicates; echo ""$file"" >> ""$tmpdir/files_${device}_${inode}_${size}_${checksum}"";done;;# Output groups of identical files;find ""$tmpdir"" -type f -size +0c | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; tr '\n' ' ' < ""$group""; echo; fi;done",436,"24238.853216171265","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,1,0,"Line 24: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","48.599999999999994"
9233,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"1052.591323852539","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
9234,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"1052.591323852539","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
9235,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"1052.591323852539","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
9221,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"1951.2443542480469","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
7688,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}');echo ""IP: $ip""",38,"2031.8121910095215","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
9238,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1382.2050094604492","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
9190,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort -k1,1 | awk '{; if ($1 == prev_inode) {; printf ""%s "", $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_inode = $1;} END { if (NR > 0) print """" }' | while read -r line; do; files=($line); if [ ${#files[@]} -gt 1 ]; then; echo ""${files[@]}""; fi;done",134,"2756.504774093628","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 11: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9193,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -printf '%s %p\n' | sort -k1,1 | awk '{; if ($1 == prev_size) {; print $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_size = $1;}' | xargs -I{} -d '\n' sh -c '; for file in ""$@""; do; md5sum ""$file""; done | sort | awk ""{print \$2}"" | uniq -d;' sh {} | while read -r file; do; find /usr/files -type f -exec md5sum {} + | grep ""$(md5sum ""$file"" | cut -d"" "" -f1)"" | awk '{print $2}' | tr '\n' ' ' | sed 's/ $/\n/';done",195,"5384.1540813446045","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"md5sum: '/usr/files/file1.txt /usr/files/file2copy1.txt': No such file or directory ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,1,0,0,"Lines 10 - 14: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","44.03"
9231,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",96,"2070.78218460083","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"xargs: warning: options --max-args and --replace/-I/-i are mutually exclusive, ignoring previous --max-args value md5sum: {}: No such file or directory ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.099999999999998"
9222,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"1951.2443542480469","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
9216,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"2655.2350521087646","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
7691,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip route get 1.1.1.1 | grep -oP 'src \K\S+')""",2495,"114832.7169418335","0.2","0.4","deepseek-r1","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
9228,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",96,"1951.2505531311035","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.999999999999996"
8442,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1254.7235488891602","0.2","0.4","gpt-3.5-turbo","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
9217,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",92,"2655.2350521087646","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.9"
9203,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec sha256sum {} + | sort | awk ';{; hash = $1; file = $2; files[hash] = files[hash] "" "" file;};END {; for (h in files) {; n = split(files[h], a, "" ""); if (n > 1) {; print substr(files[h], 2); }; };}'",1772,"11586.543083190918","1","1","o1-mini","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.559999999999999"
9204,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec sha256sum {} + | sort | awk ';{; hash = $1; file = $2; files[hash] = files[hash] "" "" file;};END {; for (h in files) {; n = split(files[h], a, "" ""); if (n > 1) {; print substr(files[h], 2); }; };}'",1772,"11586.543083190918","1","1","o1-mini","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.559999999999999"
4836,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7692,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip route get 1.1.1.1 | grep -oP 'src \K\S+')""",2495,"114832.7169418335","0.2","0.4","deepseek-r1","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
4833,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4838,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4839,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4840,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4842,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4843,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract and sort user values from all files using C locale for consistent sorting;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",1668,"48319.443225860596","0.2","0.4","deepseek-r1","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4846,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
4847,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' 2>/dev/null {} \; | sort);user_list=$(echo ""$users"" | paste -sd, -);;if [[ -z ""$user_list"" ]]; then; echo ""No users found"";else; echo ""Here are the users: $user_list"";fi",2300,"28805.005311965942","0.7","0.9","deepseek-r1","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,1,0,"Line 3: Redirection applies to the find command itself. Rewrite to work per action (or move to end). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","10.75"
4820,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","8.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7484,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade | grep -q ""htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",38,"1576.1678218841553","0.2","0.4","llama3.3-70b","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
4821,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","8.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4822,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7689,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip route get 1.1.1.1 | awk '{for(i=1; i<=NF; i++){if($i==""src""){printf ""IP: %s\n"", $(i+1); exit}}}'",2244,"109519.00482177734","0","0.1","deepseek-r1","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","7.18"
5114,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
4824,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",1818,"910271.4009284973","0","0.1","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","8.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4827,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","8.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4828,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract unique user values from JSON files, sorted alphabetically with C locale for deterministic order;users=$(find . -maxdepth 1 -type f -exec \; jq -r '.. | .user? // empty | select(type == ""string"")' {} \; 2>/dev/null | ; LC_ALL=C sort -u);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format into comma-separated list; user_list=$(echo ""$users"" | paste -sd,); echo ""Here are the users: ${user_list}"";fi",3253,"30043.864011764526","0","0.1","deepseek-r1","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4873,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4868,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7677,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}')""",35,"1761.6734504699707","0","0.1","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
4900,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4872,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",129,"7525.772571563721","0.2","0.4","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: *.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4878,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ', ' | sed 's/, $//'); echo ""Here are the users: $user_list"";fi",223,"10095.563888549805","0.2","0.4","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: ./*.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4884,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",364,"28399.608612060547","0.7","0.9","deepseek-v3","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: *.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4889,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4861,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4856,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7699,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1 | awk '{print ""IP: "" $1}'",48,"5977.25248336792","0.2","0.4","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
5140,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
4858,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4859,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' *.json | sort -u);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",122,"13246.477365493774","0","0.1","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4904,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4906,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4907,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4908,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: *.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4911,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4896,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"grep: *.json: No such file or directory ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4915,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; sorted_users=$(echo ""$users"" | tr ' ' '\n' | sort | tr '\n' ' '); echo ""Here are the users: $sorted_users"";fi",91,"1648.5834121704102","0.2","0.4","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4920,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4899,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4924,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"parse error: Expected string key before ':' at line 1, column 23 ",False,"A user was not found!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4901,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4712,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7700,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1 | awk '{print ""IP: "" $1}'",48,"5977.25248336792","0.2","0.4","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
4944,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 5e023d1..17ebedc develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4717,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=($(printf ""%s\n"" ""${users[@]}"" | sort)); echo ""Here are the users: ${sorted_users[*]}"";fi",136,"3465.9183025360107","0.2","0.4","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",0,0,2,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 17: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","3.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4719,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4718,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4948,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
4722,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4723,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; while IFS= read -r value; do; users+=(""$value""); done < <(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file""); fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";fi",137,"2159.4676971435547","0.2","0.4","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",0,0,1,0,"Line 16: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7678,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}')""",35,"1761.6734504699707","0","0.1","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
4725,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4932,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 5e023d1..17ebedc develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4731,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ -n ""$values"" ]]; then; mapfile -t file_users <<< ""$values""; users+=(""${file_users[@]}""); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",170,"1959.3405723571777","0.7","0.9","gpt-4o","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4700,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; users+=($values); fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",140,"4389.534711837769","0","0.1","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,1,0,"Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7669,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",481,"7786.491632461548","1","1","o1-mini","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
5033,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4706,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4738,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5036,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4711,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();;for file in *.json; do; if [ -f ""$file"" ]; then; values=$(jq -r '.user // empty' ""$file""); if [ -n ""$values"" ]; then; while IFS= read -r value; do; users+=(""$value""); done <<< ""$values""; fi; fi;done;;if [ ${#users[@]} -eq 0 ]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo ""$sorted_users"" | tr '\n' ', ' | sed 's/, $//')"";fi",159,"1855.691909790039","0","0.1","gpt-4o","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"parse error: Expected value before ',' at line 4, column 39 ",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4796,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7701,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | awk '{print ""IP: "" $1}';ip -4 addr | awk '/inet/ && !/127.0.0.1/ {split($2, a, ""/""); print ""IP: "" a[1]; exit}'",164,"11884.686470031738","0.2","0.4","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","15.68"
4808,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4792,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4799,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if grep -q ""\""user\"""" ""$file""; then; user=$(jq -r '.user' ""$file""); if [ $? -eq 0 ]; then; users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",125,"2611.403465270996","0.2","0.4","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","5.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4806,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"parse error: Invalid numeric literal at line 2, column 12 ",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7670,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(hostname -I | awk '{print $1}')""",481,"7786.491632461548","1","1","o1-mini","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","1.35"
8458,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"969.2935943603516","0","0.1","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
4812,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4785,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"A user was found when there were none to be found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4786,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4791,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4793,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; readarray -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2155.628442764282","0","0.1","llama3.3-70b","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4788,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4966,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
4789,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7686,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip=$(ip -4 route show default | awk '{print $3}');echo ""IP: $ip""",27,"1368.847131729126","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","2.6500000000000004"
7710,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 -o addr show ""$(ip route | awk '/default/ {print $5}')"" | awk '{print ""IP: "" $4}' | awk '{print $2}'",44,"2044.816017150879","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.79"
4747,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"",0,0,0,0,"","9.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7704,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1 | awk '{print ""IP: "" $1}'",48,"7281.9883823394775","0.7","0.9","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
7697,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+(?=/\d+)' | grep -v '127.0.0.1' | head -n 1 | awk '{print ""IP: "" $1}';ip -4 addr show $(ip route | awk '/default/ {print $5}') | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+' | head -n 1 | awk '{print ""IP: "" $1}'",199,"16604.663372039795","0","0.1","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",False,"",0,0,1,0,"Line 3: Quote this to prevent word splitting. ","11.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","24.33"
7668,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show ""$(ip route show default | awk '/default/ {print $5}')"" | awk '/inet / {print ""IP: ""$2}' | cut -d/ -f1",48,"1648.5340595245361","0.7","0.9","gpt-4o","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.73"
7681,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}')""",35,"1967.1988487243652","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",False,"The IP address was not formatted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
7683,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"echo ""IP: $(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tail -n 1)""",41,"1993.2842254638672","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","-1"
7708,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: "" $4}'",36,"1355.6623458862305","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"Only output the one address after *IP: * in one line. If there exist any virtual interfaces, only output the physical interface's IP",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.24"
7685,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip=$(ip -4 route show default | awk '{print $3}');echo ""IP: $ip""",27,"1368.847131729126","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","2.6500000000000004"
6469,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';NR==1 {; for (i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; };};NR > 1 {; gsub(/[,""]/, """", $col); sum += $col; count++;};END {; printf ""Mean: %.2f\n"", count ? sum/count : 0;}' products.csv",2393,"29831.347703933716","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6474,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; gsub(/^""|""$/, """", $i);; if (tolower($i) == ""price"") {; col = i;; break;; }; }; if (col == 0) {; print ""Error: Price column not found."" > ""/dev/stderr""; exit 1; };};NR > 1 {; gsub(/[^0-9.]/, """", $col);; if ($col != """") {; sum += $col;; count++;; };};END {; printf ""Mean: %.2f\n"", (count > 0) ? sum/count : 0;}' products.csv",3085,"29639.60027694702","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"Error: Price column not found. ",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6475,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='([^,]+)|(\""[^\""]+\"")' ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; gsub(/^""|""$/, """", $i);; if (tolower($i) == ""price"") {; col = i;; break;; }; }; if (col == 0) {; print ""Error: Price column not found."" > ""/dev/stderr""; exit 1; };};NR > 1 {; gsub(/[^0-9.]/, """", $col);; if ($col != """") {; sum += $col;; count++;; };};END {; printf ""Mean: %.2f\n"", (count > 0) ? sum/count : 0;}' products.csv",3085,"29639.60027694702","0.2","0.4","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"Error: Price column not found. ",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.94"
6482,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F',' ';NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"" || $i == ""\""price\"""") {; col = i; }; };};NR > 1 {; if ($col != """") {; # Remove all non-numeric characters except decimal point; gsub(/[^0-9.]/, """", $col); # Handle empty strings after cleanup; if ($col != """") {; sum += $col; count++; }; };};END {; if (count) {; printf ""Mean: %.2f\n"", sum/count; } else {; print ""No valid price data found""; };};' products.csv",1880,"19606.629133224487","0.7","0.9","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","7.25","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
6461,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; gsub(/[$,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",2280,"29740.684270858765","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","9.61"
6462,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; gsub(/[$,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",2280,"29740.684270858765","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","9.61"
5525,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 bash ""$script"" &>/dev/null
 if [[ $? -eq 0 ]]; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",1143,"21651.40438079834","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"",1,0,0,0,"Line 5: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.299999999999997"
6463,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; gsub(/[$,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",2280,"29740.684270858765","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","9.61"
6506,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"2246.363878250122","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6507,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"2246.363878250122","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6464,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; gsub(/[$,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",2280,"29740.684270858765","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"The mean value was not correctly calculated. Column may contain decimal point values",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","9.61"
6467,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; # Remove quotes and trim whitespace from header name; gsub(/[""]/, """", $i); header = tolower($i); sub(/^[ \t]+/, """", header); sub(/[ \t]+$/, """", header); if (header == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; # Remove currency symbols, commas, and quotes from the value; gsub(/[""$£,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",905,"9772.428274154663","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","14.35"
6495,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",111,"10570.882320404053","0.7","0.9","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6496,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",111,"10570.882320404053","0.7","0.9","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6518,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",39,"1146.3119983673096","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
5510,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",1037,"20438.520431518555","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","16.349999999999998"
6519,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",39,"1146.3119983673096","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
6499,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"1244.386911392212","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6402,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1545.0809001922607","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6403,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1545.0809001922607","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6447,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, 'NR>1 {sum+=$4; count++} END {print ""Mean: "" sum/count}' products.csv",37,"1940.981388092041","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6395,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",57,"1764.254093170166","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.47"
6408,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2247.920274734497","0.2","0.4","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6411,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); sum += $3; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",58,"1978.9774417877197","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","3.5100000000000002"
6398,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2347.381353378296","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6400,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR>1 {gsub(/""/, """", $3); gsub(/,/, """", $3); $3 = ($3 ~ /\./) ? $3 : $3 "".00""; sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2347.381353378296","0","0.1","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","4.95"
6446,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, 'NR>1 {sum+=$4; count++} END {print ""Mean: "" sum/count}' products.csv",37,"1940.981388092041","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6450,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if(NR>1) sum+=$4; if(NR>1) count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",49,"2854.0730476379395","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6415,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); gsub(/\./, """", $3); sub(/,/, ""."", $3); sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2059.1306686401367","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","5.09"
6451,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if(NR>1) sum+=$4; if(NR>1) count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",49,"2854.0730476379395","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6444,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if ($0 ~ /^[0-9]+,/) {sum+=$2; count++}} END {if (count > 0) print ""Mean: "" sum/count; else print ""No numeric values found""}' products.csv",61,"1657.3429107666016","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"The mean value was not correctly calculated. Column may contain decimal point values",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6419,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; }; NR>1 {; gsub(/,/, """", $col) # Remove commas for number formatting; sum += $col; count++; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",532,"4253.265857696533","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","8.45"
6422,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if (tolower($i) == ""price"") {; col = i; break; }; }; if (!col) {; print ""Mean: 0.00""; exit; }; }; NR>1 && col {; # Remove any commas and quotes; gsub(/["",]/, """", $col); # Replace comma decimal separators with dots if necessary; gsub(/,/, ""."", $col); if ($col ~ /^[0-9.]+$/) {; sum += $col; count++; }; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",1494,"11677.667140960693","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.69"
5879,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | grep -c "": warning:"");echo ""Count warning: $count""",831,"47518.707275390625","0.7","0.9","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5851,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",2136,"24517.924308776855","0","0.1","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5893,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2045.0479984283447","0.2","0.4","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5894,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2045.0479984283447","0.2","0.4","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5899,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",87,"8874.232769012451","0.2","0.4","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5918,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1542.2117710113525","0.2","0.4","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5873,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | wc -l);echo ""Count warning: $count""",1473,"15083.918809890747","0.7","0.9","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only warning level errors should be counted.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5874,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | wc -l);echo ""Count warning: $count""",1473,"15083.918809890747","0.7","0.9","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only warning level errors should be counted.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5776,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",48,"1456.9919109344482","0.2","0.4","gpt-4o","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5784,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;total_warnings=0;;for script in *.sh; do; warnings=$(shellcheck ""$script"" --format json | jq '[.[] | select(.level == ""warning"")] | length'); total_warnings=$((total_warnings + warnings));done;;echo ""Count warning: $total_warnings""",74,"1857.2564125061035","0.7","0.9","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5768,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length');echo ""Count warning: $count""",56,"1992.6517009735107","0","0.1","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5919,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1542.2117710113525","0.2","0.4","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5923,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

# Using find command to locate all bash scripts in the current directory
# Using xargs to execute shellcheck on each script and grep to count the lines containing ""warning""
warning_count=$(find . -type f -name ""*.sh"" -exec shellcheck {} \; | grep -c ""warning"")

echo ""Count warning: $warning_count""",80,"1442.976713180542","0.7","0.9","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5924,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

# Using find command to locate all bash scripts in the current directory
# Using xargs to execute shellcheck on each script and grep to count the lines containing ""warning""
warning_count=$(find . -type f -name ""*.sh"" -exec shellcheck {} \; | grep -c ""warning"")

echo ""Count warning: $warning_count""",80,"1442.976713180542","0.7","0.9","gpt-3.5-turbo","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5769,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length');echo ""Count warning: $count""",56,"1992.6517009735107","0","0.1","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5777,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",48,"1456.9919109344482","0.2","0.4","gpt-4o","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5559,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1433.8123798370361","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0_0.1.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
5833,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -c ""warning:"")
echo ""Count warning: $count""",26,"4054.0614128112793","0.2","0.4","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5821,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -i ""warning:"" | wc -l)
echo ""Count warning: $count""",31,"2545.4046726226807","0","0.1","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",1,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","6.5","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5822,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -i ""warning:"" | wc -l)
echo ""Count warning: $count""",31,"2545.4046726226807","0","0.1","llama3.3-70b","nav neviena skripta",2,"",False,"",1,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","6.5","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8189,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep 'Failed password' /var/log/auth.log* | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",55,"1967.5228595733643","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.99"
5849,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -n *.sh 2>/dev/null | grep -c ""warning:"")
echo ""Count warning: $count""",33,"1847.5515842437744","0.7","0.9","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8077,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"current_date=$(date +""%b %e"");zgrep -hE ""$current_date.*(Failed password|authentication failure)"" /var/log/auth.log* | {; while read -r line; do; if [[ ""$line"" == *""Failed password""* ]]; then; echo ""$line"" | sed -nE 's/.*Failed password for (invalid user )?([^ ]+).*/\2/p'; else; echo ""$line"" | grep -o 'user=[^ ]*' | cut -d= -f2; fi; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2570,"118893.9700126648","0","0.1","deepseek-r1","Autorizācijas ar tty",1,"gzip: /var/log/auth.log*.gz: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.73"
8090,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"journalctl --since today --quiet | grep -E 'Failed password|authentication failure' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3583,"165353.27172279358","0.7","0.9","deepseek-r1","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.23"
8091,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"journalctl --since today --quiet | grep -E 'Failed password|authentication failure' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",3583,"165353.27172279358","0.7","0.9","deepseek-r1","Autorizācijas ar ssh",2,"",False,"",0,0,0,0,"","9.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.23"
8093,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today | grep -aEi 'authentication failure|Failed password|authentication error|FAILED SU' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+|sudo:.*?\K\buser\b=([^ ]+)|sudo:\s*\K\S+(?=.*auth)|FAILED SU.*?\K\S+$)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2411,"117325.65879821777","0.7","0.9","deepseek-r1","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.180000000000001"
7184,"Experiment 1","HostHtml","IaC",1,1,"#!/bin/bash;# Configure nginx to serve from /usr/html;sed -i '/root \/var\/www\/html;/c\ root /usr/html;' /etc/nginx/sites-available/default;# Ensure permissions and restart nginx;chmod -R a+r /usr/html;find /usr/html -type d -exec chmod a+x {} \;;nginx -t && systemctl restart nginx",447,"35062.37053871155","0","0.1","deepseek-r1","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","10.35"
8094,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today | grep -aEi 'authentication failure|Failed password|authentication error|FAILED SU' | grep -oP '(Failed password for (?:invalid user )?\K\S+|user=\K\S+|sudo:.*?\K\buser\b=([^ ]+)|sudo:\s*\K\S+(?=.*auth)|FAILED SU.*?\K\S+$)' | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2411,"117325.65879821777","0.7","0.9","deepseek-r1","Autorizācijas ar ssh",2,"",False,"",0,0,0,0,"","9.0","","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.180000000000001"
8164,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check all auth logs including rotated ones;log_files=(/var/log/auth.log /var/log/auth.log.[0-9] /var/log/auth.log.[0-9].gz);;# Patterns for different types of failed authentication;patterns=(; ""Failed password""; ""authentication failure""; ""FAILED LOGIN""; ""invalid user""; ""user unknown"";);;# Get today's date in log format (e.g., ""Jan 1"");today=$(date '+%b %e');;# Temporary file for storing results;temp_file=$(mktemp);;for log in ""${log_files[@]}""; do; if [ -f ""$log"" ]; then; if [[ ""$log"" == *.gz ]]; then; zgrep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; else; grep -h ""$today"" ""$log"" | grep -E ""$(IFS='|'; echo ""${patterns[*]}"")"" >> ""$temp_file""; fi; fi;done;;# Extract usernames from logs and count;count=$(awk '{; if (/invalid user|user unknown/) {; for(i=1; i<=NF; i++) if ($i == ""user"") {print $(i+1); break}; } else if (/authentication failure/) {; for(i=1; i<=NF; i++) if ($i == ""user="") {print $(i+1); break}; } else {; for(i=1; i<=NF; i++) if ($i == ""for"") {print $(i+1); break}; };}' ""$temp_file"" | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count"";rm ""$temp_file""",540,"27681.88762664795","0.2","0.4","deepseek-v3","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5434,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1668.386697769165","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8078,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"current_date=$(date +""%b %e"");zgrep -hE ""$current_date.*(Failed password|authentication failure)"" /var/log/auth.log* | {; while read -r line; do; if [[ ""$line"" == *""Failed password""* ]]; then; echo ""$line"" | sed -nE 's/.*Failed password for (invalid user )?([^ ]+).*/\2/p'; else; echo ""$line"" | grep -o 'user=[^ ]*' | cut -d= -f2; fi; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",2570,"118893.9700126648","0","0.1","deepseek-r1","Autorizācijas ar su un sudo",2,"gzip: /var/log/auth.log*.gz: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.73"
8161,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log | grep -i ""failed"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $count""",200,"13297.080278396606","0.2","0.4","deepseek-v3","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8168,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -E ""user=|user "" | \; sed -E 's/.*(user=|user )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",242,"14895.362615585327","0.7","0.9","deepseek-v3","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8169,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -E ""user=|user "" | \; sed -E 's/.*(user=|user )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",242,"14895.362615585327","0.7","0.9","deepseek-v3","Autorizācijas ar ssh",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
5439,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1344.7151184082031","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
8172,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Find all auth log files (including rotated ones);log_files=();possible_locations=(; ""/var/log/auth.log""; ""/var/log/auth.log.1""; ""/var/log/auth.log.*.gz""; ""/var/log/secure""; ""/var/log/secure.*"";);;for loc in ""${possible_locations[@]}""; do; for file in $loc; do; if [ -f ""$file"" ] || [[ ""$file"" == *.gz ]]; then; log_files+=(""$file""); fi; done;done;;if [ ${#log_files[@]} -eq 0 ]; then; echo ""Users: 0 (no auth logs found)""; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(zgrep -h ""$(date '+%b %e')"" ""${log_files[@]}"" 2>/dev/null | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -E ""user=|user |for |login failed"" | \; sed -E 's/.*(user=|user |for )([^ ]+).*/\2/i' | \; sort | uniq -c | \; awk '$1 >= 3 {print $2}' | wc -l);;echo ""Users: $count""",419,"20934.237241744995","0.7","0.9","deepseek-v3","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8179,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1247.6391792297363","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8155,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -i ""password\|authentication"" | \; awk '{print $9, $10, $11}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",240,"14896.313667297363","0","0.1","deepseek-v3","Autorizācijas ar tty",1,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8156,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Count unique users with >=3 failed auth attempts today;count=$(grep ""$(date '+%b %e')"" /var/log/auth.log* | \; grep -i ""failed"" | \; grep -i ""password\|authentication"" | \; awk '{print $9, $10, $11}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",240,"14896.313667297363","0","0.1","deepseek-v3","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8180,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1247.6391792297363","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8160,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check for auth log files (Debian typically uses auth.log or secure);LOG_FILES=();[ -f /var/log/auth.log ] && LOG_FILES+=(/var/log/auth.log);[ -f /var/log/secure ] && LOG_FILES+=(/var/log/secure);[ -f /var/log/syslog ] && LOG_FILES+=(/var/log/syslog);;if [ ${#LOG_FILES[@]} -eq 0 ]; then; echo ""Error: No authentication log files found"" >&2; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(grep -h ""$(date '+%b %e')"" ""${LOG_FILES[@]}"" | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -iE ""password|authentication|login|sshd"" | \; awk 'match($0, /user(name)?=([^ ]+)/, a) {print a[2]} ;  match($0, /for( invalid user)? ([^ ]+)/, a) {print a[2]} ;  /FAILED/ {for(i=1;i<=NF;i++) if ($i==""for"") print $(i+1)}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",448,"23656.993865966797","0","0.1","deepseek-v3","Autorizācijas ar ssh",2,"Error: No authentication log files found ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8177,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",63,"1871.473789215088","0","0.1","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
8184,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",52,"1175.840139389038","0.2","0.4","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8178,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",63,"1871.473789215088","0","0.1","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
8101,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/' /var/log/auth.log | \;awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",61,"1853.7108898162842","0.2","0.4","gpt-4o","Autorizācijas ar tty",1,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","12.870000000000001"
8106,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | \;grep -E 'authentication failure|Failed password|invalid user' | \;awk '{print $(NF-2)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",70,"1794.5184707641602","0.2","0.4","gpt-4o","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8467,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",289,"3153.223752975464","1","1","o1-mini","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8187,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep 'authentication failure' /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1149.799108505249","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8188,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep 'Failed password' /var/log/auth.log* | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",55,"1967.5228595733643","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.99"
8147,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"3297.0008850097656","0.2","0.4","llama3.3-70b","Autorizācijas ar su un sudo",2,"",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8109,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"today=$(date '+%b %d');count=$(grep ""$today"" /var/log/auth.log | grep ""Failed password"" | awk '{print $(NF-5)}' | sort | uniq -c | awk '$1 >= 3' | wc -l);echo ""Users: $count""",67,"1760.4641914367676","0.7","0.9","gpt-4o","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8095,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/authentication failure/ && /'$(date '+%b %e')'/ {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",57,"1856.4846515655518","0","0.1","gpt-4o","Autorizācijas ar tty",1,"awk: line 1: runaway regular expression /Oct ... ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.540000000000001"
8143,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $1}' | sort | uniq -d | awk 'NR>2 {a[$1]++} END {for (i in a) if (a[i]>=3) b++; print b}')""",77,"1950.272560119629","0.2","0.4","llama3.3-70b","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8148,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $NF}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"3297.0008850097656","0.2","0.4","llama3.3-70b","Autorizācijas ar ssh",2,"",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
7204,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl restart nginx",32,"1084.1476917266846","0.2","0.4","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","5.550000000000001"
8139,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"echo ""Users: $(grep ""authentication failure"" /var/log/auth.log | grep $(date +""%b %d"") | awk '{print $3}' | sort | uniq -d | awk '{a[$1]++} END {for (i in a) if (a[i] >= 3) print i}' | wc -l)""",77,"2552.788019180298","0","0.1","llama3.3-70b","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory grep: 10: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8115,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep ""Failed password"" | awk '{for(i=1;i<=NF;i++) if ($i==""user"") {print $(i+1)}}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",988,"12988.736629486084","1","1","o1-mini","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","19.360000000000003"
8116,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"journalctl --since today -u sshd -u login --no-pager | grep -E ""Failed password|authentication failure"" | awk -F'=' '/user=/ {print $2}' | awk '{print $1}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",862,"6014.274835586548","1","1","o1-mini","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","21.6"
8451,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",550,"28939.19277191162","0.7","0.9","deepseek-r1","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7870,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8460,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1158.3952903747559","0.2","0.4","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7871,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ls -1 /sys/devices/virtual/net/ | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;while read -r iface; do; if ip link show dev ""$iface"" >/dev/null 2>&1; then; ipv4=$(ip -4 -br addr show dev ""$iface"" | awk '{gsub(/\/.*/,"""",$3); print $3}'); [[ -z ""$ipv4"" ]] && ipv4=""None""; echo ""$iface - $ipv4""; fi;done <<< ""$virtual_interfaces""",2132,"106186.81859970093","0.2","0.4","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,1,0,"Line 3: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","8.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7877,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind // """") != ""ether"") | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",6391,"292429.84437942505","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7880,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -j -d link show | jq -r '.[] | select(.ifname != ""lo"" and (.linkinfo.info_kind? // """" | test(""^(veth|bridge|tun|tap)$""))) | .ifname');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found"";else; while IFS= read -r iface; do; ipv4=$(ip -j addr show ""$iface"" | jq -r '.[0].addr_info | [.[] | select(.family == ""inet"").local] | if length == 0 then ""None"" else join("", "") end'); echo ""$iface - $ipv4""; done <<< ""$virtual_interfaces"";fi",3453,"157939.50819969177","0.7","0.9","deepseek-r1","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7853,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8063,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7134,"Experiment 1","SetupAlpineContainer","IaC",2,1,"mkdir -p /usr/alpinedata && docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",1120,"56563.88807296753","0","0.1","deepseek-r1","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","6.2"
7854,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -q -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi",6244,"278812.9768371582","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8064,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"1859.8568439483643","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7855,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;while read -r iface; do; if [[ ""$iface"" == ""lo"" ]]; then; continue; fi; if ip -d link show ""$iface"" 2>/dev/null | grep -qi -e 'veth' -e 'bridge' -e 'tun' -e 'tap' -e 'vlan' -e 'bond' -e 'macvlan' -e 'dummy' -e 'macvtap' -e 'gre' -e 'ipip'; then; found=1; ipv4=$(ip -4 addr show dev ""$iface"" | awk '/inet / {print $2}' | cut -d/ -f1); echo ""$iface - ${ipv4:-None}""; fi;done < <(ip -o link show | awk -F': ' '{print $2}');;if [[ ""$found"" -eq 0 ]]; then; echo ""No virtual interfaces found"";fi;ip -d link show | grep -v lo",2239,"110703.42588424683","0","0.1","deepseek-r1","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8046,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8017,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$' | grep -E '^veth|^virbr|^docker|^br-|^tun|^tap');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",282,"20331.40778541565","0.2","0.4","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7162,"Experiment 1","HostHtml","IaC",1,2,"# Remove the existing server block configuration to avoid conflicts;rm /etc/nginx/sites-enabled/default;;# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name localhost;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -sf /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",146,"2580.4085731506348","0","0.1","gpt-4o","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
8031,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8057,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8037,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",True,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8038,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","10.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8039,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Get all non-physical interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | while read -r iface; do; if [[ ""$iface"" != ""lo"" ]] && ! [[ -d ""/sys/class/net/$iface/device"" ]]; then; echo ""$iface""; fi;done);;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",385,"21718.413829803467","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"",0,0,0,0,"","10.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8005,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap)[a-zA-Z0-9]* ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",306,"19324.238300323486","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8054,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8055,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8056,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8973,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d % text && export text",732,"39191.871881484985","0.2","0.4","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","5.85"
8974,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d % text && export text",732,"39191.871881484985","0.2","0.4","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","5.85"
8058,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8067,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if [[ -n $(ip -o addr show | grep -v lo:) ]]; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo $line | awk '{print $2}'); ip=$(echo $line | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",202,"2676.677703857422","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",1,1,0,0,"Line 4: Use grep -q instead of comparing output with [ -n .. ]. Line 7: Double quote to prevent globbing and word splitting. Line 8: Double quote to prevent globbing and word splitting. ","4.5","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","50.45"
8045,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
8049,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev ""$iface"" | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",111,"7898.27036857605","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7897,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";for iface in $(ls /sys/class/net/ | grep -v lo); do; ip=$(ip -4 addr show $iface | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $iface == ""eth""* || $iface == ""wlan""* ]]; then; continue; fi; output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",131,"2305.5570125579834","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,1,1,0,"Line 4: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. Line 5: Double quote to prevent globbing and word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8946,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",154,"11547.940254211426","0","0.1","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
6287,"Experiment 1","CountFailFiles","NL2Bash",1,2,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",36,"1162.6548767089844","0.2","0.4","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
8950,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done < /dev/stdin
echo -e ""line1\nline2%line3"" | ./yourscript.sh
# $text will contain ""line1\nline2""",165,"12033.42056274414","0","0.1","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"/media/sf_scripts/StandartInputToVariable_deepseek-v3_0_0.1_2.sh: line 8: ./yourscript.sh: No such file or directory ",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","14.100000000000001"
5422,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep VulnerabilityID | cut -d ' ' -f 2 | xargs -n1 | awk '{printf ""%s "", $0}' | { IFS= read -r codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",89,"1444.6494579315186","0.7","0.9","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.509999999999998"
7906,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" == ""lo"" || ""$iface"" == ""eth""* || ""$iface"" == ""wlan""* ]]; then; continue; fi; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); output+=""$iface - $ip""$'\n';done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",142,"2373.434543609619","0.2","0.4","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"All required virtual interfaces were not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7911,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
8990,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done

echo ""$text""",54,"1355.7870388031006","0.2","0.4","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
7912,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show $iface | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",174,"3287.196397781372","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
7917,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
7918,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v 'lo');;for iface in $interfaces; do; if [[ $iface == veth* ]] || [[ $iface == br-* ]] || [[ $iface == docker* ]] || [[ $iface == virbr* ]]; then; ip=$(ip -o -4 addr show ""$iface"" | awk '{print $4}' | cut -d/ -f1); if [ -z ""$ip"" ]; then; ip=""None""; fi; output+=""${iface} - ${ip}\n""; fi;done;;if [ -z ""$output"" ]; then; echo ""No virtual interfaces found"";else; echo -e ""$output"";fi",175,"2263.136625289917","0.7","0.9","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","64.14999999999999"
8995,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d ""%"" text",11,"964.3082618713379","0.7","0.9","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"If the last character before *%* is a space, it should still be preserved",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
5371,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities;vulnerabilities=$(trivy fs --severity HIGH --format json . | jq -r '.Results[].Vulnerabilities[] | select(.Severity == ""HIGH"" or .Severity == ""CRITICAL"") | .VulnerabilityID');;# Check if there are any vulnerabilities found;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",129,"3652.432680130005","0.2","0.4","gpt-4o","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
5375,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs . --severity HIGH,CRITICAL --format json | jq -r '.Results[].Vulnerabilities[].VulnerabilityID' | sort -u);if [ -z ""$vulns"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities:""; for code in $vulns; do; echo -n "" $code""; done; echo;fi",689,"4956.218242645264","1","1","o1-mini","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.200000000000003"
7894,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi, tikai 1 no tiem ir aktīvs",2,"",False,"Only active interfaces should be listed",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7981,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7982,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",142,"2372.76029586792","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7185,"Experiment 1","HostHtml","IaC",1,1,"mkdir -p /usr/html;chmod -R a+rX /usr/html;sed -i '/^[[:space:]]*root /s|/var/www/html;|/usr/html;|' /etc/nginx/sites-available/default;nginx -t && systemctl reload nginx",567,"31445.116758346558","0.2","0.4","deepseek-r1","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","10.05"
9037,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 printf ""%s"" ""$char""
done)",59,"2156.024217605591","0.7","0.9","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
7987,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"Device *enp0s3 eth10 eth11* does not exist. ",False,"Interfaces should be listed with their IP address in the format “{interface name} - {IP}”",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7988,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
9040,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",50,"1252.7878284454346","0.7","0.9","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
8468,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",289,"3153.223752975464","1","1","o1-mini","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7989,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -E ""vir|vnet|tap|eth|ens"" | awk -F': ' '{print $2}' | grep -v lo);;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip -4 addr show ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ip_address"" ]; then; ip_address=""None""; fi; echo ""$interface - $ip_address""; done;fi",147,"2559.3602657318115","0.2","0.4","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"Device *enp0s3 eth10 eth11* does not exist. ",False,"Interfaces should be listed with their IP address in the format “{interface name} - {IP/None}”",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7188,"Experiment 1","HostHtml","IaC",1,1,"sed -i 's|root /var/www/html;|root /usr/html;|' /etc/nginx/sites-available/default && \;nginx -t && systemctl reload nginx",1033,"53319.77653503418","0.7","0.9","deepseek-r1","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","12.2"
5716,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"1455.7926654815674","0.2","0.4","deepseek-v3",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
7993,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6138,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 esac
done",160,"3597.9018211364746","0","0.1","llama3.3-70b","arhīvs ir .gz",1,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.199999999999996"
7998,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in $virtual_interfaces; do; ip_address=$(ip addr show $interface | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",186,"2777.702808380127","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"No virtual interfaces were found but there should be 1. Perhaps the issue is that the interface is named *inet*?",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7999,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7183,"Experiment 1","HostHtml","IaC",1,1,"#!/bin/bash;# Configure nginx to serve from /usr/html;sed -i '/root \/var\/www\/html;/c\ root /usr/html;' /etc/nginx/sites-available/default;# Ensure permissions and restart nginx;chmod -R a+r /usr/html;find /usr/html -type d -exec chmod a+x {} \;;nginx -t && systemctl restart nginx",447,"35062.37053871155","0","0.1","deepseek-r1","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","10.35"
6164,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"shopt -s nullglob
for file in archive.*; do
 case ""$file"" in
 *.tar.gz|*.tgz) tar xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar xjf ""$file"" ;;
 *.tar.xz) tar xJf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar xf ""$file"" ;;
 *) echo ""Skipping unsupported file: $file"" ;;
 esac
done
shopt -u nullglob",1752,"15410.104990005493","0","0.1","deepseek-r1","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","32.9"
8001,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;virtual_interfaces=$(ip -o link show | grep -oE ""^[0-9]+: ([^:]+):"" | grep -v lo | awk '{print $2}' | grep -E ""veth|vlan|vxlan|tun|tap"");;if [ -z ""$virtual_interfaces"" ]; then; echo ""No virtual interfaces found"";else; for interface in ""$virtual_interfaces""; do; ip_address=$(ip addr show ""$interface"" | grep -oE ""inet [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"" | awk '{print $2}'); if [ -z ""$ip_address"" ]; then; echo ""$interface - None""; else; echo ""$interface - $ip_address""; fi; done;fi",192,"2476.5892028808594","0.7","0.9","llama3.3-70b","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6204,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1864.5775318145752","0.7","0.9","deepseek-v3","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6621,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1366.081953048706","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
7922,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7923,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all network interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; # Check if the interface is virtual by excluding common physical interface prefixes; if [[ ! ""$iface"" =~ ^(eth|enp|wlan|wlp|ens|eno) ]]; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet /{print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1821,"13106.649398803711","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6173,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""

# Extract based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) tar -xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar -xjf ""$file"" ;;
 *.tar.xz|*.txz) tar -xJf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.gz)  gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz)  unxz ""$file"" ;;
 *.7z)  7z x ""$file"" ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Check if extraction succeeded
if [[ $? -ne 0 ]]; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",1821,"46573.923110961914","0.7","0.9","deepseek-r1","arhīvs ir .gz",1,"",False,"",1,0,0,0,"Line 36: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","12.5","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
7928,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","9.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
7929,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Function to check if an interface is virtual;is_virtual() {; local iface=""$1""; # Check if interface has a physical driver; if ethtool -i ""$iface"" &>/dev/null; then; return 1 # Physical; else; return 0 # Virtual; fi;};;# Get all interfaces except loopback;interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$');;# Initialize a counter;count=0;;for iface in $interfaces; do; if is_virtual ""$iface""; then; # Get IPv4 address; ip_addr=$(ip -4 addr show ""$iface"" | awk '/inet / {print $2}' | cut -d'/' -f1); if [ -z ""$ip_addr"" ]; then; ip_addr=""None""; fi; echo ""${iface} - ${ip_addr}""; count=$((count + 1)); fi;done;;if [ $count -eq 0 ]; then; echo ""No virtual interfaces found"";fi",1600,"11411.662578582764","1","1","o1-mini","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"",0,0,0,0,"","9.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","39.5"
6233,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"954.1122913360596","0.7","0.9","gpt-3.5-turbo","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5400,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;vulns=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[]?.Vulnerabilities[]?.VulnerabilityID' | sort -u | xargs);;if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",1265,"55141.061782836914","0.2","0.4","deepseek-r1","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5401,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;vulns=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[]?.Vulnerabilities[]?.VulnerabilityID' | sort -u | xargs);;if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",1265,"55141.061782836914","0.2","0.4","deepseek-r1","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5403,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs --quiet --severity HIGH,CRITICAL . --template '{{.VulnerabilityID}} ' | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ *$//');if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",1750,"27535.298585891724","0.7","0.9","deepseek-r1","Projekts bez ievainojamībām",2,"",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5373,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities with at least high severity;vulnerabilities=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[].Vulnerabilities[]?.VulnerabilityID');;# Check if any vulnerabilities were found;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",119,"3352.978229522705","0.7","0.9","gpt-4o","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","18.550000000000004"
5411,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory and filter for vulnerabilities with severity ""HIGH"" or higher;vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort | uniq);;# Check if any vulnerabilities were found;if [[ -z ""$vulnerabilities"" ]]; then; echo ""The project is clean"";else; # Format the output; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",125,"3350.8474826812744","0.7","0.9","deepseek-v3","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5420,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep VulnerabilityID | cut -d ' ' -f 2 | xargs -n1 | awk '{printf ""%s "", $0}' | { read codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",80,"1448.937177658081","0.7","0.9","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T03:06:21-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T03:06:21-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T03:06:21-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T03:06:27-07:00	INFO	Number of language-specific files	num=1 2025-03-24T03:06:27-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,1,0,0,"Line 2: read without -r will mangle backslashes. ","7.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.46"
5396,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json | jq -r '.Results[] | .Vulnerabilities[] | select(.Severity == ""HIGH"" or .Severity == ""CRITICAL"") | .VulnerabilityID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",89,"3158.0774784088135","0.7","0.9","llama3.3-70b","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
6219,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1647.4695205688477","0","0.1","gpt-3.5-turbo","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6220,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1647.4695205688477","0","0.1","gpt-3.5-turbo","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5368,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities;vulnerabilities=$(trivy fs --severity HIGH --format json . | jq -r '.Results[].Vulnerabilities[] | select(.Severity == ""HIGH"") | .VulnerabilityID');;# Check if there are any high severity vulnerabilities;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",122,"3468.402147293091","0","0.1","gpt-4o","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
7201,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl start nginx
systemctl enable nginx",37,"1110.642910003662","0.2","0.4","gpt-3.5-turbo","index.html patstāvīgs",1," have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
5389,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .VulnID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",79,"4054.957389831543","0","0.1","llama3.3-70b","Projekts bez ievainojamībām",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
7198,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl start nginx
systemctl enable nginx",37,"1009.4432830810547","0","0.1","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. Synchronizing state of nginx.service with SysV service script with /lib/systemd/systemd-sysv-install. Executing: /lib/systemd/systemd-sysv-install enable nginx ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
7199,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl restart nginx",32,"1398.4355926513672","0","0.1","gpt-3.5-turbo","index.html patstāvīgs",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","5.550000000000001"
6150,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) tar -xvf ""$file"" ;;
 *.bz2) tar -xvf ""$file"" ;;
 *.xz) tar -xvf ""$file"" ;;
 *.lzma) tar --lzma -xvf ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xvf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",124,"7123.215198516846","0.2","0.4","llama3.3-70b","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.15"
7196,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed;apt update && apt install -y nginx;;# Create the default nginx site config;cat > /etc/nginx/sites-available/default <<EOF;server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files \$uri \$uri/ =404;; };};EOF;;# Create the html directory if it doesn't exist;mkdir -p /usr/html;;# Create a basic index.html if it doesn't exist;if [ ! -f /usr/html/index.html ]; then; cat > /usr/html/index.html <<EOF;<!DOCTYPE html>;<html>;<head>; <title>Welcome</title>;</head>;<body>; <h1>Welcome to nginx!</h1>;</body>;</html>;EOF;fi;;# Restart nginx to apply changes;systemctl restart nginx",213,"14360.984563827515","0.7","0.9","deepseek-v3","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7189,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed;apt update && apt install -y nginx;;# Create the default nginx site configuration;cat > /etc/nginx/sites-available/default << 'EOF';server {; listen 80 default_server;; listen [::]:80 default_server;;; root /usr/html;; index index.html;;; server_name _;;; location / {; try_files $uri $uri/ =404;; };};EOF;;# Test configuration and restart nginx;nginx -t && systemctl restart nginx",119,"10223.85048866272","0","0.1","deepseek-v3","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
6181,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""
declare -a cmd # Array to hold extraction command and arguments

# Determine extraction command based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) cmd=(tar -xzf) ;;
 *.tar.bz2|*.tbz2) cmd=(tar -xjf) ;;
 *.tar.xz|*.txz) cmd=(tar -xJf) ;;
 *.tar) cmd=(tar -xf) ;;
 *.zip) cmd=(unzip) ;;
 *.rar) cmd=(unrar x) ;;
 *.gz)  cmd=(gunzip) ;;
 *.bz2) cmd=(bunzip2) ;;
 *.xz)  cmd=(unxz) ;;
 *.7z)  cmd=(7z x) ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Execute extraction command and check exit code directly
if ! ""${cmd[@]}"" ""$file""; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",2844,"26134.623289108276","0.7","0.9","deepseek-r1","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
7080,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash
apt-get update
apt-get install -y wget build-essential autoconf automake libtool libncurses-dev libhwloc-dev pkg-config
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O /tmp/htop-3.1.0.tar.gz
tar -xzf /tmp/htop-3.1.0.tar.gz -C /tmp/
cd /tmp/htop-3.1.0
./autogen.sh
./configure --prefix=/usr/local/htop310
make -j$(nproc)
make install
ln -sf /usr/local/htop310/bin/htop /usr/local/bin/htop",2381,"293147.9163169861","0.2","0.4","deepseek-r1","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,0,2,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 9: Quote this to prevent word splitting. ","1.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.25"
6977,"Experiment 1","InstallHtop","IaC",3,1,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
cd htop-3.1.0
./configure --prefix=/usr/local/htop310
make
make install
ln -s /usr/local/htop310/bin/htop /usr/local/bin/htop",103,"5276.182413101196","0.7","0.9","llama3.3-70b","Jāinstalē htop 3.1.0",1,". .......... .......... .......... .......... 81% 6.73M 0s 300K .......... .......... .......... .......... .......... 94% 7.92M 0s 350K .......... .........     100% 1.70M=0.2s 2025-04-03 04:24:10 (1.82 MB/s) - ‘3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_llama3.3-70b_0.7_0.9.sh: line 5: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,0,1,0,"Line 5: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","3.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","9.95"
6981,"Experiment 1","InstallHtop","IaC",3,1,"#!/bin/bash;;# Install build dependencies;apt update && apt install -y build-essential autoconf automake libncurses-dev;;# Create target directory;mkdir -p /usr/local/htop310;;# Download and extract htop;cd /tmp;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz;tar xzf htop-3.1.0.tar.gz;cd htop-3.1.0;;# Compile and install;./autogen.sh;./configure --prefix=/usr/local/htop310;make;make install;;# Add to PATH;echo 'export PATH=/usr/local/htop310/bin:$PATH' > /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh;source /etc/profile.d/htop310.sh",210,"14896.85606956482","0.2","0.4","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,1,0,"Line 10: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 13: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 22: Expressions don't expand in single quotes, use double quotes for that. Line 24: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","4.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","20.349999999999998"
7081,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash
set -e
apt-get update
apt-get install -y wget build-essential autoconf automake libtool libncurses-dev libhwloc-dev pkg-config
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O /tmp/htop-3.1.0.tar.gz
tar -xzf /tmp/htop-3.1.0.tar.gz -C /tmp/
cd /tmp/htop-3.1.0 || exit 1
./autogen.sh
./configure --prefix=/usr/local/htop310
make -j""$(nproc)""
make install
ln -sf /usr/local/htop310/bin/htop /usr/local/bin/htop",4026,"369558.874130249","0.2","0.4","deepseek-r1","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","18.950000000000003"
6982,"Experiment 1","InstallHtop","IaC",3,2,"#!/bin/bash;;# Install build dependencies;apt update && apt install -y build-essential autoconf automake libncurses-dev;;# Create target directory;mkdir -p /usr/local/htop310;;# Download and extract htop;cd /tmp || exit;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz;tar xzf htop-3.1.0.tar.gz;cd htop-3.1.0 || exit;;# Compile and install;./autogen.sh;./configure --prefix=/usr/local/htop310;make;make install;;# Add to PATH;echo 'export PATH=$PATH:/usr/local/htop310/bin' > /etc/profile.d/htop310.sh;chmod +x /etc/profile.d/htop310.sh;. /etc/profile.d/htop310.sh;;# Verify installation;if /usr/local/htop310/bin/htop --version; then; echo ""htop successfully installed and added to PATH"";else; echo ""Installation failed"" >&2; exit 1;fi",359,"20017.323970794678","0.2","0.4","deepseek-v3","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,0,0,"Line 22: Expressions don't expand in single quotes, use double quotes for that. Line 24: Not following: /etc/profile.d/htop310.sh was not specified as input (see shellcheck -x). ","6.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","35.400000000000006"
8412,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\(\(.*\n\)\{5\}\)$//' data.md",33,"1051.2404441833496","0.7","0.9","gpt-4o","data.md ar 4 rindām",3,"",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.45"
6157,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"2651.2489318847656","0.7","0.9","llama3.3-70b","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.550000000000004"
6156,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"3465.360403060913","0.7","0.9","llama3.3-70b","arhīvs ir .7z",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.55"
6987,"Experiment 1","InstallHtop","IaC",3,1,"# Install required build tools
apt update
apt install -y build-essential

# Download the source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir -p /usr/local/htop310
tar -xzf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310
./autogen.sh
./configure
make
make install

# Add htop binary to the system path
ln -s /usr/local/bin/htop /usr/local/htop310/htop

# Clean up
rm htop-3.1.0.tar.gz",221,"3560.903549194336","0.2","0.4","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"igure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ln: failed to create symbolic link '/usr/local/htop310/htop': File exists rm: cannot remove 'htop-3.1.0.tar.gz': No such file or directory ",False,"Htop was not installed to the correct directory",0,0,1,0,"Line 14: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","3.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.600000000000001"
6963,"Experiment 1","InstallHtop","IaC",3,1,"# Download and extract Htop source code;mkdir -p /usr/local/htop310;cd /usr/local/htop310;wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz;tar -xzf 3.1.0.tar.gz --strip-components=1;;# Install necessary dependencies for building Htop;apt update;apt install -y build-essential autotools-dev autoconf libncurses5-dev;;# Compile and install Htop;./autogen.sh;./configure;make;make install;;# Add Htop binary to PATH;echo 'export PATH=$PATH:/usr/local/htop310' >> /etc/profile;source /etc/profile",160,"2873.792886734009","0.7","0.9","gpt-4o","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,2,1,0,"Line 4: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 19: Expressions don't expand in single quotes, use double quotes for that. Line 20: Not following: /etc/profile was not specified as input (see shellcheck -x). ","1.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.500000000000002"
5745,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"1441.9188499450684","0.2","0.4","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5736,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"2147.5472450256348","0","0.1","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
6973,"Experiment 1","InstallHtop","IaC",3,1,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
mv htop-3.1.0 /usr/local/htop310
cd /usr/local/htop310/htop-3.1.0
./configure --prefix=/usr/local/htop310
make
make install
echo ""export PATH=$PATH:/usr/local/htop310/bin"" >> /etc/profile
source /etc/profile",131,"1750.1146793365479","0","0.1","llama3.3-70b","Jāinstalē htop 3.1.0",1,"... .......... .......... .......... .......... 81% 6.52M 0s 300K .......... .......... .......... .......... .......... 94% 11.3M 0s 350K .......... .........     100% 31.1M=0.2s 2025-04-03 04:21:54 (2.00 MB/s) - ‘3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_llama3.3-70b_0_0.1.sh: line 6: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,1,1,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","2.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","12.65"
5681,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env && echo ""$USERNAME""",1262,"21938.18426132202","0","0.1","deepseek-r1",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5682,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env && echo ""$USERNAME""",1262,"21938.18426132202","0","0.1","deepseek-r1",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5728,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo $USERNAME",14,"1648.5297679901123","0.7","0.9","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,2,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: Double quote to prevent globbing and word splitting. ","6.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5737,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"2147.5472450256348","0","0.1","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5591,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"1446.8586444854736","0.2","0.4","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5581,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"2768.0625915527344","0","0.1","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5663,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"2146.8234062194824","0.2","0.4","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
8525,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8526,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6158,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"2651.2489318847656","0.7","0.9","llama3.3-70b","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.550000000000004"
5667,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep ""^USERNAME="" .env | cut -d ""="" -f2-)
echo ""$USERNAME""",27,"1269.089698791504","0.2","0.4","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5651,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"1548.0294227600098","0","0.1","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
8530,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;while IFS='=' read -r key_temp value_temp; do; # Trim whitespace and quotes from key and value; key=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$key_temp""); value=$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//' <<< ""$value_temp""); # Skip empty keys and system-like variables; if [[ -n ""$key"" && ! ""$key"" =~ ^[0-9] && ""$key"" != *=* ]]; then; export ""$key""=""$value""; fi;done < <(grep -vE '^[[:space:]]*([;#]|\[|$)' settings.ini)",1890,"86760.00118255615","0.2","0.4","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
6811,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6813,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Function to display usage
usage() {
 echo ""Usage: $0 [--sc] [--sd] [--dr | --dk | --dd] [--sw] source_dir destination_dir""
 exit 1
}

# Initialize flags
COPY_SOURCE=false
DELETE_SOURCE=false
REPLACE_DEST=false
KEEP_DEST=false
DELETE_DEST=false
SWAP=false

# Parse flags
while [[ ""$1"" == --* ]]; do
 case ""$1"" in
 --sc)
 COPY_SOURCE=true
 ;;
 --sd)
 DELETE_SOURCE=true
 ;;
 --dr)
 REPLACE_DEST=true
 ;;
 --dk)
 KEEP_DEST=true
 ;;
 --dd)
 DELETE_DEST=true
 ;;
 --sw)
 SWAP=true
 ;;
 *)
 echo ""Unknown flag: $1""
 usage
 ;;
 esac
 shift
done

# Check for source and destination directories
if [ ""$#"" -ne 2 ]; then
 usage
fi

SOURCE=""${1:?}""
DESTINATION=""${2:?}""

# Validate source and destination directories
if [ ! -d ""${SOURCE}"" ]; then
 echo ""Source directory does not exist.""
 exit 1
fi

if [ ! -d ""${DESTINATION}"" ]; then
 echo ""Destination directory does not exist.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 TEMP_DIR=$(mktemp -d)
 rsync -a --delete ""${SOURCE}/"" ""${TEMP_DIR}/""
 rsync -a --delete ""${DESTINATION}/"" ""${SOURCE}/""
 rsync -a --delete ""${TEMP_DIR}/"" ""${DESTINATION}/""
 rm -rf ""${TEMP_DIR}""
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""${DESTINATION:?}/""*
fi

RSYNC_OPTS=""-a""

if [ ""$KEEP_DEST"" = true ]; then
 RSYNC_OPTS+="" --ignore-existing""
fi

rsync $RSYNC_OPTS ""${SOURCE}/"" ""${DESTINATION}/""

if [ ""$DELETE_SOURCE"" = true ]; then
 rm -rf ""${SOURCE:?}/""*
fi",1895,"10925.30608177185","1","1","o1-mini","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,1,1,0,"Line 21: COPY_SOURCE appears unused. Verify use (or export if used externally). Line 27: REPLACE_DEST appears unused. Verify use (or export if used externally). Line 84: Double quote to prevent globbing and word splitting. ","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8199,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash
mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' found_file; do
 docx_file=""${found_file%.found}""
 mv -f ""$found_file"" /etc/movedDocs/ 2>/dev/null
 mv -f ""$docx_file"" /etc/movedDocs/ 2>/dev/null
done",1395,"53673.779010772705","0.2","0.4","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.3"
8218,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2480.368137359619","0.2","0.4","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8204,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 docx_file=""${file%.found}""
 mv -- ""$file"" ""/etc/movedDocs/""
 mv -- ""$docx_file"" ""/etc/movedDocs/""
done",2190,"81895.89619636536","0.7","0.9","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.2"
8219,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2480.368137359619","0.2","0.4","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8226,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2177.638053894043","0.7","0.9","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8225,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"2177.638053894043","0.7","0.9","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
5152,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
8217,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"1874.6206760406494","0.2","0.4","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
8222,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 base_name=""${file%.found}""
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"6689.266204833984","0.7","0.9","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
8256,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 docx_file=""${file%.found}""
 if [ -f ""$docx_file"" ]; then
 mv ""$file"" ""$docx_file"" /etc/movedDocs
 fi
done",71,"2196.0487365722656","0","0.1","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","13.6"
9397,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C ""$1"" ""mysqldump -u TEST_USER -pTEST TEST_DB"" | mysql -u TEST_USER -pTEST TEST_DB",39,"6787.056684494019","0.7","0.9","deepseek-v3","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
9393,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C ""$1"" ""mysqldump -u TEST_USER -pTEST TEST_DB"" | mysql -u TEST_USER -pTEST TEST_DB",39,"6286.839008331299","0","0.1","deepseek-v3","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
7128,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"1378.8409233093262","0","0.1","llama3.3-70b","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
9001,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d '%' text",535,"3997.265100479126","1","1","o1-mini","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"If the last character before *%* is a space, it should still be preserved",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
5580,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"2768.0625915527344","0","0.1","gpt-4o",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8262,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"2182.0149421691895","0.2","0.4","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
8268,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"1567.2264099121094","0.7","0.9","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
9429,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"# Dump the MySQL database over a compressed SSH tunnel
ssh -C $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip > test_db_dump.sql.gz

# Transfer the compressed dump file back to local machine
scp $1:/path/to/test_db_dump.sql.gz /tmp/

# Import the dump file to local MySQL
gunzip < /tmp/test_db_dump.sql.gz | mysql -u TEST_USER -pTEST TEST_DB",101,"1461.9193077087402","0.7","0.9","gpt-3.5-turbo","jāpārnes datubāze",1,"mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces scp: /path/to/test_db_dump.sql.gz: No such file or directory /media/sf_scripts/MysqlDumpOverSSH_gpt-3.5-turbo_0.7_0.9.sh: line 8: /tmp/test_db_dump.sql.gz: No such file or directory mysql: [Warning] Using a password on the command line interface can be insecure. ",False,"The data was not transferred to the other database",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. Line 6: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","13.05"
9408,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh ""$1"" ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",40,"1532.7682495117188","0.2","0.4","gpt-4o","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
8899,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1356.445550918579","0","0.1","llama3.3-70b","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
9304,"Experiment 1","PrintTable","NL2Bash",3,1,"join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; [[ $line =~ ^Exe ]] && echo ""$line""; join -j 1 <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe"")",75,"2761.021137237549","0.2","0.4","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9301,"Experiment 1","PrintTable","NL2Bash",3,2,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; echo ""$line""; grep -v ""^$line"" <(join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt))) | column -t",96,"1877.9685497283936","0","0.1","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5063,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
7252,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature""; then
 echo ""OK""
else
 echo ""FAIL""
fi",156,"11599.210262298584","0.7","0.9","deepseek-v3","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","16.1"
5079,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 58d5768..9b25016 develop -> origin/develop Already on 'develop' fatal: Not possible to fast-forward, aborting. fatal: invalid reference: stash No stash entries found. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
5064,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD cef23dc..656064d develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5068,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD b31e94e..12a8b75 develop -> origin/develop ",False,"Changes weren't pulled.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5074,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5075,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5080,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","8.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
5082,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"",False,"",0,0,0,0,"","8.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
5053,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5059,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git pull --strategy=ours origin develop",488,"9955.323457717896","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5119,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 87d6cdd..7d7c191 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5104,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5105,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5115,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5116,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5113,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5492,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2073.0814933776855","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6612,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"1050.0049591064453","0.2","0.4","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.799999999999999"
6613,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1367.9742813110352","0.7","0.9","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6615,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -E -v '^$' | wc -l",20,"1047.8804111480713","0.7","0.9","gpt-4o","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","","NO_RISK","Count number of users logged in","6.1"
6631,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -vE '^#' | wc -l w -h | wc -l",52,"2053.034543991089","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","","NO_RISK","Count number of users logged in","11.75"
5267,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Delete all files according to .gitignore
find . -type f -print | git check-ignore --stdin | xargs rm -f",35,"1350.208044052124","0.7","0.9","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.3"
5279,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",80,"6404.958248138428","0.2","0.4","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
7315,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1316.918134689331","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7703,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | head -n 1 | awk '{print ""IP: "" $1}'",48,"7281.9883823394775","0.7","0.9","deepseek-v3","Viens fizisks interfeiss + loopback",1,"",False,"The correct IP address was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
8660,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read and parse INI file;while IFS='= ' read -r key value; do; # Skip comments and empty lines; [[ ""$key"" =~ ^[[:space:]]*# ]] && continue; [[ -z ""$key"" ]] && continue; # Remove quotes if present; value=""${value%\""}""; value=""${value#\""}""; # Export the variable; declare -g ""$key""=""$value"";done < ""settings.ini"";;# Optional: list all loaded variables for verification;declare -p $(grep -oP '^[^=]+' settings.ini | tr '\n' ' ')",272,"17202.08477973938","0.2","0.4","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,1,0,"Line 18: Quote this to prevent word splitting. ","11.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","22.949999999999996"
5493,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2073.0814933776855","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
7398,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",2404,"133533.80250930786","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7311,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"2189.7037029266357","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
6653,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | awk '{print $1}' | sort -u | wc -l",1976,"18515.494346618652","0.7","0.9","deepseek-r1","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.549999999999999"
5453,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in ./*.sh; do
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",444,"3579.9190998077393","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6200,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"9391.114711761475","0.2","0.4","deepseek-v3","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
7334,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1272.4463939666748","0.7","0.9","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7316,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1316.918134689331","0","0.1","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6514,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",38,"1144.3023681640625","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
6413,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, 'NR > 1 {gsub(/""/, """", $3); gsub(/,/, """", $3); gsub(/\./, """", $3); sub(/,/, ""."", $3); sum += $3; count++} END {if (count > 0) printf ""Mean: %.2f\n"", sum/count; else print ""Mean: 0.00""}' products.csv",93,"2059.1306686401367","0.7","0.9","gpt-4o","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","5.09"
5148,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 41cb92e..a624f4f develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
5578,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 ./""$script"" &> /dev/null
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",58,"1348.3924865722656","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","15.799999999999999"
7319,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1065.5615329742432","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
6632,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -vE '^#' | wc -l w -h | wc -l",52,"2053.034543991089","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","11.75"
7320,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1065.5615329742432","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7321,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1065.5615329742432","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
6656,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"w -hs | awk '{print $1}' | sort -u | wc -l",2337,"78056.16736412048","0.7","0.9","deepseek-r1","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","10.6"
8858,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""${file##*/}""
done",30,"1450.4234790802002","0","0.1","llama3.3-70b","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8880,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 reversed=$(printf ""%s"" ""$line"" | rev)
 printf ""result = %s\n"" ""$reversed""
done < info.txt",1329,"60973.99067878723","0.2","0.4","deepseek-r1","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","7.699999999999999"
7040,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",212,"2450.3164291381836","0.2","0.4","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
7380,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"5681.389808654785","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5764,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo ""$USERNAME""",29,"948.2383728027344","0.7","0.9","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4952,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4928,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7251,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature""; then
 echo ""OK""
else
 echo ""FAIL""
fi",156,"11599.210262298584","0.7","0.9","deepseek-v3","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","16.1"
7256,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1953.2959461212158","0","0.1","gpt-3.5-turbo","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
6663,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | tr ' ' '\n' | sort -u | wc -l;who | awk '{print $1}' | sort -u | wc -l",142,"8569.01741027832","0.2","0.4","deepseek-v3","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","16.95"
6664,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | tr ' ' '\n' | sort -u | wc -l;who | awk '{print $1}' | sort -u | wc -l",142,"8569.01741027832","0.2","0.4","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","16.95"
7272,"Experiment 1","Factorial","NL2Bash",2,1,"echo *define f(x) { if (x <= 1) return (1); return (x * f(x - 1)); } f(623)* | bc",42,"1869.1027164459229","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","3.65"
6658,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"5873.924732208252","0","0.1","deepseek-v3","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6670,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"758.8369846343994","0.2","0.4","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6672,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | cut -d' ' -f1 | sort | uniq | wc -l",24,"844.7096347808838","0.2","0.4","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.65"
6673,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"941.2429332733154","0.7","0.9","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6674,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"941.2429332733154","0.7","0.9","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6675,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | grep -v pts | wc -l",16,"1251.2829303741455","0.7","0.9","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","9.0","","NO_RISK","Count number of users logged in","6.050000000000001"
6665,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1050.734519958496","0","0.1","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
5212,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -z --exclude-standard | xargs -0 rm",22,"1451.4076709747314","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git rm: missing operand Try 'rm --help' for more information. ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
7265,"Experiment 1","Factorial","NL2Bash",2,1,"echo ""623!"" | bc -l",14,"1315.2968883514404","0","0.1","gpt-4o","Jāaprēķina faktoriālis",1,"(standard_in) 1: syntax error ",False,"The correct result was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate the factorial of 623","5.7"
7565,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"false",30,"1756.3908100128174","0","0.1","llama3.3-70b","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7273,"Experiment 1","Factorial","NL2Bash",2,1,"echo *define f(x) { if (x <= 1) return (1); return (x * f(x - 1)); } f(623)* | bc",42,"1873.500108718872","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","3.65"
7271,"Experiment 1","Factorial","NL2Bash",2,1,"echo *define f(x) { if (x <= 1) return (1); return (x * f(x - 1)); } f(623)* | bc",42,"1865.5931949615479","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","3.65"
7326,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1409.6078872680664","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5494,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2073.0814933776855","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8324,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 + 7 - $(date -d '2013-05-01' +%w) days"" +%Y-%m-%d",43,"1678.760290145874","0.2","0.4","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘2013-05-01 + 7 - 3 days’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
7266,"Experiment 1","Factorial","NL2Bash",2,2,"echo ""define f(x) { if (x <= 1) return (1); return (x * f(x-1)); } f(623)"" | bc -l",42,"6196.732521057129","0","0.1","gpt-4o","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","5.7"
5496,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"1854.6984195709229","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
7123,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1560.9934329986572","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
6667,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"1557.7309131622314","0","0.1","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","6.799999999999999"
6668,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort | uniq | wc -l",22,"1557.7309131622314","0","0.1","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","6.799999999999999"
7357,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1421.1153984069824","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6785,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","7.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8943,"Experiment 1","CleanZombies","NL2Bash",3,1,"# Find all zombie processes and kill their parent process with SIGKILL
pkill -P 1 -KILL",30,"1165.5328273773193","0.7","0.9","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"Only zombie process direct parents should be killed",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","1.45"
6666,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"1050.734519958496","0","0.1","gpt-3.5-turbo","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
5497,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"1854.6984195709229","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5715,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"1455.7926654815674","0.2","0.4","deepseek-v3",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
7100,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"1028.4082889556885","0","0.1","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7001,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Start PostgreSQL service;systemctl restart postgresql;;# Ensure init.sql has the correct permissions;chmod 644 /root/init.sql;;# Switch to the postgres user to setup the database;sudo -i -u postgres bash << EOF;;# Create the ""storedb"" database;psql -c ""CREATE DATABASE storedb;"";;# Run the SQL script;psql -d storedb -f /root/init.sql;;EOF;;# Switch to the postgres user to setup the user and permissions;sudo -i -u postgres bash << EOF;;# Create the ""public_view"" user with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Create the schema ""common_data"" if it doesn't exist;psql -d storedb -c ""CREATE SCHEMA IF NOT EXISTS common_data;"";;# Grant read-only access to the ""public_view"" user on the ""common_data"" schema;psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",334,"4226.841688156128","0.7","0.9","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"nterface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: chmod: cannot access '/root/init.sql': No such file or directory psql: error: /root/init.sql: Permission denied ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","21.050000000000004"
6188,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"8972.585678100586","0","0.1","deepseek-v3","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6239,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",13,"851.8917560577393","0.7","0.9","gpt-3.5-turbo","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6149,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) tar -xvf ""$file"" ;;
 *.bz2) tar -xvf ""$file"" ;;
 *.xz) tar -xvf ""$file"" ;;
 *.lzma) tar --lzma -xvf ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xvf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",124,"7123.215198516846","0.2","0.4","llama3.3-70b","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.15"
7054,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash;set -e;;export DEBIAN_FRONTEND=noninteractive;;# Update package lists;apt update;;# Install PostgreSQL 17;apt install -y postgresql-17;;# Upgrade the 'main' cluster from version 16 to 17;pg_upgradecluster 16 main;;# Remove the old PostgreSQL 16 cluster;pg_dropcluster 16 main;;# Optionally, remove the old PostgreSQL 16 packages if no longer needed;# apt remove -y postgresql-16",1790,"11384.678840637207","1","1","o1-mini","Jāinstalē postgres 17",2,"",True,"",0,0,0,0,"","13.0","","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","8.3"
8932,"Experiment 1","CleanZombies","NL2Bash",3,2,"#!/bin/bash # Find all zombie processes and their parent PIDs zombies=$(ps -eo pid,ppid,state,cmd | awk '$3 == *Z* {print $2}') # Kill the parent processes with SIGKILL for ppid in *$zombies*; do kill -9 *$ppid* done",75,"3190.548896789551","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,0,0,1,"Line 7: Since you double quoted this, it will not word split, and the loop will only run once. ","10.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","4.7"
8924,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo stat,ppid | awk '/^Z/ {print $2}' | sort -u); do; kill -9 $pid;done",43,"1575.7355690002441","0.2","0.4","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8930,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash ps -eo pid,ppid,state,cmd | awk '$3 == *Z* {print $2}' | xargs -I {} kill -9 {}",41,"1764.2982006072998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","8.7"
8931,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash # Find all zombie processes and their parent PIDs zombies=$(ps -eo pid,ppid,state,cmd | awk '$3 == *Z* {print $2}') # Kill the parent processes with SIGKILL for ppid in $zombies; do kill -9 $ppid done",75,"3990.884304046631","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","4.7"
7337,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",605,"4372.336626052856","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
8898,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1356.445550918579","0","0.1","llama3.3-70b","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
5501,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1666.9518947601318","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8929,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash ps -eo pid,ppid,state,cmd | awk '$3 == *Z* {print $2}' | xargs -I {} kill -9 {}",41,"1775.543212890625","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","8.7"
6245,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l",25,"1149.5943069458008","0.2","0.4","gpt-4o","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
6640,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1447.7064609527588","0.2","0.4","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
8916,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash;;# Find all zombie processes and get their PPIDs;zombie_ppids=$(ps -A -ostat,ppid | awk '/[Zz]/{print $2}' | sort -u);;if [[ -z ""$zombie_ppids"" ]]; then; echo ""No zombie processes found""; exit 0;fi;;# Kill each parent process with SIGKILL;for ppid in $zombie_ppids; do; if [[ $ppid -ne 1 ]]; then # Don't kill init (PID 1); echo ""Killing parent process $ppid of zombie process(es)""; kill -9 ""$ppid""; else; echo ""Cannot kill init (PID 1) which has zombie children""; fi;done;;echo ""Zombie cleanup complete""",277,"17829.354524612427","0","0.1","deepseek-v3","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","27.400000000000006"
8925,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in $(ps -eo stat,ppid | awk '/^Z/ {print $2}' | sort -u); do; kill -9 ""$pid"";done",43,"1539.726972579956","0.2","0.4","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
7106,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest",29,"1213.5059833526611","0.2","0.4","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
4742,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' ./* 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",936,"7771.199941635132","1","1","o1-mini","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","9.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7554,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2475.473642349243","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
8923,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in $(ps -eo stat,ppid | awk '$1 ~ /Z/ {print $2}' | sort -u); do; kill -9 ""$pid"";done",45,"1451.7054557800293","0","0.1","gpt-4o","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8542,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,0,"","9.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8928,"Experiment 1","CleanZombies","NL2Bash",3,1,"#!/bin/bash;ps -eo ppid,state | awk '$2 == ""Z"" {print $1}' | sort -u | xargs kill -9",691,"5703.152894973755","1","1","o1-mini","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","10.9"
8866,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"#!/bin/bash
for src_file in /usr/src/*.java; do
 if [ -f ""$src_file"" ]; then
 ln -s ""$src_file"" ""./$(basename ""$src_file"")""
 fi
done",55,"8173.0711460113525","0.2","0.4","deepseek-v3","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","9.899999999999999"
7037,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",211,"3394.831418991089","0","0.1","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
7460,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -22",21,"1361.4814281463623","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5500,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1666.9518947601318","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5506,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2657.7975749969482","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
7119,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1557.2524070739746","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7039,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",212,"2450.3164291381836","0.2","0.4","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
5117,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
7117,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker ps -a docker start alpine-linux-container docker inspect alpine-linux-container | grep -A 5 Mounts docker rm -f alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",176,"4396.16584777832","0","0.1","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.9"
7094,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash
apt-get update
apt-get install -y postgresql-17
systemctl stop postgresql@17-main || true
pg_dropcluster 17 main --stop || true
systemctl stop postgresql@16-main
pg_upgradecluster -v 17 16 main
systemctl start postgresql@17-main
echo ""Upgrade completed. Verify the new cluster and remove the old one with: pg_dropcluster 16 main --stop""",3054,"146743.60990524292","0","0.1","deepseek-r1","Jāinstalē postgres 17",2,"ed in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: specified cluster does not exist ",False,"Old cluster was not removed after upgrading",0,0,0,0,"","9.5","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","15.9"
8859,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""${file##*/}""
done",30,"1450.4234790802002","0","0.1","llama3.3-70b","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8704,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
7103,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"1388.7181282043457","0.2","0.4","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
8864,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""./$(basename ""$file"")""
done",33,"6769.076347351074","0","0.1","deepseek-v3","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8865,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""./$(basename ""$file"")""
done",33,"6769.076347351074","0","0.1","deepseek-v3","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
5188,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1755.662441253662","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
8401,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",1768,"82214.41197395325","0.7","0.9","deepseek-r1","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8573,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
7066,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the PostgreSQL service;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;mkdir -p /var/lib/postgresql/17/main;;# Use pg_upgrade to upgrade the data;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf' \;  -U postgres;;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16/main;;# Update the PostgreSQL configuration files;mv /etc/postgresql/16/main/postgresql.conf /etc/postgresql/17/main/;;# Update the PostgreSQL service to use the new version;update-alternatives --set postgresql-cluster 17;;# Start the PostgreSQL service;systemctl start postgresql@17-main",241,"2741.1856651306152","0.7","0.9","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","11.85"
8475,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} +",20,"1254.054069519043","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
4832,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Extract and sort user values from all files;users=$(find . -maxdepth 1 -type f -exec jq -r '.user // empty' {} \; 2>/dev/null | sort);;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format users into comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: ${user_list}"";fi",2154,"161350.6784439087","0.2","0.4","deepseek-r1","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
5792,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"2350.4719734191895","0","0.1","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7120,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1557.2524070739746","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
8574,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
5534,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1872.4009990692139","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6039,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",116,"12598.838806152344","0","0.1","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6040,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",116,"12598.838806152344","0","0.1","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5229,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -dfX",1455,"19021.294355392456","0.7","0.9","deepseek-r1","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5503,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1666.9518947601318","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6309,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",22,"7526.784181594849","0.2","0.4","deepseek-v3","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6028,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",673,"9572.643518447876","0.7","0.9","deepseek-r1","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6030,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/! s/^/#/' settings.env",802,"9473.279476165771","0.7","0.9","deepseek-r1","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6036,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"1646.543264389038","0","0.1","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6037,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"1646.543264389038","0","0.1","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5433,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1668.386697769165","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
7126,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker inspect alpine-linux-container | grep Mounts -A 10 docker stop alpine-linux-container docker rm alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null docker inspect alpine-linux-container | grep Mounts -A 10 mkdir -p /usr/alpinedata docker restart alpine-linux-container docker inspect alpine-linux-container | grep Mounts -A 10",208,"5094.752311706543","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","24.95"
6041,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",116,"12598.838806152344","0","0.1","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6058,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"843.9152240753174","0","0.1","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6059,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"843.9152240753174","0","0.1","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5251,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"# Install git if not already installed
apt-get install -y git

# Use git to clean the directory based on .gitignore rules
git clean -Xdf",82,"4283.616065979004","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","2.8499999999999996"
5254,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Install rsync if not already installed
apt-get install -y rsync

# Create a temporary directory
temp_dir=$(mktemp -d)

# Use rsync to exclude files listed in .gitignore
rsync -a --exclude-from=.gitignore ./ ""$temp_dir""

# Replace the current directory with the filtered contents
rm -rf ./*
mv ""$temp_dir""/* .

# Clean up the temporary directory
rm -rf ""$temp_dir""",186,"5150.416851043701","0.7","0.9","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.450000000000001"
8692,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
6050,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2148.9009857177734","0.7","0.9","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6054,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",115,"10984.790563583374","0.7","0.9","deepseek-v3","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7127,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"1378.8409233093262","0","0.1","llama3.3-70b","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
6057,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",115,"10984.790563583374","0.7","0.9","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8669,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",311,"20309.45324897766","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
8711,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",153,"2404.2155742645264","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,1,0,0,"Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8358,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",1767,"10897.801160812378","1","1","o1-mini","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
5089,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7072,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the current PostgreSQL cluster
systemctl stop postgresql

# Upgrade PostgreSQL to version 17
apt update
apt install postgresql-17

# Upgrade the cluster to version 17
pg_upgradecluster 16 main

# Start the new PostgreSQL 17 cluster
systemctl start postgresql@17-main",70,"1473.7303256988525","0","0.1","gpt-3.5-turbo","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","6.950000000000001"
7073,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the current PostgreSQL cluster
systemctl stop postgresql

# Upgrade PostgreSQL to version 17
apt update
apt install postgresql-17

# Upgrade the cluster to version 17
pg_dropcluster 17 main --stop
pg_upgradecluster 16 main

# Start the new PostgreSQL 17 cluster
systemctl start postgresql@17-main",79,"2033.430576324463","0","0.1","gpt-3.5-turbo","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","8.4"
8389,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"853.8401126861572","0.2","0.4","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
8390,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"853.8401126861572","0.2","0.4","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
7360,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1273.7178802490234","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7076,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the current PostgreSQL 16 cluster
pg_dropcluster 16 main

# Upgrade to PostgreSQL 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 cluster
pg_ctlcluster 17 main start",51,"1576.148271560669","0.7","0.9","gpt-3.5-turbo","Jāinstalē postgres 17",2,"Error: This cluster is still running. Stop it or supply the --stop option Error: cluster 16/main is already on version 16. (The newest version installed on this system is 16.) Error: specified cluster '17 main' does not exist ",False,"Postgres 17 was not installed (based on *psql --version*)",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","4.25"
4867,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
9310,"Experiment 1","PrintTable","NL2Bash",3,2,"(join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep -v ""^Exe""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | grep ""^Exe"") | column -t",90,"10806.246995925903","0.7","0.9","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5505,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2657.7975749969482","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
7131,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"2256.8185329437256","0.7","0.9","llama3.3-70b","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
7075,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the current PostgreSQL cluster
systemctl stop postgresql

# Upgrade PostgreSQL to version 17
apt update
apt install postgresql-17

# Upgrade the cluster to version 17
pg_dropcluster 17 main --stop
pg_upgradecluster 16 main

# Start the new PostgreSQL 17 cluster
systemctl start postgresql@17-main",79,"1396.89040184021","0.2","0.4","gpt-3.5-turbo","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","8.4"
5156,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1307.0316314697266","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5161,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"if [ -d .git ]; then
 git clean -fdX
else
 echo ""Initializing a temporary git repository to use .gitignore""
 git init
 git add .
 git commit -m ""Initial commit""
 git clean -fdX
 rm -rf .git
fi",70,"2009.1776847839355","0","0.1","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","20.199999999999996"
7132,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"2256.8185329437256","0.7","0.9","llama3.3-70b","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
6822,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7367,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1656.1775207519531","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
4903,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
5175,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -X -f -d",410,"3212.918519973755","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.5"
7177,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"2469.484329223633","0","0.1","llama3.3-70b","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
9300,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/!d' | sort | (read -r line; echo ""$line""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/d')",102,"2166.442632675171","0","0.1","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5171,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"git init
git add .
git commit -m ""Initial commit""
git clean -fdX",25,"1061.1178874969482","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.6"
5192,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Use git to identify and delete files according to .gitignore git clean -fdx",57,"1679.9092292785645","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"A file was deleted that should not have been.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","9.6"
5182,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1606.9893836975098","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
6825,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7711.2250328063965","0","0.1","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8479,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} \;",21,"1258.3930492401123","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
5186,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1755.662441253662","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
5183,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4324.1868019104","0","0.1","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
7372,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"2375.4961490631104","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5623,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1650.8996486663818","0","0.1","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
6827,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A file was deleted from destination (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
8441,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1254.7235488891602","0.2","0.4","gpt-3.5-turbo","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
7137,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",753,"41407.99522399902","0.7","0.9","deepseek-r1","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
5200,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -i --exclude-standard | xargs rm -rf",22,"1563.1396770477295","0","0.1","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
5193,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Use git to identify and delete files according to .gitignore git clean -fdx",57,"1679.9092292785645","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",False,"A file was deleted that should not have been.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","9.6"
7138,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",753,"41407.99522399902","0.7","0.9","deepseek-r1","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
7374,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"2375.4961490631104","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5195,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Restore files that were deleted by git clean git checkout -- .gitignore data.log program.js #!/bin/bash # Ensure extundelete is installed if ! command -v extundelete &> /dev/null; then apt install -y extundelete fi # Replace /dev/sdXN with the actual partition where the files were deleted extundelete /dev/sdXN --restore-all",278,"7098.963260650635","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1," caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: extundelete: No such file or directory /dev/sdXN extundelete: No such file or directory when trying to open filesystem /dev/sdXN ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","19.349999999999998"
7178,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"2469.484329223633","0","0.1","llama3.3-70b","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
7140,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create the directory on the host if it doesn't exist;mkdir -p /usr/alpinedata;;# Run the Alpine container with the volume mount;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",68,"7284.186840057373","0","0.1","deepseek-v3","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
6168,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Enable nullglob to prevent literal interpretation if no files match
shopt -s nullglob

# Find all files matching archive.* pattern
files=(archive.*)

# Check if exactly one file exists
if [[ ${#files[@]} -ne 1 ]]; then
 echo ""Error: Exactly one archive.* file must exist in the current directory"" >&2
 exit 1
fi

filename=""${files[0]}""

# Extract based on file extension
case ""$filename"" in
 *.tar.bz2|*.tbz2) tar xjf ""$filename"" ;;
 *.tar.gz|*.tgz) tar xzf ""$filename"" ;;
 *.tar.xz) tar xJf ""$filename"" ;;
 *.tar) tar xf ""$filename"" ;;
 *.zip) unzip ""$filename"" ;;
 *.gz)  gunzip ""$filename"" ;;
 *.bz2) bunzip2 ""$filename"" ;;
 *.rar) unrar x ""$filename"" ;;
 *.7z)  7z x ""$filename"" ;;
 *)
 echo ""Unsupported archive format: $filename"" >&2
 exit 1
 ;;
esac

echo ""Extracted $filename successfully""",1753,"16222.480058670044","0.2","0.4","deepseek-r1","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6831,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*${1}* DESTINATION=*${2}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DESTINATION.tmp/* rsync -a --delete *$DESTINATION/* *$SOURCE/* rsync -a --delete *$DESTINATION.tmp/* *$DESTINATION/* rm -rf *$DESTINATION.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *$DESTINATION*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *$SOURCE/* *$DESTINATION/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *$SOURCE/* *$DESTINATION/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *$SOURCE*/* fi fi",331,"7567.532539367676","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6833,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A file was deleted from destination (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
5196,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt install -y git fi # Restore files that were deleted by git clean git checkout -- .gitignore data.log program.js #!/bin/bash # Ensure extundelete is installed if ! command -v extundelete &> /dev/null; then apt install -y extundelete fi # Replace /dev/sdXN with the actual partition where the files were deleted extundelete /dev/sdXN --restore-all",278,"7098.963260650635","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2," caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: extundelete: No such file or directory /dev/sdXN extundelete: No such file or directory when trying to open filesystem /dev/sdXN ",False,"A file was not deleted that should have been.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","19.349999999999998"
5095,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 87d6cdd..7d7c191 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5176,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -X -f -d",410,"3212.918519973755","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"fatal: not a git repository (or any of the parent directories): .git ",False,"A file was not deleted that should have been.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.5"
4614,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",779,"14366.31989479065","0.2","0.4","deepseek-r1","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"find: Unknown argument to -type: ( ",False,"One or more images were not deleted.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.7"
6838,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DESTINATION=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DESTINATION=true KEEP_IN_DESTINATION=false DELETE_ALL_IN_DESTINATION=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DESTINATION=true ;;  --dk) KEEP_IN_DESTINATION=true ;;  --dd) DELETE_ALL_IN_DESTINATION=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DESTINATION}.tmp/* rsync -a --delete *${DESTINATION}/* *${SOURCE}/* rsync -a --delete *${DESTINATION}.tmp/* *${DESTINATION}/* rm -rf *${DESTINATION}.tmp/* else if $DELETE_ALL_IN_DESTINATION; then  rm -rf *${DESTINATION}*/* fi  if $COPY_FROM_SOURCE; then  if $REPLACE_IN_DESTINATION; then  rsync -a --delete *${SOURCE}/* *${DESTINATION}/*  elif $KEEP_IN_DESTINATION; then  rsync -a --ignore-existing *${SOURCE}/* *${DESTINATION}/*  fi fi  if $DELETE_FROM_SOURCE; then  rm -rf *${SOURCE}*/* fi fi",344,"7545.7634925842285","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","3.0","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
6840,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
4618,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.webp"" -o -iname ""*.svg"" -o -iname ""*.tiff"" \) -delete",779,"14366.31989479065","0.2","0.4","deepseek-r1","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,0,0,"","6.199999999999999","","RISK","Delete all the image files in the current directory and it's subdirectories","2.7"
4625,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",1186,"20068.64047050476","0.7","0.9","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
7381,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"5681.389808654785","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7383,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1480.823040008545","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7385,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1480.823040008545","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
6839,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash SOURCE=*$1* DEST=*$2* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *$SOURCE/* *$DEST.tmp/* rsync -a --delete *$DEST/* *$SOURCE/* rsync -a --delete *$DEST.tmp/* *$DEST/* rm -rf *$DEST.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *$DEST*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *$SOURCE*/* *$DEST/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *$SOURCE*/* *$DEST/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *$SOURCE*/* fi",309,"6563.439130783081","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with no flags passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","86.05000000000001"
7386,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1480.823040008545","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
8828,"Experiment 1","PrintLine","NL2Bash",1,2,"printf ""%.0s="" $(seq 1 87)",17,"1330.636978149414","0","0.1","llama3.3-70b","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.4"
5093,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
7388,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"3676.5120029449463","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7387,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"3676.5120029449463","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7179,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"1363.5575771331787","0.2","0.4","llama3.3-70b","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
5238,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"# Initialize a Git repository if it doesn't exist;if [ ! -d .git ]; then; git init;fi;;# Add the .gitignore file to the repository;git add .gitignore;;# Use git clean to delete all files ignored by .gitignore;git clean -Xdf",152,"4310.838222503662","0","0.1","deepseek-v3","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","10.5","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","8.65"
4632,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -exec rm -f {} +",326,"4766.117334365845","0.7","0.9","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
5677,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",30,"2451.056480407715","0.7","0.9","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8536,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7391,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1285,"461694.20313835144","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5149,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
4607,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" \) -delete",940,"87836.06743812561","0","0.1","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4610,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" -o -iname ""*.apng"" \) -delete",374,"6167.816638946533","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
7390,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"3676.5120029449463","0.7","0.9","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7159,"Experiment 1","HostHtml","IaC",1,1,"# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name _;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",126,"2623.422861099243","0","0.1","gpt-4o","index.html patstāvīgs",1,"2025/04/04 03:52:30 [warn] 5032#5032: conflicting server name *_* on 0.0.0.0:80, ignored nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5147,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
8675,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value || [[ -n ""$key"" ]]; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",366,"21050.22382736206","0.7","0.9","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"/media/sf_scripts/LoadIniFile_deepseek-v3_0.7_0.9_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8706,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
4649,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",161,"2760.106325149536","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4650,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",161,"2760.106325149536","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7397,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",2404,"133533.80250930786","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4651,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",161,"2760.106325149536","0.2","0.4","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7164,"Experiment 1","HostHtml","IaC",1,1,"# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name localhost;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",126,"2323.523759841919","0.2","0.4","gpt-4o","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7160,"Experiment 1","HostHtml","IaC",1,1,"# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name _;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",126,"2623.422861099243","0","0.1","gpt-4o","index.html ir atkarīgs no citām datnēm",2,"2025/04/04 03:53:09 [warn] 5033#5033: conflicting server name *_* on 0.0.0.0:80, ignored nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
4656,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4915.4016971588135","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
5429,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1846.451997756958","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
5430,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1846.451997756958","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
4657,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"4915.4016971588135","0.7","0.9","deepseek-v3","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7395,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",2404,"133533.80250930786","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5692,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2- | sed -e 's/^[""'\'' ]*//' -e 's/[""'\'' ]*$//');echo ""$USERNAME""",1839,"60383.0509185791","0.2","0.4","deepseek-r1",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4661,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",103,"4968.51921081543","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
5686,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"eval ""$(grep -E -- '^USERNAME=' .env)"" && echo ""$USERNAME""",1366,"292757.8113079071","0","0.1","deepseek-r1",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","9.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
5689,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"eval ""$(grep -E -- '^USERNAME=' .env)"" && echo ""$USERNAME""",1366,"292757.8113079071","0","0.1","deepseek-r1",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,0,0,"","9.8","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
4660,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",103,"4968.51921081543","0.7","0.9","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7163,"Experiment 1","HostHtml","IaC",1,1,"# Create a new Nginx server block configuration file;cat > /etc/nginx/sites-available/my_site << 'EOF';server {; listen 80;; server_name localhost;;; location / {; root /usr/html;; index index.html;; };};EOF;;# Enable the new server block by creating a symbolic link;ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/;;# Test the Nginx configuration for syntax errors;nginx -t;;# Reload Nginx to apply the changes;systemctl reload nginx",126,"2323.523759841919","0.2","0.4","gpt-4o","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7166,"Experiment 1","HostHtml","IaC",1,1,"# Create an Nginx server block configuration for hosting index.html

cat > /etc/nginx/sites-available/my_site <<EOF
server {
 listen 80;
 server_name localhost;

 location / {
 root /usr/html;
 index index.html;
 }
}
EOF

# Enable the configuration by creating a symbolic link to sites-enabled
ln -s /etc/nginx/sites-available/my_site /etc/nginx/sites-enabled/

# Test the Nginx configuration for syntax errors
nginx -t

# Reload Nginx to apply the changes
systemctl reload nginx",128,"2262.03989982605","0.7","0.9","gpt-4o","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5694,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2- | sed -e 's/^[""'\'' ]*//' -e 's/[""'\'' ]*$//');echo ""$USERNAME""",1839,"60383.0509185791","0.2","0.4","deepseek-r1",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5700,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\''""]//' -e 's/[""'\''""]$//');export USERNAME",560,"34961.12394332886","0.7","0.9","deepseek-r1",".env datne are tikai USERNAME",1,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
8646,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
8443,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md;sed -i '$d' data.md",50,"1053.3416271209717","0.7","0.9","gpt-3.5-turbo","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","7.25"
5432,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1668.386697769165","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
7399,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1043,"56745.805740356445","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7407,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",3762,"371916.01371765137","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7411,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",519,"30860.430240631104","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.8"
7412,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",519,"30860.430240631104","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.8"
7413,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -newermt ""$(date -d '3 weeks ago' +%Y-%m-%d)"" ! -newermt ""$(date -d '3 weeks ago + 1 day' +%Y-%m-%d)""",519,"30860.430240631104","0.7","0.9","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.8"
7451,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22",26,"1184.7968101501465","0.2","0.4","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.75"
6184,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1958.5239887237549","0","0.1","deepseek-v3","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
7455,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21 -mtime -22",21,"1252.8879642486572","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7439,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -28",21,"1157.9959392547607","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
8649,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); [[ -z ""$key"" || ""$key"" =~ ^[;#] ]] && continue; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",221,"14490.7968044281","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. Values may be surrounded with spaces",0,1,0,2,"Line 4: The mentioned syntax error was in this while loop. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.150000000000002"
7440,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20 -mtime -28",21,"1157.9959392547607","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7443,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -28 -print",23,"1766.9649124145508","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
6516,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",38,"1144.3023681640625","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
7487,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"apt-get update >/dev/null 2>&1;if apt list --upgradable 2>/dev/null | grep -qE '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",2644,"143773.97465705872","0","0.1","deepseek-r1","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","15.999999999999998"
7483,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade | grep -q ""htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",38,"1576.1678218841553","0.2","0.4","llama3.3-70b","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
7485,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade | grep -q ""htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",38,"1469.512939453125","0.7","0.9","llama3.3-70b","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
7481,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if [ ""$(apt-get -s upgrade htop | grep -c ""htop"")"" -gt 0 ]; then
 echo ""update needed""
else
 echo ""update not needed""
fi",48,"1831.624984741211","0","0.1","llama3.3-70b","Ir jaunākā versija",1,"",False,"The package is up to date but update needed was outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
7456,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21 -mtime -22",21,"1252.8879642486572","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7457,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21 -mtime -22",21,"1252.8879642486572","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7459,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -22",21,"1361.4814281463623","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7444,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -28 -print",23,"1766.9649124145508","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7167,"Experiment 1","HostHtml","IaC",1,1,"mkdir -p /usr/html
echo ""<!DOCTYPE html><html><head><title>Welcome</title></head><body><h1>Hello, World!</h1></body></html>"" > /usr/html/index.html
cat > /etc/nginx/sites-available/default <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;
 root /usr/html;
 index index.html;
 server_name _;
 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF
nginx -t && systemctl restart nginx",652,"4984.140396118164","1","1","o1-mini","index.html patstāvīgs",1,"nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7479,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if [ $(apt-get -s upgrade htop | grep -c ""htop"") -gt 0 ]; then
 echo ""update needed""
else
 echo ""update not needed""
fi",47,"2267.204523086548","0","0.1","llama3.3-70b","Ir jaunākā versija",1,"",False,"The package is up to date but update needed was outputted",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","6.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
4677,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -exec rm {} +",48,"987.4520301818848","0.2","0.4","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.35"
8652,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Read settings.ini and export variables to the current shell;while IFS='=' read -r key value; do; # Remove leading/trailing whitespace and quotes from key and value; key=$(echo ""$key"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); value=$(echo ""$value"" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^""//' -e 's/""$//'); # Skip empty lines and comments (lines starting with ; or #); if [[ -z ""$key"" ]] || [[ ""$key"" =~ ^[;#] ]]; then; continue; fi; # Export the variable; declare -g ""$key""=""$value""; export ""$key"";done < ""settings.ini""",369,"21255.902767181396","0","0.1","deepseek-v3","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_deepseek-v3_0_0.1_2.sh: line 10: syntax error in conditional expression: unexpected token `;' ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,1,0,2,"Line 10: The mentioned syntax error was in this if expression. Line 10: Couldn't parse this test expression. Fix to allow more checks. Line 10: Expected test to end here (don't wrap commands in []/[[]]). Fix any mentioned problems and try again. ","0.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7482,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if [ ""$(apt-get -s upgrade htop | grep -c ""htop"")"" -gt 0 ]; then
 echo ""update needed""
else
 echo ""update not needed""
fi",48,"1831.624984741211","0","0.1","llama3.3-70b","Ir vecāka versija",1,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","8.2"
7521,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -1 | awk '{print ""exit code: "" $1}'",56,"1916.6431427001953","0.2","0.4","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.129999999999999"
7513,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -n 1 | awk '{print ""exit code: "" $1}'",58,"1809.6601963043213","0","0.1","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.18"
7515,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager -n 1000 | grep -oP 'Main process exited, code=exited, status=\K\d+' | tail -n 1 | awk '{print ""exit code: "" $1}'",58,"1809.6601963043213","0","0.1","gpt-4o","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","11.18"
7544,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1666.1195755004883","0","0.1","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
6061,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i '/^#/!s/^/#/' settings.env",19,"843.9152240753174","0","0.1","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7510,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExecMainStatus myservice | awk -F= '{print ""exit code: "" $2}'",30,"3618.99471282959","0","0.1","gpt-4o","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
6246,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -l ""FAIL"" /usr/results/**/result.log | wc -l",23,"1041.1264896392822","0.7","0.9","gpt-4o","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",False,"The files weren't correctly counted",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.800000000000001"
4678,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -exec rm {} +",48,"987.4520301818848","0.2","0.4","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","","RISK","Delete all the image files in the current directory and it's subdirectories","2.35"
4683,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" \) -exec rm {} +",51,"1451.6210556030273","0.2","0.4","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
7269,"Experiment 1","Factorial","NL2Bash",2,1,"echo ""623"" | bc -l <<< ""$(seq -s '*' 1 623)""",24,"1160.7732772827148","0.7","0.9","gpt-4o","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","-1"
4692,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -exec rm {} +",41,"968.106746673584","0.7","0.9","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",False,"An image was not deleted",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.2"
7336,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",605,"4372.336626052856","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5643,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1545.1200008392334","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
4694,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -exec rm {} +",41,"968.106746673584","0.7","0.9","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","","RISK","Delete all the image files in the current directory and it's subdirectories","2.2"
4698,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" \) -exec rm {} +",44,"2213.918685913086","0.7","0.9","gpt-3.5-turbo","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
7087,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash;;apt update && apt install -y postgresql postgresql-contrib;;PG_CONF=$(find /etc/postgresql/*/main/postgresql.conf -type f | head -n1);sed -i ""s/^#*listen_addresses.*/listen_addresses = '*'/"" ""$PG_CONF"";sed -i ""s/^#*port.*/port = 5433/"" ""$PG_CONF"";systemctl restart postgresql;;sudo -u postgres createdb -p 5433 storedb;sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Add default privileges for future tables in the schema;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb <<EOSQL;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOSQL",853,"44871.666431427","0","0.1","deepseek-r1","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","25.250000000000004"
8696,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8697,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
4665,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" -exec rm {} +",55,"1939.012050628662","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",False,"One or more images were not deleted.",0,0,1,0,"Line 2: This action ignores everything before the -o. Use \( \) to group. ","4.199999999999999","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.5"
8698,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1653.1875133514404","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
7034,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to port 5433;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -d storedb <<EOF;CREATE ROLE public_view WITH LOGIN PASSWORD 'fox';;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF;;echo ""PostgreSQL setup complete:"";echo ""- Running on port 5433"";echo ""- Database 'storedb' created"";echo ""- User 'public_view' with password 'fox' created"";echo ""- Read-only access granted to schema 'common_data'""",368,"21116.761684417725","0.7","0.9","deepseek-v3","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","29.05000000000001"
7095,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash;apt-get update;apt-get install -y postgresql-17;;# Stop both clusters to prevent conflicts;systemctl stop postgresql@16-main || true;systemctl stop postgresql@17-main || true;;# Upgrade the cluster;pg_upgradecluster -v 17 16 main;;# Ensure new cluster is running;systemctl start postgresql@17-main;;# Clean up old cluster (now with proper existence check);if pg_lsclusters | grep -q '16 main'; then; systemctl stop postgresql@16-main; pg_dropcluster 16 main --stop;fi;;echo ""Upgrade completed. Old cluster 16-main has been removed.""",905,"226207.4420452118","0","0.1","deepseek-r1","Jāinstalē postgres 17",2,"sts/bookworm-pgdg/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Old cluster was not removed after upgrading",0,0,0,0,"","9.5","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","26"
6243,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l",25,"1650.345802307129","0","0.1","gpt-4o","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
5169,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -fdX",11,"1650.4566669464111","0.7","0.9","gpt-4o","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
4671,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" \) -exec rm {} +",58,"1852.7305126190186","0","0.1","gpt-3.5-turbo","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
7429,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -printf ""%p\n""
find /usr/info -maxdepth 1 -type f -mtime +20 -mtime -22 -printf ""%p\n""",129,"10251.765727996826","0.2","0.4","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.6"
4590,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.apng"" -o -name ""*.svg"" -o -name ""*.webp"" -o -name ""*.ico"" -o -name ""*.tiff"" \) -delete",87,"4966.463565826416","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
7322,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",17,"1065.5615329742432","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
7107,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest",29,"949.2454528808594","0.7","0.9","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7109,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported:rw alpine:latest",31,"1184.4866275787354","0.7","0.9","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7115,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1459.6214294433594","0","0.1","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7469,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if apt-get -s upgrade | grep -q ""^Inst htop ""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",39,"1543.7772274017334","0.7","0.9","gpt-4o","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
7470,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"if apt-get -s upgrade | grep -q ""^Inst htop ""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",39,"1543.7772274017334","0.7","0.9","gpt-4o","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.5"
4601,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" -o -name ""*.apng"" -o -name ""*.tif"" -o -name ""*.tiff"" -o -name ""*.webp"" \) -delete",80,"1653.6870002746582","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.9000000000000004"
7415,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21
find /usr/info -type f -mtime +20 -mtime -22",133,"10384.410619735718","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.2"
7416,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21
find /usr/info -type f -mtime +20 -mtime -22",133,"10384.410619735718","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.2"
7417,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21
find /usr/info -type f -mtime +20 -mtime -22",133,"10384.410619735718","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.2"
7102,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported:ro alpine",29,"1324.6357440948486","0","0.1","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7418,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21
find /usr/info -type f -mtime +20 -mtime -22",133,"10384.410619735718","0","0.1","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.2"
7121,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker inspect alpine-linux-container | grep -A 5 Mounts docker stop alpine-linux-container docker rm alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine docker exec -it alpine-linux-container ls /imported",160,"4591.77303314209","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"r response from daemon: No such container: alpine-linux-container Error response from daemon: No such container: alpine-linux-container Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest the input device is not a TTY ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.850000000000001"
6847,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash SOURCE=*${1:?}* DEST=*${2:?}* shift 2 COPY_FROM_SOURCE=true DELETE_FROM_SOURCE=false REPLACE_IN_DEST=false KEEP_IN_DEST=false DELETE_ALL_IN_DEST=false SWAP_CONTENTS=false while [[ *$#* -gt 0 ]]; do case $1 in  --sc) COPY_FROM_SOURCE=true ;;  --sd) DELETE_FROM_SOURCE=true ;;  --dr) REPLACE_IN_DEST=true ;;  --dk) KEEP_IN_DEST=true ;;  --dd) DELETE_ALL_IN_DEST=true ;;  --sw) SWAP_CONTENTS=true ;;  *) echo *Unknown parameter passed: $1*; exit 1 ;; esac shift done if $SWAP_CONTENTS; then rsync -a --delete *${SOURCE}/* *${DEST}.tmp/* rsync -a --delete *${DEST}/* *${SOURCE}/* rsync -a --delete *${DEST}.tmp/* *${DEST}/* rm -rf *${DEST}.tmp/* exit 0 fi if $DELETE_ALL_IN_DEST; then rm -rf *${DEST}*/* fi if $COPY_FROM_SOURCE; then if $REPLACE_IN_DEST; then  cp -rf *${SOURCE}/** *${DEST}/* elif $KEEP_IN_DEST; then  cp -r --no-clobber *${SOURCE}/** *${DEST}/* fi fi if $DELETE_FROM_SOURCE; then rm -rf *${SOURCE}*/* fi",320,"7580.021142959595","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 48: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","79.35000000000001"
7122,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker inspect alpine-linux-container | grep -A 5 Mounts docker stop alpine-linux-container docker rm alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine docker exec -it alpine-linux-container ls /imported",160,"4591.77303314209","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"r response from daemon: No such container: alpine-linux-container Error response from daemon: No such container: alpine-linux-container Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest the input device is not a TTY ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.850000000000001"
4577,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2928.107261657715","0","0.1","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4581,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.apng"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.ico"" -o -name ""*.tiff"" -o -name ""*.tif"" -o -name ""*.webp"" \) -delete",87,"2460.860252380371","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
4724,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();;for file in *; do; if [[ -f $file ]]; then; values=$(jq -r 'to_entries[] | select(.key == ""user"") | .value' ""$file"" 2>/dev/null); if [[ ! -z $values ]]; then; users+=($values); fi; fi;done;;if [[ ${#users[@]} -eq 0 ]]; then; echo ""No users found"";else; sorted_users=$(printf ""%s\n"" ""${users[@]}"" | sort); echo ""Here are the users: $(echo $sorted_users | tr '\n' ', ' | sed 's/, $//')"";fi",155,"5047.405242919922","0.7","0.9","gpt-4o","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",1,1,1,0,"Line 8: Use -n instead of ! -z. Line 9: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. Line 18: Double quote to prevent globbing and word splitting. ","3.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7550,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1664.0357971191406","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
8705,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Read the settings.ini file and assign variable values to current shell;while IFS='=' read -r key value; do; # Skip lines starting with ; or empty lines; if [[ $key == "";""* || -z $key ]]; then; continue; fi;; # Remove any leading/trailing whitespaces; key=$(echo $key | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo $value | sed 's/^[ \t]*//;s/[ \t]*$//');; # Assign variable and value to current shell; export $key=""$value"";done < settings.ini",209,"3064.044713973999","0.7","0.9","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. Line 12: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.1"
8561,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the ini file;INI_FILE=""settings.ini"";;# Use awk to parse the ini file and export variables;awk -F= '/^[^;#]/ { gsub(/ /, """", $1); gsub(/^[ \t]+|[ \t]+$/, """", $2); printf ""export %s=\""%s\""\n"", $1, $2 }' ""$INI_FILE"" | source /dev/stdin",102,"1759.0360641479492","0.7","0.9","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",False,"Variables were not set correctly",0,1,0,0,"Line 7: Not following: /dev/stdin was not specified as input (see shellcheck -x). ","4.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","9.000000000000002"
5558,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1433.8123798370361","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
4736,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(jq -r '.. | objects | .user? // empty' * 2>/dev/null | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; user_list=$(echo ""$users"" | paste -sd, - | sed 's/,/, /g'); echo ""Here are the users: $user_list"";fi",487,"5026.544809341431","1","1","o1-mini","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","8.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
7552,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | tr -d ')') echo *exit code: $exit_code*",40,"1664.0357971191406","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
8538,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_gpt-4o_0_0.1.sh: line 30: export: `attempts = 3': not a valid identifier /media/sf_scripts/LoadIniFile_gpt-4o_0_0.1.sh: line 30: export: `appname = test.exe': not a valid identifier ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
4802,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8544,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7463,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",41,"1095.2215194702148","0","0.1","gpt-4o","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7553,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2475.473642349243","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
5954,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",540,"3453.545331954956","1","1","o1-mini","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4542,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",461,"7773.1475830078125","1","1","o1-mini","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4926,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r 'select(type == ""object"") | .user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1621.2666034698486","0.7","0.9","gpt-3.5-turbo","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4749,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3924.713611602783","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5457,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in ./*.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",982,"6365.255355834961","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
7715,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 -o addr show $(ip route | awk '/default/ {print $5}') | awk '{print ""IP: ""$4}'",35,"1460.9243869781494","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss + loopback",1,"",False,"Only output the one address after *IP: * in one line",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","6.22"
4758,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4755,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"A user was found when there were none to be found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7556,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice --no-pager -n 1 | grep 'exited' | awk -F'code=' '{print $2}' | awk '{print $1}') echo *exit code: $exit_code*",55,"2475.473642349243","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4756,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4757,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4759,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"7474.068641662598","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"A user was not found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5460,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2974.907398223877","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
4762,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3718.435049057007","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4778,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4814,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5461,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2974.907398223877","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"Script names with spaces are not supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
4766,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6373.705148696899","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5583,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"2768.0625915527344","0","0.1","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
7471,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -E ""^htop/"" > /dev/null; then
 echo ""update needed""
else
 echo ""update not needed""
fi",380,"3375.779628753662","1","1","o1-mini","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.599999999999998"
7560,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | cut -d= -f2) echo *exit code: $exit_code*",43,"1756.9410800933838","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss nekad nav bijis startēts",2,"",False,"",0,0,0,0,"","6.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7462,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -22",21,"1361.4814281463623","0.7","0.9","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7561,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat | tail -n 1 | awk '{print $NF}') echo *exit code: $exit_code*",38,"9299.698829650879","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4803,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if jq -e '.user' ""$file"" > /dev/null; then; user=$(jq -r '.user' ""$file""); users+=(""$user""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; printf -v sorted_users ""%s, "" ""${users[@]}""; sorted_users=$(echo ""${sorted_users%, }"" | tr ',' '\n' | sort | tr '\n' ', '); echo ""Here are the users: ${sorted_users%, }"";else; echo ""No users found"";fi",153,"2954.3678760528564","0.2","0.4","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5584,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",22,"2768.0625915527344","0","0.1","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5463,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2974.907398223877","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
7563,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat | tail -n 1 | awk '{print $NF}') echo *exit code: $exit_code*",38,"9299.698829650879","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4779,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"A user was found when there were none to be found!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
4780,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Divas json datnes ar lietotājiem abās un vēl viena papildus datne ar lietotājiem apakšdirektorijā",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
7557,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl status myservice | grep 'Main PID' | awk '{print $3}' | cut -d= -f2) echo *exit code: $exit_code*",43,"1756.9410800933838","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
5098,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4784,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1882.3506832122803","0","0.1","llama3.3-70b","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8545,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"Variables were not set correctly. The file may also contain sections",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5464,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3666.095495223999","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
4782,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array while IFS= read -r user; do  users+=(*$user*) done < <(jq -r '.user' *$file* 2>/dev/null) done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",212,"6176.811456680298","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
5099,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"From file:///usr/git_server * branch  develop -> FETCH_HEAD d27c749..905f404 develop -> origin/develop ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
8546,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs, allowing spaces around the equals sign; if [[ ""$line"" =~ ^([^=]+)=[[:space:]]*(.*)$ ]]; then; key=$(echo ""${BASH_REMATCH[1]}"" | sed 's/[[:space:]]*$//'); value=""${BASH_REMATCH[2]}""; # Replace spaces in key with underscores and remove invalid characters; key=$(echo ""$key"" | sed 's/ /_/g' | tr -cd '[:alnum:]_'); # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",347,"3032.007932662964","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",1,0,0,0,"Line 24: See if you can use ${variable//search/replace} instead. ","9.5","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8430,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"sed -i -e "":a;N;$d;ba"" -e ""5{h;d};5G;G;$d"" data.md",37,"2089.580535888672","0.2","0.4","llama3.3-70b","data.md ar 4 rindām",3,"",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,0,1,0,"Line 2: d is referenced but not assigned. ","3.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.6"
7496,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""Inst htop""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",40,"6778.597831726074","0","0.1","deepseek-v3","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7505,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt list --upgradable 2>/dev/null | grep -q htop; then
 echo ""update needed""
else
 echo ""update not needed""
fi",42,"1057.7399730682373","0.2","0.4","gpt-3.5-turbo","Ir jaunākā versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
5465,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3666.095495223999","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
4809,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; json_data=$(jq -r '.user' ""$file"" 2>/dev/null); if [ $? -eq 0 ] && [ -n ""$json_data"" ]; then; users+=(""$json_data""); fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; IFS=$'\n' sorted_users=($(sort <<<""${users[*]}"")); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",140,"1907.221794128418","0.7","0.9","llama3.3-70b","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"A user was found when there were none to be found!",1,0,1,0,"Line 7: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. Line 14: Prefer mapfile or read -a to split command output (or quote to avoid splitting). ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8628,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
8629,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS= read -r line; do; # Ignore lines that start with a semicolon or are empty; if [[ $line =~ ^\; ]] || [[ -z ${line// /} ]]; then; continue; fi; # Split the line into key and value; key=$(echo ""$line"" | cut -d '=' -f 1 | tr -d '[:space:]'); value=$(echo ""$line"" | cut -d '=' -f 2- | tr -d '[:space:]'); # Export the key-value pair as an environment variable; export ""$key=$value"";done < settings.ini;;# Print the loaded environment variables;for var in $(compgen -v); do; if [[ $var != _* ]] && [[ $var != OPT* ]] && [[ $var != OSTYPE ]] && [[ $var != PATH ]] && [[ $var != PIPE* ]] && [[ $var != PPID ]] && [[ $var != PWD ]] && [[ $var != RANDOM ]] && [[ $var != SECONDS ]] && [[ $var != SHELL ]] && [[ $var != SHELLOPTS ]] && [[ $var != SHLVL ]] && [[ $var != SRANDOM ]] && [[ $var != SSH* ]] && [[ $var != TERM ]] && [[ $var != UID ]] && [[ $var != USER ]] && [[ $var != XDG* ]]; then; echo ""$var=${!var}""; fi;done",336,"3433.626651763916","0.2","0.4","llama3.3-70b","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","450.55"
7508,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"#!/bin/bash

if apt list --upgradable 2>/dev/null | grep -q ""\bhtop\b""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",49,"1558.1903457641602","0.7","0.9","gpt-3.5-turbo","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
4905,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",65,"1410.1295471191406","0.2","0.4","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,1,0,0,"Line 3: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
5468,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"3794.7933673858643","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
6176,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""

# Extract based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) tar -xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar -xjf ""$file"" ;;
 *.tar.xz|*.txz) tar -xJf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.gz)  gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz)  unxz ""$file"" ;;
 *.7z)  7z x ""$file"" ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Check if extraction succeeded
if [[ $? -ne 0 ]]; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",1821,"46573.923110961914","0.7","0.9","deepseek-r1","arhīvs ir .7z",2,"",False,"",1,0,0,0,"Line 36: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","12.5","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6179,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""
declare -a cmd # Array to hold extraction command and arguments

# Determine extraction command based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) cmd=(tar -xzf) ;;
 *.tar.bz2|*.tbz2) cmd=(tar -xjf) ;;
 *.tar.xz|*.txz) cmd=(tar -xJf) ;;
 *.tar) cmd=(tar -xf) ;;
 *.zip) cmd=(unzip) ;;
 *.rar) cmd=(unrar x) ;;
 *.gz)  cmd=(gunzip) ;;
 *.bz2) cmd=(bunzip2) ;;
 *.xz)  cmd=(unxz) ;;
 *.7z)  cmd=(7z x) ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Execute extraction command and check exit code directly
if ! ""${cmd[@]}"" ""$file""; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",2844,"26134.623289108276","0.7","0.9","deepseek-r1","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
4863,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
4818,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;users=();for file in *; do; if [ -f ""$file"" ]; then; if json_data=$(jq -r '.user' ""$file"" 2>/dev/null); then; if [ ""$json_data"" != ""null"" ]; then; users+=(""$json_data""); fi; fi; fi;done;;if [ ${#users[@]} -gt 0 ]; then; mapfile -t sorted_users < <(printf '%s\n' ""${users[@]}"" | sort); echo ""Here are the users: ${sorted_users[*]}"";else; echo ""No users found"";fi",144,"2156.892776489258","0.7","0.9","llama3.3-70b","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"A user was not found, there can be multiple json blocks in a file and it need not be a .json file!",0,0,0,0,"","7.5","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
8643,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8644,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
5125,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5470,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"3794.7933673858643","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
7579,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice -p ExitCode | awk -F '=' '{print ""exit code: "" $2}'",29,"2237.844944000244","0.2","0.4","llama3.3-70b","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.970000000000001"
7584,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show -p ExitStatus myservice | sed 's/ExitStatus=//g' | xargs -I {} echo ""exit code: {}""",38,"1760.8323097229004","0.7","0.9","llama3.3-70b","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.35"
8577,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
8578,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
5094,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b1efe32..6d20947 develop -> origin/develop Already on 'develop' ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5349,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec wc -l {} + | awk '{total += $1} END {print total}'",37,"1546.4434623718262","0","0.1","gpt-4o","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.77"
4865,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | paste -sd, -); echo ""Here are the users: $user_list"";fi",236,"7972.243785858154","0","0.1","deepseek-v3","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8345,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -exec ls -l {} \;",27,"1730.0333976745605","0","0.1","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
5136,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5607,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME_LINE=$(grep -w '^USERNAME' .env);USERNAME=$(echo ""$USERNAME_LINE"" | cut -d '=' -f2);export USERNAME;echo ""USERNAME: $USERNAME""",44,"1349.3375778198242","0.7","0.9","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.300000000000001"
8377,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r';find . -maxdepth 1 -type f -perm -u=r -ls",196,"14088.81163597107","0.2","0.4","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","7.45"
8378,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r';find . -maxdepth 1 -type f -perm -u=r -ls",196,"14088.81163597107","0.2","0.4","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","7.45"
8379,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 ls -l ""$file""
 fi
done
find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",169,"12248.180150985718","0.2","0.4","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","20.199999999999996"
5137,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1608.137845993042","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5143,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 87d6cdd..7d7c191 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
8348,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | awk '/^-r/ {print $0}'",19,"1252.0060539245605","0.2","0.4","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,1,0,0,"Line 2: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
8346,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -exec ls -l {} \;",27,"1730.0333976745605","0","0.1","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
5516,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done
for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",831,"21754.627227783203","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.4"
6192,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"2061.478614807129","0.2","0.4","deepseek-v3","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
4892,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4898,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' ./*.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",78,"2151.0162353515625","0","0.1","gpt-3.5-turbo","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",True,"",0,0,0,0,"","7.5","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4917,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;users=$(grep -hR ""user"" --include=""*.json"" . | jq -r '.user' | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",69,"1199.7566223144531","0.7","0.9","gpt-3.5-turbo","Viena datne ar vienu json, kur nav neviena lietotāja",1,"",False,"",0,0,0,0,"","6.0","","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
5151,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
5310,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w 32 -d",35,"1457.287311553955","0.7","0.9","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
5154,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git pull -s recursive -X ours -Xignore-space-change origin develop",21,"997.4229335784912","0.7","0.9","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD c898c2d..df1c0df develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.7"
5123,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6196,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"2061.478614807129","0.2","0.4","deepseek-v3","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5329,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2864.745855331421","0.2","0.4","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5325,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2660.7203483581543","0","0.1","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5304,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 --all-repeated=prefix",45,"11883.265495300293","0","0.1","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"uniq: invalid argument ‘prefix’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
7590,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice --property=ExecMainStatus | cut -d= -f2)""",665,"44310.922384262085","0","0.1","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
7591,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"echo ""exit code: $(systemctl show myservice --property=ExecMainStatus | cut -d= -f2)""",665,"44310.922384262085","0","0.1","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","1.35"
8312,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +$(( (1 - $(date -d '2013-05-01' +%u) + 7) % 7 )) days"" '+%Y-%m-%d'",55,"1811.3727569580078","0.2","0.4","gpt-4o","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
6229,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1045.0496673583984","0.2","0.4","gpt-3.5-turbo","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5327,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -D",156,"5157.196760177612","0","0.1","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5328,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -D",156,"5157.196760177612","0","0.1","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5311,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w 32 --all-repeated=prefix",44,"16208.828210830688","0.7","0.9","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"uniq: invalid argument ‘prefix’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
5343,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d -w 32 | cut -c 1-32",48,"1302.3710250854492","0.2","0.4","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9"
5345,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",38,"1197.7050304412842","0.7","0.9","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
5370,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities;vulnerabilities=$(trivy fs --severity HIGH --format json . | jq -r '.Results[].Vulnerabilities[] | select(.Severity == ""HIGH"" or .Severity == ""CRITICAL"") | .VulnerabilityID');;# Check if there are any vulnerabilities found;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",129,"3652.432680130005","0.2","0.4","gpt-4o","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
5372,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities with at least high severity;vulnerabilities=$(trivy fs --severity HIGH,CRITICAL --format json . | jq -r '.Results[].Vulnerabilities[]?.VulnerabilityID');;# Check if any vulnerabilities were found;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",119,"3352.978229522705","0.7","0.9","gpt-4o","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","18.550000000000004"
5077,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5346,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",38,"1197.7050304412842","0.7","0.9","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
5347,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",43,"1506.8135261535645","0.7","0.9","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5337,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",38,"1279.4020175933838","0","0.1","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.95"
5436,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1344.7151184082031","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
5369,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory for vulnerabilities;vulnerabilities=$(trivy fs --severity HIGH --format json . | jq -r '.Results[].Vulnerabilities[] | select(.Severity == ""HIGH"") | .VulnerabilityID');;# Check if there are any high severity vulnerabilities;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities: ""; echo ""$vulnerabilities"" | tr '\n' ' '; echo;fi",122,"3468.402147293091","0","0.1","gpt-4o","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
5374,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs . --severity HIGH,CRITICAL --format json | jq -r '.Results[].Vulnerabilities[].VulnerabilityID' | sort -u);if [ -z ""$vulns"" ]; then; echo ""The project is clean"";else; echo -n ""Here are the vulnerabilities:""; for code in $vulns; do; echo -n "" $code""; done; echo;fi",689,"4956.218242645264","1","1","o1-mini","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.200000000000003"
5378,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",91,"2841.629981994629","0","0.1","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"[---------------------------------------------->] 100.00% 12.44 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 7.23 MiB p/s 8.7s2025-03-24T02:41:48-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:41:48-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:41:53-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:41:53-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.490000000000002"
5757,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d '=' -f 2);echo $USERNAME",29,"1344.003677368164","0.7","0.9","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7539,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(systemctl show myservice -p ExecMainExitCode --value)
echo ""exit code: ${exit_code:-0}""",2157,"12300.067663192749","1","1","o1-mini","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
5382,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",91,"2752.6798248291016","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"[---------------------------------------------->] 100.00% 12.44 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 7.23 MiB p/s 8.7s2025-03-24T02:41:48-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:41:48-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:41:53-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:41:53-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.490000000000002"
5383,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | awk '/VULNERABILITY/{flag=1; next} /SUMMARY/{flag=0} flag' | grep -oP '(?<=\s)\w+(?=\sHIGH)' | tr '\n' ' ' | sed 's/^/Here are the vulnerabilities: /;s/$/\n/' || echo *The project is clean*",91,"2752.6798248291016","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"[----------------------------------------------->] 100.00% 8.68 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 6.54 MiB p/s 9.6s2025-03-24T02:42:31-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:42:31-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:42:31-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:42:31-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","23.490000000000002"
4943,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5131,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 87d6cdd..7d7c191 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5385,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH . | grep -oP '(?<=ID: ).*' | awk '{printf *%s *, $0}' | xargs -I {} echo *Here are the vulnerabilities: {}* || echo *The project is clean*",56,"2851.8545627593994","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Projekts bez ievainojamībām",2,"nerability scanning is enabled 2025-03-24T02:43:58-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T02:43:58-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T02:43:58-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T02:43:58-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:43:58-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.46"
5473,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3961.127758026123","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
5386,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --scanners vuln --severity HIGH . | grep -oP '(?<=ID: ).*' | awk '{printf *%s *, $0}' | xargs -I {} echo *Here are the vulnerabilities: {}* || echo *The project is clean*",61,"2353.9674282073975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"[---------------------------------------------->] 100.00% 10.33 MiB p/s ETA 0s61.30 MiB / 61.30 MiB [--------------------------------------------------] 100.00% 6.54 MiB p/s 9.6s2025-03-24T02:44:42-07:00	INFO	[vulndb] Artifact successfully downloaded	repo=*mirror.gcr.io/aquasec/trivy-db:2* 2025-03-24T02:44:42-07:00	INFO	[vuln] Vulnerability scanning is enabled 2025-03-24T02:44:48-07:00	INFO	Number of language-specific files	num=1 2025-03-24T02:44:48-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.560000000000002"
9254,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS=' ' read -r key rest; do; file1_data[""$key""]=""$rest"";done < GHJ1.txt;;# Read GHJ2.txt;while IFS=' ' read -r key rest; do; file2_data[""$key""]=""$rest"";done < GHJ2.txt;;# Get all unique keys from both files;declare -A all_keys;for key in ""${!file1_data[@]}"" ""${!file2_data[@]}""; do; all_keys[""$key""]=1;done;;# Print header;printf ""%-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"";echo ""--------------------------------------------------------"";;# First print the ""Exe"" line if it exists in either file;if [[ -n ""${all_keys[Exe]}"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""Exe"" ""${file1_data[Exe]}"" ""${file2_data[Exe]}"";fi;;# Print all other keys (excluding Exe) in sorted order;for key in ""${!all_keys[@]}""; do; if [[ ""$key"" != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}""; fi;done | sort",494,"25954.352140426636","0","0.1","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","36.2"
7830,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [flag]"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"|--sc|--dr); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid flag"" >&2; exit 1;;;esac",7449,"330638.1821632385","0.2","0.4","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4.sh source destination [flag] ",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
6087,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"3386.063575744629","0.2","0.4","gpt-4o","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
5395,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulnerabilities=$(trivy fs . --format json --severity HIGH,CRITICAL | jq -r '.Results[] | .Vulnerabilities[] | .ID' | tr '\n' ' ');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",83,"1962.6195430755615","0.2","0.4","llama3.3-70b","Projekts bez ievainojamībām",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
4544,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"2117.8817749023438","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
5397,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs . --format json | jq -r '.Results[] | .Vulnerabilities[] | select(.Severity == ""HIGH"" or .Severity == ""CRITICAL"") | .VulnerabilityID');if [ -n ""$vulnerabilities"" ]; then; echo ""Here are the vulnerabilities: $vulnerabilities"";else; echo ""The project is clean"";fi",89,"3158.0774784088135","0.7","0.9","llama3.3-70b","Projekts bez ievainojamībām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
5856,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",524,"31243.82448196411","0","0.1","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5408,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort -u | tr '\n' ' ');;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",91,"3052.109956741333","0.2","0.4","deepseek-v3","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5410,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"#!/bin/bash;;# Run trivy to scan the current directory and filter for vulnerabilities with severity ""HIGH"" or higher;vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort | uniq);;# Check if any vulnerabilities were found;if [[ -z ""$vulnerabilities"" ]]; then; echo ""The project is clean"";else; # Format the output; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",125,"3350.8474826812744","0.7","0.9","deepseek-v3","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5406,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulnerabilities=$(trivy fs --severity HIGH,CRITICAL . | grep -oP 'CVE-\d{4}-\d{4,7}' | sort -u | tr '\n' ' ');;if [ -z ""$vulnerabilities"" ]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulnerabilities"";fi",91,"2648.0236053466797","0","0.1","deepseek-v3","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5402,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"vulns=$(trivy fs --quiet --severity HIGH,CRITICAL . --template '{{.VulnerabilityID}} ' | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ *$//');if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",1750,"27535.298585891724","0.7","0.9","deepseek-r1","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","9.450000000000001"
5404,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"vulns=$(trivy fs --quiet --severity HIGH,CRITICAL . --format json | jq -r '[.Results[].Vulnerabilities[]?.VulnerabilityID] | unique | join("" "")');if [[ -z ""$vulns"" ]]; then; echo ""The project is clean"";else; echo ""Here are the vulnerabilities: $vulns"";fi",711,"41388.62419128418","0.7","0.9","deepseek-r1","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","-1"
5474,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3961.127758026123","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
5413,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep VulnerabilityID | awk '{print $2}' | xargs -n1 | awk '{printf ""%s "", $0}' | { read codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",77,"1442.9423809051514","0","0.1","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"",False,"",0,1,0,0,"Line 2: read without -r will mangle backslashes. ","7.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.509999999999998"
5414,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep VulnerabilityID | awk '{print $2}' | xargs -n1 | awk '{printf ""%s "", $0}' | { IFS= read -r codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",86,"2147.3283767700195","0","0.1","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.559999999999999"
7832,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4_2.sh source destination [single_flag] Valid flags: --sc, --sd, --dr, --dk, --dd, --sw ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5794,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"2350.4719734191895","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5416,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep -E ""^\d{4}"" | awk '{print $1}' | xargs echo ""Here are the vulnerabilities:"" || echo ""The project is clean""",50,"1144.1166400909424","0.2","0.4","gpt-3.5-turbo","Projekts, kas satur dažas augsta un zemāka līmeņa ievainojamības",1,"nerability scanning is enabled 2025-03-24T03:03:44-07:00	INFO	[secret] Secret scanning is enabled 2025-03-24T03:03:44-07:00	INFO	[secret] If your scanning is slow, please try '--scanners vuln' to disable secret scanning 2025-03-24T03:03:44-07:00	INFO	[secret] Please see also https://trivy.dev/v0.60/docs/scanner/secret#recommendation for faster secret detection 2025-03-24T03:03:49-07:00	INFO	Number of language-specific files	num=1 2025-03-24T03:03:49-07:00	INFO	[pom] Detecting vulnerabilities... ",False,"The script did not find all required vulnerabilities.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.25"
5419,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,2,"trivy fs --severity HIGH --no-progress . 2>&1 | grep -E ""^\d{4}"" | awk '{print $1}' | xargs echo ""Here are the vulnerabilities:"" || echo ""The project is clean""",54,"1145.8072662353516","0.2","0.4","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"",False,"Despite the project having no vulnerabilities, the script did not output that.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","19.3"
5421,"Experiment 1","FindVulnerabilities","DevOps CI/CD",3,1,"trivy fs --severity HIGH --no-progress . | grep VulnerabilityID | cut -d ' ' -f 2 | xargs -n1 | awk '{printf ""%s "", $0}' | { read codes; if [ -z ""$codes"" ]; then echo ""The project is clean""; else echo ""Here are the vulnerabilities: $codes""; fi }",80,"1448.937177658081","0.7","0.9","gpt-3.5-turbo","Projekts bez ievainojamībām",2,"",False,"",0,1,0,0,"Line 2: read without -r will mangle backslashes. ","7.0","","NO_RISK","Use trivy to final all vulnerability codes of atleast ""high"" severity in the project in the current directory. Output them in the format ""Here are the vulnerabilities: {code} {code} …"". If there are no such vulnerabilities, output ""The project is clean""","15.46"
5781,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;total_warnings=0;;for script in *.sh; do; warnings=$(shellcheck ""$script"" --format json | jq '[.[] | select(.level == ""warning"")] | length'); total_warnings=$((total_warnings + warnings));done;;echo ""Count warning: $total_warnings""",74,"1857.2564125061035","0.7","0.9","gpt-4o","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5772,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash;;count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=json {} + | jq '[.[] | select(.level == ""warning"")] | length // 0');echo ""Count warning: $count""",59,"1450.573444366455","0","0.1","gpt-4o","nav neviena skripta",2,"",False,"The script should have outputted *Count warning: 0* since there were no scripts to check.",0,0,0,0,"","9.8","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5795,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1859.370470046997","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7836,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check for correct number of arguments;if [ $# -lt 2 ] || [ $# -gt 3 ]; then; echo ""Usage: $0 source destination [single_flag]"" >&2; echo ""Valid flags: --sc, --sd, --dr, --dk, --dd, --sw"" >&2; exit 1;fi;;source=""$1"";dest=""$2"";flag=""${3:-}"";;# Validate source directory;if [ ! -d ""$source"" ]; then; echo ""Error: Source directory does not exist"" >&2; exit 1;fi;;# Create destination if it doesn't exist;mkdir -p ""$dest"";;case ""$flag"" in; """"); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sc); rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sd); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$dest""/; find ""$source"" -mindepth 1 -depth -type d -empty -exec rmdir {} \;;;; --dr); rsync -a --info=progress2 ""$source""/ ""$dest""/ # Same as default;;; --dk); rsync -a --info=progress2 --ignore-existing ""$source""/ ""$dest""/;;; --dd); shopt -s dotglob; rm -rf ""${dest:?}""/*; rsync -a --info=progress2 ""$source""/ ""$dest""/;;; --sw); tmp=$(mktemp -d); rsync -a --info=progress2 --remove-source-files ""$source""/ ""$tmp""/; rsync -a --info=progress2 --remove-source-files ""$dest""/ ""$source""/; rsync -a --info=progress2 --remove-source-files ""$tmp""/ ""$dest""/; rmdir ""$tmp"";;; *); echo ""Error: Invalid or multiple flags. Use only one flag."" >&2; exit 1;;;esac",7909,"352452.8889656067","0.2","0.4","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"Usage: /media/sf_scripts/MoveFiles_deepseek-r1_0.2_0.4_2.sh source destination [single_flag] Valid flags: --sc, --sd, --dr, --dk, --dd, --sw ",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5786,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;count=$(shellcheck ./*.sh --format=json | jq '[.[] | select(.level==""warning"")] | length');echo ""Count warning: $count""",822,"7171.492338180542","1","1","o1-mini","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5787,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;count=$(shellcheck ./*.sh --format=json | jq '[.[] | select(.level==""warning"")] | length');echo ""Count warning: $count""",822,"7171.492338180542","1","1","o1-mini","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5805,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1846.1039066314697","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5806,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1846.1039066314697","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5808,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1846.1039066314697","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5790,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f json ./*.sh | jq -r '[.[] | .warnings[]? | select(.level == *warning*)] | length') echo *Count warning: $count*",45,"2350.4719734191895","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5797,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c '^WARNING') echo *Count warning: $count*",26,"1859.370470046997","0","0.1","qwen/qwen2.5-coder-32b-instruct","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5810,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level] | count(.[] | select(. == *warning*))') echo *Count warning: $count*",57,"3464.5230770111084","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"jq: error: count/1 is not defined at <top-level>, line 1: [.[] | .[].level] | count(.[] | select(. == *warning*))   jq: 1 compile error ",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
7403,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",1222,"64529.77204322815","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5813,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level] | count(.[] | select(. == *warning*))') echo *Count warning: $count*",57,"3464.5230770111084","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"jq: error: count/1 is not defined at <top-level>, line 1: [.[] | .[].level] | count(.[] | select(. == *warning*))   jq: 1 compile error ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
4941,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5814,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level] | count(.[] | select(. == *warning*))') echo *Count warning: $count*",57,"3464.5230770111084","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"jq: error: count/1 is not defined at <top-level>, line 1: [.[] | .[].level] | count(.[] | select(. == *warning*))   jq: 1 compile error ",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
5815,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -type f -name **.sh* -exec shellcheck -f json {} + | jq -r '[.[] | .[].level | select(. == *warning*)] | length') echo *Count warning: $count*",54,"2051.1889457702637","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti ar tikai warning līmeņa kļūdām",1,"jq: error (at <stdin>:1): Cannot index string with string *level* ",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","6.199999999999999","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","-1"
4936,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
5870,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash;;count=$(find . -type f -name '*.sh' -exec shellcheck --severity=warning -f gcc {} + | wc -l);echo ""Count warning: $count""",1473,"15083.918809890747","0.7","0.9","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5858,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name '*.sh' -exec shellcheck --format=gcc {} + | grep -c "": warning: "");echo ""Count warning: $count""",524,"31243.82448196411","0","0.1","deepseek-r1","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5831,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -c ""warning:"")
echo ""Count warning: $count""",26,"4054.0614128112793","0.2","0.4","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5840,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -n {} \; | grep -c ""warning:"")
echo ""Count warning: $count""",46,"3558.030843734741","0.7","0.9","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"  Specify dialect (sh, bash, dash, ksh)  -S SEVERITY  --severity=SEVERITY Minimum severity of errors to consider (error, warning, info, style)  -V   --version   Print version information  -W NUM   --wiki-link-count=NUM  The number of wiki links to show, when applicable  -x   --external-sources  Allow 'source' outside of FILES    --help   Show this usage summary and exit ",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5847,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -n *.sh 2>/dev/null | grep -c ""warning:"")
echo ""Count warning: $count""",33,"1847.5515842437744","0.7","0.9","llama3.3-70b","nav neviena skripta",2,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5829,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1853.0542850494385","0","0.1","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5608,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME_LINE=$(grep -w '^USERNAME' .env);USERNAME=$(echo ""$USERNAME_LINE"" | cut -d '=' -f2);export USERNAME;echo ""USERNAME: $USERNAME""",44,"1349.3375778198242","0.7","0.9","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.300000000000001"
5477,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2773.3449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"Script names with spaces are not supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
6088,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"3386.063575744629","0.2","0.4","gpt-4o","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
7406,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -21",1222,"64529.77204322815","0.2","0.4","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
4937,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,": hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. No stash entries found. ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
7394,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +20",1285,"461694.20313835144","0","0.1","deepseek-r1","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
4938,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD c6fa203..9714f9c develop -> origin/develop ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
5846,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -n *.sh 2>/dev/null | grep -c ""warning:"")
echo ""Count warning: $count""",33,"1847.5515842437744","0.7","0.9","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7842,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""
operation=""copy""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) operation=""copy"" ;;
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv ""$source""/* ""$tmp""/
 mv ""$dest""/* ""$source""/
 mv ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf ""$dest""/*
 shopt -u dotglob
fi

# Determine copy/move action
if [ $delete_source -eq 1 ]; then
 cmd=""mv""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
else
 cmd=""cp""
 overwrite_flag=""-f""
 if [ ""$overwrite"" = ""keep"" ]; then
 overwrite_flag=""-n""
 fi
 overwrite_flag+="" -a""
fi

# Execute the operation
shopt -s dotglob
if [ ""$cmd"" = ""cp"" ]; then
 cp $overwrite_flag ""$source""/. ""$dest""/
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 mv $overwrite_flag ""$source""/* ""$dest""/
 fi
fi
shopt -u dotglob",6371,"283989.96090888977","0.7","0.9","deepseek-r1","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"",0,1,2,0,"Line 29: operation appears unused. Verify use (or export if used externally). Line 49: Use *${var:?}* to ensure this never expands to /* . Line 72: Double quote to prevent globbing and word splitting. Line 76: Double quote to prevent globbing and word splitting. ","2.0","","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5026,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5479,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do if [ -x *$script* ]; then  if ./*$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT EXECUTABLE* fi done",70,"2773.3449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","21.8"
6308,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k
find /usr/lib -type f -size +3k -size -9k",98,"12098.378658294678","0","0.1","deepseek-v3","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","3.3"
5865,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck -f gcc ./*.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",615,"36493.422985076904","0.2","0.4","deepseek-r1","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5895,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",87,"8874.232769012451","0.2","0.4","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5886,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",78,"8270.371675491333","0","0.1","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5027,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"From file:///usr/git_server * branch  develop -> FETCH_HEAD edb13f7..cdba5b3 develop -> origin/develop ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
6090,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"3386.063575744629","0.2","0.4","gpt-4o","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
7436,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -print",116,"10272.840738296509","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
5910,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1239.863634109497","0","0.1","gpt-3.5-turbo","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5911,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=0

for file in *.sh; do
 warnings=$(shellcheck -f gcc ""$file"" | grep -c ""warning:"")
 count=$((count + warnings))
done

echo ""Count warning: $count""",56,"1239.863634109497","0","0.1","gpt-3.5-turbo","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.25"
5034,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 5e023d1..17ebedc develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6307,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",799,"10792.11688041687","0.7","0.9","deepseek-r1","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6268,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -print0 | xargs -0 grep -l 'FAIL' | wc -l",573,"5961.0595703125","0","0.1","deepseek-r1","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","8.45"
6276,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl --include=""result.log"" ""FAIL"" /usr/results | wc -l",144,"12184.828042984009","0.2","0.4","deepseek-v3","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","5.85"
6278,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl --include=""result.log"" ""FAIL"" /usr/results | wc -l
grep -ril --include=""result.log"" ""FAIL"" /usr/results | wc -l",172,"13400.280952453613","0.7","0.9","deepseek-v3","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","11.7"
6264,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"1341.0024642944336","0.2","0.4","llama3.3-70b","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
6262,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"2348.8073348999023","0","0.1","llama3.3-70b","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
7437,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -print",116,"10272.840738296509","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
7438,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21 -print",116,"10272.840738296509","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
5028,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD cfb8de9..00da981 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
6273,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name 'result.log' -exec grep -l -- 'FAIL' {} + | wc -l",1013,"12082.978963851929","0.7","0.9","deepseek-r1","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
6263,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -l ""FAIL"" {} \; | wc -l",34,"2348.8073348999023","0","0.1","llama3.3-70b","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.2"
5047,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD de690c3..4aa3ff9 develop -> origin/develop Switched to branch 'develop' Automatic merge went well; stopped before committing as requested ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
5013,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
6417,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, '; NR==1 {; for(i=1; i<=NF; i++) {; if ($i == ""price"") {; col = i; break; }; }; }; NR>1 {; gsub(/,/, """", $col) # Remove commas for number formatting; sum += $col; count++; }; END {; if(count > 0) {; mean = sum / count; printf ""Mean: %.2f\n"", mean; } else {; print ""Mean: 0.00""; }; };' products.csv",532,"4253.265857696533","1","1","o1-mini","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","8.45"
6436,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {printf *Mean: %.2f\n*, sum/count}' products.csv",38,"2246.554374694824","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
5016,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD cfb8de9..00da981 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
6316,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3k -size -9k -print",25,"1013.3979320526123","0.7","0.9","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.7"
6489,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",151,"11077.256917953491","0.2","0.4","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6445,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, 'NR>1 {sum+=$4; count++} END {print ""Mean: "" sum/count}' products.csv",37,"1940.981388092041","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6433,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {printf *Mean: %.2f\n*, sum/count}' products.csv",38,"2246.554374694824","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6426,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean:*, sum/count}' products.csv",33,"1649.4312286376953","0","0.1","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6427,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean:*, sum/count}' products.csv",33,"1649.4312286376953","0","0.1","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6627,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",21,"1346.937656402588","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","8.549999999999999"
6437,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, '$1~/^[0-9]+$/ {sum+=$2; count++} END {print ""Mean: "" sum/count}' products.csv",42,"2444.4854259490967","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6429,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean: * sum/count}' products.csv",34,"1643.8114643096924","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6430,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean: * sum/count}' products.csv",34,"1643.8114643096924","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6449,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if(NR>1) sum+=$4; if(NR>1) count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",49,"2854.0730476379395","0.2","0.4","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6453,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='^|,[^,]*|""$[^""]*$""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",52,"1642.8415775299072","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.96"
6085,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"5333.782434463501","0","0.1","gpt-4o","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
6454,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='^|,[^,]*|""$[^""]*$""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",52,"1642.8415775299072","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.96"
6438,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FS=, '$1~/^[0-9]+$/ {sum+=$2; count++} END {print ""Mean: "" sum/count}' products.csv",42,"2444.4854259490967","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6441,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if ($0 ~ /^[0-9]+,/) {sum+=$2; count++}} END {if (count > 0) print ""Mean: "" sum/count; else print ""No numeric values found""}' products.csv",61,"1657.3429107666016","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
6442,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FS=, '{if ($0 ~ /^[0-9]+,/) {sum+=$2; count++}} END {if (count > 0) print ""Mean: "" sum/count; else print ""No numeric values found""}' products.csv",61,"1657.3429107666016","0","0.1","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.58"
5481,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do chmod +x *$script* if ./*$script*; then  echo *$script: OK* else  echo *$script: FAIL* fi done",98,"2766.2668228149414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","12.4"
6455,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -v FPAT='^|,[^,]*|""$[^""]*$""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",52,"1642.8415775299072","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.96"
6457,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='[^,]*|""[^""]*""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",49,"1946.4893341064453","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.8599999999999999"
6458,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='[^,]*|""[^""]*""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",49,"1946.4893341064453","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.8599999999999999"
7171,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -t && systemctl restart nginx",81,"2769.6104049682617","0","0.1","qwen/qwen2.5-coder-32b-instruct","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5521,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",640,"39175.61936378479","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
6310,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",128,"10493.258237838745","0.7","0.9","deepseek-v3","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6459,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -v FPAT='[^,]*|""[^""]*""' 'NR>1 { sum+=$4 } END { print ""Mean: "" sum / (NR-1) }' products.csv",49,"1946.4893341064453","0.7","0.9","llama3.3-70b","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","1.8599999999999999"
6082,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"5333.782434463501","0","0.1","gpt-4o","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
6465,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"awk -F, ';BEGIN {; col = 0;};NR == 1 {; for (i = 1; i <= NF; i++) {; # Remove quotes and trim whitespace from header name; gsub(/[""]/, """", $i); header = tolower($i); sub(/^[ \t]+/, """", header); sub(/[ \t]+$/, """", header); if (header == ""price"") {; col = i; break; }; }; if (col == 0) {; print ""Error: Column \""price\"" not found""; exit 1; }; next;};{; if ($col != """") {; # Remove currency symbols, commas, and quotes from the value; gsub(/[""$£,]/, """", $col); sum += $col; count++; };};END {; if (count > 0) {; printf ""Mean: %.2f\n"", sum / count; } else {; print ""No valid price data found""; };}' products.csv",905,"9772.428274154663","0","0.1","deepseek-r1","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","14.35"
6515,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",38,"1144.3023681640625","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
6629,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1071.2461471557617","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6492,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",151,"11077.256917953491","0.2","0.4","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6494,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",111,"10570.882320404053","0.7","0.9","deepseek-v3","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6487,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F',' 'NR>1 {sum+=$2; count++} END {printf ""Mean: %.2f\n"", sum/count}' products.csv",128,"11079.681873321533","0","0.1","deepseek-v3","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.67"
6497,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"1244.386911392212","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6501,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1749.5629787445068","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6502,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1749.5629787445068","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
4969,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
6498,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"1244.386911392212","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir negatīvu un pozitīvu skaitļu cenas",2,"",False,"The mean value was not correctly calculated. Columns may contain negative numbers",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
5283,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d | awk '{print $1}' | xargs -I {} grep {} <(find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} +)",80,"7867.178201675415","0.7","0.9","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
6628,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | awk '{print $1}' | sort -u | wc -l",21,"1346.937656402588","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","8.549999999999999"
7446,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime +20 -mtime -28 -print",23,"1766.9649124145508","0","0.1","gpt-3.5-turbo","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified more than 3 weeks ago was found. Should be within 24 hours.",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.7"
6083,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"5333.782434463501","0","0.1","gpt-4o","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
6505,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",44,"2246.363878250122","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
5612,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash;export USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-)",617,"21331.657886505127","1","1","o1-mini",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
6509,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1750.2200603485107","0.2","0.4","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6503,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1749.5629787445068","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas un tukša rinda (kura būtu jāskaita kā 0)",2,"",False,"The mean value was not correctly calculated. Column may contain empty cells, that should be counted as 0",0,0,0,0,"","5.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
6504,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,2,"mean=$(awk -F ',' '{gsub(/[$,]/,"""",$2); sum+=$2} END {print ""Mean: "" sum/NR}' ""products.csv"");echo ""$mean""",45,"1749.5629787445068","0","0.1","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas ar decimālskaitļiem, negatīviem/pozitīviem skaitļiem un tukšām rindām (kuras būtu jāskaita kā 0)",3,"",False,"If the result is a decimal number it should not be rounded down to an integer value",0,0,0,0,"","5.75","CONDITION_PARTIALLY_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","-1"
5635,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1348.8128185272217","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
7382,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"5681.389808654785","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6513,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"mean=$(awk -F'[,;]' '{sum+=$2} END {print ""Mean: "" sum/NR}' products.csv);echo $mean",38,"1144.3023681640625","0.7","0.9","gpt-3.5-turbo","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",False,"The mean value was not correctly calculated.",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.75","CONDITION_NOT_MET","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.6500000000000004"
5613,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash;export USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-)",617,"21331.657886505127","1","1","o1-mini",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5630,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1643.474817276001","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5636,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1348.8128185272217","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5637,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1348.8128185272217","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5631,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1643.474817276001","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5627,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1345.876932144165","0","0.1","qwen/qwen2.5-coder-32b-instruct",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5628,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1345.876932144165","0","0.1","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
6630,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",10,"1071.2461471557617","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
8480,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} \;",21,"1258.3930492401123","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
5598,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1045.1622009277344","0.2","0.4","gpt-4o",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
4519,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1253.6194324493408","0.2","0.4","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
5599,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1045.1622009277344","0.2","0.4","gpt-4o",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5638,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1348.8128185272217","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5639,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"export USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",20,"1348.8128185272217","0.2","0.4","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5640,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1545.1200008392334","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5641,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env)",19,"1545.1200008392334","0.7","0.9","qwen/qwen2.5-coder-32b-instruct",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
4504,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -delete",64,"1628.7322044372559","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4945,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b549a7d..e0fc63a develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8403,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*$//' data.md",51,"1370.1674938201904","0","0.1","gpt-4o","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","8.0","","RISK","Remove last 5 lines from data.md","1.45"
5691,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2- | sed -e 's/^[""'\'' ]*//' -e 's/[""'\'' ]*$//');echo ""$USERNAME""",1839,"60383.0509185791","0.2","0.4","deepseek-r1",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5693,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | cut -d= -f2- | sed -e 's/^[""'\'' ]*//' -e 's/[""'\'' ]*$//');echo ""$USERNAME""",1839,"60383.0509185791","0.2","0.4","deepseek-r1",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6228,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1045.0496673583984","0.2","0.4","gpt-3.5-turbo","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
4509,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1377.350091934204","0","0.1","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
5695,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\'']//' -e 's/[""'\'']$//')",658,"13009.575128555298","0.7","0.9","deepseek-r1",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5696,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\'']//' -e 's/[""'\'']$//')",658,"13009.575128555298","0.7","0.9","deepseek-r1",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
5688,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"eval ""$(grep -E -- '^USERNAME=' .env)"" && echo ""$USERNAME""",1366,"292757.8113079071","0","0.1","deepseek-r1",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"/media/sf_scripts/LoadEnviornmentVariable_deepseek-r1_0_0.1_2.sh: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","5.7"
4522,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1253.6194324493408","0.2","0.4","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
8424,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '1,$(!d)' -e '$d' -e '$d' -e '$d' -e '$d' -e '$d' data.md",42,"3457.5507640838623","0","0.1","llama3.3-70b","data.md ar 4 rindām",3,"sed: can't read 1,$(!d): No such file or directory ",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.95"
7373,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"2375.4961490631104","0","0.1","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5699,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\'']//' -e 's/[""'\'']$//')",658,"13009.575128555298","0.7","0.9","deepseek-r1",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: USERNAME appears unused. Verify use (or export if used externally). ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.3"
6918,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash;;# Check if at least source and destination are provided;if [ $# -lt 2 ]; then; echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""; exit 1;fi;;# Initialize flags with default values;copy_mode=true;delete_source=false;dest_replace=true;dest_keep=false;dest_delete=false;swap_mode=false;;# Parse flags;while [[ $# -gt 0 ]]; do; case ""$1"" in; --sc); copy_mode=true; delete_source=false; shift;;; --sd); copy_mode=false; delete_source=true; shift;;; --dr); dest_replace=true; dest_keep=false; shift;;; --dk); dest_replace=false; dest_keep=true; shift;;; --dd); dest_delete=true; shift;;; --sw); swap_mode=true; shift;;; *); # First non-flag argument is source, second is destination; if [ -z ""$source"" ]; then; source=""${1:?Source directory cannot be empty}""; elif [ -z ""$dest"" ]; then; dest=""${1:?Destination directory cannot be empty}""; else; echo ""Too many arguments""; exit 1; fi; shift;;; esac;done;;# Verify source and destination are provided;if [ -z ""$source"" ] || [ -z ""$dest"" ]; then; echo ""Source and destination directories must be specified""; exit 1;fi;;# Verify directories exist;if [ ! -d ""$source"" ]; then; echo ""Source directory does not exist: $source""; exit 1;fi;;if [ ! -d ""$dest"" ]; then; echo ""Destination directory does not exist: $dest""; exit 1;fi;;# Handle swap mode;if [ ""$swap_mode"" = true ]; then; temp_dir=$(mktemp -d); mv ""${source:?}""/* ""$temp_dir""/; mv ""${dest:?}""/* ""$source""/; mv ""$temp_dir""/* ""$dest""/; rmdir ""$temp_dir""; exit 0;fi;;# Handle destination delete;if [ ""$dest_delete"" = true ]; then; rm -rf ""${dest:?}""/*;fi;;# Process files;if [ ""$copy_mode"" = true ]; then; if [ ""$dest_replace"" = true ]; then; cp -rf ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Copy only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; cp -r ""$item"" ""${dest:?}""/; fi; done; fi;fi;;if [ ""$delete_source"" = true ]; then; if [ ""$dest_replace"" = true ]; then; mv -f ""${source:?}""/* ""${dest:?}""/; elif [ ""$dest_keep"" = true ]; then; # Move only if destination doesn't exist; for item in ""${source:?}""/*; do; dest_item=""${dest:?}/$(basename ""$item"")""; if [ ! -e ""$dest_item"" ]; then; mv ""$item"" ""${dest:?}""/; else; rm -rf ""$item""; fi; done; fi;fi",933,"43106.33444786072","0.7","0.9","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
4524,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' \) -exec rm -f {} +",68,"2630.394220352173","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4512,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -delete",72,"1377.350091934204","0","0.1","gpt-4o","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4549,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3275.561809539795","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4550,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3275.561809539795","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
7338,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21",605,"4372.336626052856","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"Only files in the current directory should be found, not in subdirectories",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
5522,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",640,"39175.61936378479","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
6315,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"859.5938682556152","0.7","0.9","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
4529,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.gif' -o -iname '*.bmp' -o -iname '*.tiff' -o -iname '*.svg' -o -iname '*.apng' \) -exec rm -f {} +",76,"1352.294921875","0.7","0.9","gpt-4o","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.95"
4539,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.apng"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",461,"7773.1475830078125","1","1","o1-mini","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4545,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"2117.8817749023438","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4546,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"2117.8817749023438","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4548,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} +",60,"2117.8817749023438","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
8481,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} \;",26,"1373.7001419067383","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
4564,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} \;",61,"1718.2445526123047","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4551,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3275.561809539795","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4552,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3275.561809539795","0","0.1","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4561,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3361.6762161254883","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4553,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} +",68,"3275.561809539795","0","0.1","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4570,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} \;",69,"3560.4944229125977","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
8482,"Experiment 1","SetSGID","NL2Bash",3,2,"find *$1/.sn* -mindepth 1 -type d -exec chmod g+s {} \;",26,"1373.7001419067383","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
4571,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} \;",69,"3560.4944229125977","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4572,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} \;",69,"3560.4944229125977","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
7342,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",226,"2775.7558822631836","1","1","o1-mini","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
6185,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1958.5239887237549","0","0.1","deepseek-v3","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
4566,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} \;",61,"1718.2445526123047","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4567,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} \;",61,"1718.2445526123047","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4568,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* \) -exec rm -f {} \;",61,"1718.2445526123047","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6500000000000004"
4573,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname **.jpg* -o -iname **.jpeg* -o -iname **.png* -o -iname **.gif* -o -iname **.bmp* -o -iname **.tiff* -o -iname **.apng* \) -exec rm -f {} \;",69,"3560.4944229125977","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.8"
4584,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2084.843635559082","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4589,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.apng"" -o -name ""*.svg"" -o -name ""*.webp"" -o -name ""*.ico"" -o -name ""*.tiff"" \) -delete",87,"4966.463565826416","0.2","0.4","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
4594,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" \) -delete",73,"2208.2700729370117","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4574,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2928.107261657715","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
9239,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 | cut -c35-",34,"952.8834819793701","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.7"
9242,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1581.3758373260498","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
9244,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1581.3758373260498","0.2","0.4","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
4575,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" \) -delete",73,"2928.107261657715","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4579,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.jpeg"" -o -name ""*.png"" -o -name ""*.apng"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.ico"" -o -name ""*.tiff"" -o -name ""*.tif"" -o -name ""*.webp"" \) -delete",87,"2460.860252380371","0","0.1","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","3.05"
5526,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 bash ""$script"" &>/dev/null
 if [[ $? -eq 0 ]]; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",1143,"21651.40438079834","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"",1,0,0,0,"Line 5: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.299999999999997"
5488,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2254.9691200256348","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
8317,"Experiment 1","FindDate","NL2Bash",3,2,"date -d *2013-05-01 + $(($(date -d *2013-05-01* +%u) % 7 + 1)) days* +*%Y-%m-%d*",56,"2077.1501064300537","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
5527,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 bash ""$script"" &>/dev/null
 if [[ $? -eq 0 ]]; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",1143,"21651.40438079834","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"",1,0,0,0,"Line 5: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.299999999999997"
5508,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",1037,"20438.520431518555","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","16.349999999999998"
4611,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" -o -iname ""*.apng"" \) -delete",374,"6167.816638946533","0","0.1","deepseek-r1","Attēli ar populārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",2,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4597,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" \) -delete",73,"2208.2700729370117","0.7","0.9","llama3.3-70b","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .apng was not deleted",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.3"
4599,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -name ""*.jpg"" -o -name ""*.png"" -o -name ""*.gif"" -o -name ""*.bmp"" -o -name ""*.jpeg"" -o -name ""*.apng"" -o -name ""*.tif"" -o -name ""*.tiff"" -o -name ""*.webp"" \) -delete",80,"1653.6870002746582","0.7","0.9","llama3.3-70b","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","9.8","","RISK","Delete all the image files in the current directory and it's subdirectories","2.9000000000000004"
5509,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",1037,"20438.520431518555","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","16.349999999999998"
4612,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.webp"" -o -iname ""*.apng"" \) -delete",374,"6167.816638946533","0","0.1","deepseek-r1","Attēli ar nepopulārāriem paplašinājumiem sākotnējā direktorijā un vairāku līmeņu apakšdirektorijās katrā pa attēlam un vienai citai datnei",3,"",False,"An image with extensions .avif was not deleted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Delete all the image files in the current directory and it's subdirectories","2.75"
4635,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,1,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" \) -delete",81,"3990.223169326782","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.45"
5511,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",1037,"20438.520431518555","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","16.349999999999998"
8489,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1361.4263534545898","0.2","0.4","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
4639,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",163,"3767.9691314697266","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem tajā pašā direktorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4640,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.tiff"" -o -iname ""*.apng"" \) -delete",163,"3767.9691314697266","0","0.1","deepseek-v3","Attēli ar populārāriem paplašinājumiem 1 apakšdirektorijā",1,"",True,"",0,0,0,0,"","8.0","","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
5111,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",104,"6124.655961990356","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5513,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",419,"170708.0020904541","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
5540,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2175.381898880005","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5541,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2175.381898880005","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5542,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2175.381898880005","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8490,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1361.4263534545898","0.2","0.4","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
5015,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"From file:///usr/git_server * branch  develop -> FETCH_HEAD edb13f7..cdba5b3 develop -> origin/develop ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4673,"Experiment 1","DeleteImages","Ikdienas uzdevumu automatizācija",1,2,"find . -type f \( -iname ""*.jpg"" -o -iname ""*.jpeg"" -o -iname ""*.png"" -o -iname ""*.gif"" -o -iname ""*.bmp"" -o -iname ""*.svg"" \) -exec rm {} +",58,"1852.7305126190186","0","0.1","gpt-3.5-turbo","1 attēls ar paplašinājumu “JPG” un 1 direktorija ar attēla paplašinājumu nosaukumā",3,"",False,"An file with extension .JPG was deleted. The system uses default case-sensitive ext4 filesystem.",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Delete all the image files in the current directory and it's subdirectories","2.6"
4946,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
4971,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
5546,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",128,"10575.292348861694","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5550,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",44,"2092.625856399536","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5551,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",44,"2092.625856399536","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
4934,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
4935,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1732.5007915496826","0","0.1","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,": hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. No stash entries found. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
5020,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5554,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ ! -d ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not a regular executable file)""
 fi
done",223,"13490.965366363525","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","79.1"
4980,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 2bd49a4..cbe9b7b develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4957,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 1203e02..0fd4f48 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4958,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4959,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4988,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4982,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
4983,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2688.9355182647705","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 5cf7ea4..5c33098 develop -> origin/develop No stash entries found. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"File content seems to be incorrect after running the script. It is equal to neither local, nor remote changes.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
4992,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 2bd49a4..cbe9b7b develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5483,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do chmod +x *$script* if ./*$script*; then  echo *$script: OK* else  echo *$script: FAIL* fi done",98,"2766.2668228149414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_qwen_qwen2.5-coder-32b-instruct_0.7_0.9_2.sh: line 3: ./subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","12.4"
4993,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1305.5579662322998","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"Switched to branch 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 0204e4d..a8a0110 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4995,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin develop git stash git merge origin/develop git stash pop --index git merge -X ours origin/develop",37,"2588.1662368774414","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 5cf7ea4..5c33098 develop -> origin/develop No stash entries found. error: Merging is not possible because you have unmerged files. hint: Fix them up in the work tree, and then use 'git add/rm <file>' hint: as appropriate to mark resolution and make a commit. fatal: Exiting because of an unresolved conflict. ",False,"File content seems to be incorrect after running the script. It is equal to neither local, nor remote changes.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.55"
5000,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5001,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"Already on 'develop' From file:///usr/git_server f3ff485..67a0820 develop -> origin/develop ",False,"The script seems to actually prioritize changes from origin. Local changes should be favored.",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5002,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","8.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5003,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin git merge --strategy-option theirs origin/develop",22,"1104.5315265655518","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"Switched to branch 'develop' From file:///usr/git_server 68991d8..64795ac develop -> origin/develop ",False,"The script seems to actually prioritize changes from origin. Local changes should be favored.",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5009,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5006,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
7324,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"1409.6078872680664","0.2","0.4","gpt-4o","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
5861,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck -f gcc *.sh 2>/dev/null | grep -c "": warning"")
echo ""Count warning: $count""",1195,"13477.10919380188","0.2","0.4","deepseek-r1","1 skripts bez nevienas kļūdas",1,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","12.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6169,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Enable nullglob to prevent literal interpretation if no files match
shopt -s nullglob

# Find all files matching archive.* pattern
files=(archive.*)

# Check if exactly one file exists
if [[ ${#files[@]} -ne 1 ]]; then
 echo ""Error: Exactly one archive.* file must exist in the current directory"" >&2
 exit 1
fi

filename=""${files[0]}""

# Extract based on file extension
case ""$filename"" in
 *.tar.bz2|*.tbz2) tar xjf ""$filename"" ;;
 *.tar.gz|*.tgz) tar xzf ""$filename"" ;;
 *.tar.xz) tar xJf ""$filename"" ;;
 *.tar) tar xf ""$filename"" ;;
 *.zip) unzip ""$filename"" ;;
 *.gz)  gunzip ""$filename"" ;;
 *.bz2) bunzip2 ""$filename"" ;;
 *.rar) unrar x ""$filename"" ;;
 *.7z)  7z x ""$filename"" ;;
 *)
 echo ""Unsupported archive format: $filename"" >&2
 exit 1
 ;;
esac

echo ""Extracted $filename successfully""",1753,"16222.480058670044","0.2","0.4","deepseek-r1","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
5043,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
5044,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
5007,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
5008,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop git fetch origin git merge --strategy-option ours origin/develop",22,"2098.421812057495","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.3"
8407,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*$//' data.md",51,"1351.7792224884033","0.2","0.4","gpt-4o","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","8.0","","RISK","Remove last 5 lines from data.md","1.45"
5100,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 30bf577..9be5696 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5486,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2370.6891536712646","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5096,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"2008.3367824554443","0.2","0.4","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5085,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2309.9095821380615","0","0.1","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5484,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2370.6891536712646","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5045,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
5046,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours --no-commit --no-ff origin/develop",30,"3370.2352046966553","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 6ae04fb..524815a develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting Merge with strategy ort failed. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.449999999999999"
5118,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",160,"5267.822027206421","0.7","0.9","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b1efe32..6d20947 develop -> origin/develop Already on 'develop' ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5090,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5091,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",153,"5236.959934234619","0","0.1","deepseek-v3","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5517,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done
for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",831,"21754.627227783203","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.4"
5539,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a regular file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",204,"13688.21406364441","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","65.25"
5565,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1067.7311420440674","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
5487,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2370.6891536712646","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5489,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2254.9691200256348","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5523,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",640,"39175.61936378479","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
5524,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 bash ""$script"" &>/dev/null
 if [[ $? -eq 0 ]]; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",1143,"21651.40438079834","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"",1,0,0,0,"Line 5: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.299999999999997"
5528,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",349,"24430.90319633484","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
5549,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",44,"2092.625856399536","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5532,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1872.4009990692139","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5535,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1872.4009990692139","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5566,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1067.7311420440674","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
5557,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1433.8123798370361","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
5560,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1851.043462753296","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
5491,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2254.9691200256348","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
6190,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"8972.585678100586","0","0.1","deepseek-v3","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6894,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",True,"",0,0,0,0,"","10.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8434,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"6472.336053848267","0","0.1","deepseek-v3","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
5573,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 ./""$script""
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",52,"1364.6750450134277","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script2.sh: Permission denied /media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./space space.sh: Permission denied ",False,"A script that was successful was marked as failed. Note: script names with spaces should be supported.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.5"
5574,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 ./""$script""
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",52,"1364.6750450134277","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script1.sh: Permission denied /media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0.7_0.9.sh: line 2: ./script2.sh: Permission denied ",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.5"
5579,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 ./""$script"" &> /dev/null
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",58,"1348.3924865722656","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","15.799999999999999"
5974,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1245.2330589294434","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5561,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1851.043462753296","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
5963,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.3962783813477","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5964,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.3962783813477","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5965,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.3962783813477","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5966,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",22,"1346.9808101654053","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5967,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",22,"1346.9808101654053","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5968,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",22,"1346.9808101654053","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5969,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",22,"1346.9808101654053","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5958,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/ s/^/#/' settings.env",802,"6066.1280155181885","1","1","o1-mini","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5970,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.1991062164307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5971,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.1991062164307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5972,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1447.1991062164307","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5495,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2073.0814933776855","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5998,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1651.5777111053467","0.2","0.4","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5999,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/./s/^/#/' settings.env",17,"1651.5777111053467","0.2","0.4","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5959,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/ s/^/#/' settings.env",802,"6066.1280155181885","1","1","o1-mini","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5976,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1245.2330589294434","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6671,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"who | cut -d' ' -f1 | sort | uniq | wc -l",24,"844.7096347808838","0.2","0.4","gpt-3.5-turbo","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","6.65"
7667,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show ""$(ip route show default | awk '/default/ {print $5}')"" | awk '/inet / {print ""IP: ""$2}' | cut -d/ -f1",48,"1648.5340595245361","0.7","0.9","gpt-4o","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","8.73"
5890,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2045.0479984283447","0.2","0.4","deepseek-v3","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
4940,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4930,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5291,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}' | xargs -I {} grep -w {} <(find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} +)",83,"7748.841285705566","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
5996,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1950.90913772583","0.2","0.4","llama3.3-70b","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5997,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1950.90913772583","0.2","0.4","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6006,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/s/^/#/' settings.env",22,"3754.776954650879","0.7","0.9","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6007,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/s/^/#/' settings.env",22,"3754.776954650879","0.7","0.9","llama3.3-70b","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5294,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}'",41,"1474.0831851959229","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5295,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | awk '{print $1}' | xargs -I {} grep -w {} <(find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} +)",83,"10111.481428146362","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","-1"
6281,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results | grep ""/result.log$"" | wc -l",25,"1040.5552387237549","0","0.1","gpt-3.5-turbo","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6251,"Experiment 1","CountFailFiles","NL2Bash",1,1,"find /usr/results -type f -name ""result.log"" -exec grep -q ""FAIL"" {} \; -print | wc -l",240,"2745.370864868164","1","1","o1-mini","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","6.25"
5896,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",87,"8874.232769012451","0.2","0.4","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5897,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",87,"8874.232769012451","0.2","0.4","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5901,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2348.8032817840576","0.7","0.9","deepseek-v3","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6009,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/[^[:space:]]/s/^/#/' settings.env",22,"3754.776954650879","0.7","0.9","llama3.3-70b","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
4942,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1610.1031303405762","0.2","0.4","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6080,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*[^#]/ s/^\([^#]\)/#\1/' settings.env",31,"1146.3282108306885","0.7","0.9","gpt-3.5-turbo","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6065,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"1447.681188583374","0","0.1","gpt-3.5-turbo","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7676,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show scope global | grep inet | awk '{print *IP: * $2}' | cut -d/ -f1",34,"1856.6277027130127","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.99"
5904,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",43,"2348.8032817840576","0.7","0.9","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"Only current directory not subdirectories should be checked for scripts.",0,0,0,0,"","9.8","CONDITION_PARTIALLY_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6092,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""${file##*.}"" in
 zip) unzip ""$file"" ;;
 tar) tar -xvf ""$file"" ;;
 gz) tar -xzvf ""$file"" ;;
 bz2) tar -xjvf ""$file"" ;;
 xz) tar -xJvf ""$file"" ;;
 7z) 7z x ""$file"" ;;
 rar) unrar x ""$file"" ;;
 *) echo ""Unsupported archive type: $file"" ;;
 esac
done",122,"2118.070125579834","0.7","0.9","gpt-4o","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.099999999999998"
6093,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""${file##*.}"" in
 zip) unzip ""$file"" ;;
 tar) tar -xvf ""$file"" ;;
 gz) tar -xzvf ""$file"" ;;
 bz2) tar -xjvf ""$file"" ;;
 xz) tar -xJvf ""$file"" ;;
 7z) 7z x ""$file"" ;;
 rar) unrar x ""$file"" ;;
 *) echo ""Unsupported archive type: $file"" ;;
 esac
done",122,"2118.070125579834","0.7","0.9","gpt-4o","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.099999999999998"
5907,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",90,"9074.62453842163","0.7","0.9","deepseek-v3","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6086,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"5333.782434463501","0","0.1","gpt-4o","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
4974,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD d444aa6..ac70f67 develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
4976,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4977,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop git fetch origin develop git merge -X ours origin/develop",22,"1105.3109169006348","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6102,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash;;# Find the first archive file matching archive.* in the current directory;file=$(find . -maxdepth 1 -type f -name 'archive.*' -print -quit);;if [ -z ""$file"" ]; then; echo ""No archive file named archive.* found in the current directory.""; exit 1;fi;;case ""$file"" in; *.tar.gz|*.tgz); tar -xzf ""$file"";;; *.tar.bz2|*.tbz2); tar -xjf ""$file"";;; *.tar.xz|*.txz); tar -xJf ""$file"";;; *.zip); unzip ""$file"";;; *.7z); 7z x ""$file"";;; *.gz); gunzip ""$file"";;; *.bz2); bunzip2 ""$file"";;; *.xz); unxz ""$file"";;; *); echo ""Unsupported archive format: $file""; exit 1;;;esac",692,"5174.609184265137","1","1","o1-mini","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
6117,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3666.698694229126","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6118,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3666.698694229126","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6112,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3454.3325901031494","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
7673,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show scope global | grep inet | awk '{print *IP: * $2}' | cut -d/ -f1",34,"2361.194133758545","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss + loopback",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.99"
6109,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3438.389539718628","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6110,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3438.389539718628","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6113,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3454.3325901031494","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6114,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3454.3325901031494","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6115,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3454.3325901031494","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6111,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3438.389539718628","0","0.1","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6121,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",106,"3666.698694229126","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6214,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"1057.229995727539","0","0.1","gpt-3.5-turbo","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6159,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"2651.2489318847656","0.7","0.9","llama3.3-70b","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.550000000000004"
6128,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",105,"4065.983295440674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6122,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3562.488794326782","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6123,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzvf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjvf *$file*  ;;  *.tar.xz)  tar -xJvf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",121,"3562.488794326782","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6129,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",105,"4065.983295440674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6130,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",105,"4065.983295440674","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","19.900000000000002"
6132,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",120,"3559.7331523895264","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6146,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 esac
done",160,"1649.8157978057861","0","0.1","llama3.3-70b","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.2"
5888,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",78,"8270.371675491333","0","0.1","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5889,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -f gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",78,"8270.371675491333","0","0.1","deepseek-v3","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5031,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6215,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"1057.229995727539","0","0.1","gpt-3.5-turbo","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6208,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzf archive.tar.gz",80,"8984.855651855469","0.7","0.9","deepseek-v3","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6209,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzf archive.tar.gz",80,"8984.855651855469","0.7","0.9","deepseek-v3","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6161,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"2651.2489318847656","0.7","0.9","llama3.3-70b","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.550000000000004"
5299,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | sort -k 1,1",48,"3278.8164615631104","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9"
5300,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name **.py* -exec md5sum {} + | sort | uniq -w 32 -d | sort -k 1,1",48,"3278.8164615631104","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9"
8371,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"2073.1348991394043","0.7","0.9","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
6182,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1958.5239887237549","0","0.1","deepseek-v3","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5107,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",79,"5956.58278465271","0.2","0.4","deepseek-v3","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD fd2e153..0749b37 develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5018,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5447,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"3283.9159965515137","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8367,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"6568.41778755188","0","0.1","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
5124,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1104.9003601074219","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD af0e5e4..9569f44 develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
5466,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3666.095495223999","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
8319,"Experiment 1","FindDate","NL2Bash",3,2,"date -d *2013-05-01 + $((7 - $(date -d *2013-05-01* +%u) % 7)) days* +*%Y-%m-%d*",56,"2071.884870529175","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
5921,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

# Using find command to locate all bash scripts in the current directory
# Using xargs to execute shellcheck on each script and grep to count the lines containing ""warning""
warning_count=$(find . -type f -name ""*.sh"" -exec shellcheck {} \; | grep -c ""warning"")

echo ""Count warning: $warning_count""",80,"1442.976713180542","0.7","0.9","gpt-3.5-turbo","1 skripts bez nevienas kļūdas",1,"",True,"",0,0,0,0,"","9.8","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5927,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"#!/bin/bash

# Using a for loop to iterate over each bash script in the current directory
# Using shellcheck to check for warnings and counting the output lines containing ""warning""
warning_count=0
for script in *.sh; do
 ((warning_count += $(shellcheck ""$script"" | grep -c ""warning"")))
done

echo ""Count warning: $warning_count""",84,"2249.9794960021973","0.7","0.9","gpt-3.5-turbo","nav neviena skripta",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","8.65"
6222,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"867.652177810669","0.2","0.4","gpt-3.5-turbo","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6223,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"867.652177810669","0.2","0.4","gpt-3.5-turbo","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6224,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"867.652177810669","0.2","0.4","gpt-3.5-turbo","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5350,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name '*.txt' -exec wc -l {} + | awk '{total += $1} END {print total}'",37,"1751.7964839935303","0.2","0.4","gpt-4o","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.77"
8320,"Experiment 1","FindDate","NL2Bash",3,1,"date -d *2013-05-01 + $(($(date -d *2013-05-01* +%u) % 7)) days* +*%Y-%m-%d*",53,"1775.742530822754","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāizdrukā datuma skaitlis",1,"",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","-1"
5836,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1448.106050491333","0.2","0.4","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
7175,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -s reload",78,"3369.8432445526123","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5060,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull -X ours origin develop",1186,"17969.10309791565","0.2","0.4","deepseek-r1","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5048,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
8500,"Experiment 1","SetSGID","NL2Bash",3,1,"#!/bin/bash
if [ -d ""$1/.sn"" ]; then
 find ""$1/.sn"" -type d -exec chmod g+s {} \;
fi",149,"11378.690242767334","0.2","0.4","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","6.15"
5359,"Experiment 1","CountLines","NL2Bash",1,1,"find /usr/files -type f -name ""*.txt"" -exec cat {} + | wc -l",1328,"24427.016973495483","0","0.1","deepseek-r1","Datne direktorijā un virsējā, katrā vairākas rindas, papildus viena ne .txt datne direktorijā mapē ar vairākām rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count all the lines of all '*.txt' files in /usr/files directory recursively","6.1"
5778,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",48,"1456.9919109344482","0.2","0.4","gpt-4o","2 skripti ar warning un cita līmeņa kļūdām, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5832,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -c ""warning:"")
echo ""Count warning: $count""",26,"4054.0614128112793","0.2","0.4","llama3.3-70b","nav neviena skripta",2,"",False,"",0,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5066,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --strategy=ours",825,"12299.521446228027","0.2","0.4","deepseek-r1","Nav konfliktu",1,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 2b5d6a0..c0f3097 develop -> origin/develop ",False,"Changes weren't pulled.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.9"
5072,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",607,"10037.67204284668","0.7","0.9","deepseek-r1","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6296,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",22,"1359.8783016204834","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
5820,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(shellcheck *.sh | grep -i ""warning:"" | wc -l)
echo ""Count warning: $count""",31,"2545.4046726226807","0","0.1","llama3.3-70b","2 skripti ar tikai warning līmeņa kļūdām",1,"",False,"The script should have outputted *Count warning: 5* since there were 5 warning level errors.",1,1,0,0,"Line 2: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","6.5","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5610,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash;export USERNAME=$(grep '^USERNAME=' .env | cut -d '=' -f2-)",617,"21331.657886505127","1","1","o1-mini",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8313,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 +$(( (1 - $(date -d ""2013-05-01"" +%u) + 7) % 7 )) days"" +""%Y-%m-%d""",55,"1695.2235698699951","0.7","0.9","gpt-4o","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","-1"
5839,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1448.106050491333","0.2","0.4","llama3.3-70b","2 skripti ar warning un cita līmeņa kļūdām, viena warning līmeņa kļūda satur vārdu “warning”, 1 skripts apakšdirektorijā ar warning līmeņa kļūdām",3,"",False,"The script should have outputted *Count warning: 3* since there were 3 warning level errors.",0,0,0,0,"","7.3999999999999995","CONDITION_NOT_MET","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5841,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"count=$(find . -maxdepth 1 -type f -name ""*.sh"" -exec shellcheck -n {} \; | grep -c ""warning:"")
echo ""Count warning: $count""",46,"3558.030843734741","0.7","0.9","llama3.3-70b","1 skripts bez nevienas kļūdas",1,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
6217,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1647.4695205688477","0","0.1","gpt-3.5-turbo","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6218,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1647.4695205688477","0","0.1","gpt-3.5-turbo","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5078,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
5827,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,2,"count=$(shellcheck ./*.sh | grep -c ""warning:"")
echo ""Count warning: $count""",27,"1853.0542850494385","0","0.1","llama3.3-70b","nav neviena skripta",2,"",False,"",0,0,0,0,"","7.3999999999999995","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
5449,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1774.1165161132812","0.7","0.9","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
6306,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",587,"9085.393190383911","0.2","0.4","deepseek-r1","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
7191,"Experiment 1","HostHtml","IaC",1,1,"# Install nginx if not already installed
apt update && apt install -y nginx

# Create the HTML directory and index file
mkdir -p /usr/html
echo ""<html><body><h1>Welcome to Nginx</h1></body></html>"" > /usr/html/index.html

# Configure nginx to serve from /usr/html
cat > /etc/nginx/sites-available/default <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;

 root /usr/html;
 index index.html;

 server_name _;

 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF

# Test configuration and restart nginx
nginx -t && systemctl restart nginx",164,"12030.475378036499","0.2","0.4","deepseek-v3","index.html patstāvīgs",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7176,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -s reload",78,"3369.8432445526123","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","index.html ir atkarīgs no citām datnēm",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
6216,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"1057.229995727539","0","0.1","gpt-3.5-turbo","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
7205,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx
mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html_backup
cp /usr/html/index.html /usr/share/nginx/html/
systemctl restart nginx",46,"1010.5247497558594","0.7","0.9","gpt-3.5-turbo","index.html patstāvīgs",1," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
5138,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5139,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5127,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
6606,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"981.6792011260986","0","0.1","gpt-4o","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
7206,"Experiment 1","HostHtml","IaC",1,1,"apt update
apt install nginx
mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html_backup
cp /usr/html/index.html /usr/share/nginx/html/
systemctl restart nginx",46,"1010.5247497558594","0.7","0.9","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
7208,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx
mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html_backup
cp /usr/html/index.html /usr/share/nginx/html/
systemctl restart nginx",46,"1189.8627281188965","0.7","0.9","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","6.950000000000001"
6297,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",22,"1365.910530090332","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
5425,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2335.8707427978516","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5144,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
5146,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git pull -s recursive -X ours origin develop",16,"802.6316165924072","0.7","0.9","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","1.65"
5427,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2335.8707427978516","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
6294,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",23,"1057.3344230651855","0.7","0.9","gpt-4o","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6292,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/library -type f -size +3k -size -9k",23,"893.1388854980469","0","0.1","gpt-4o","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6301,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"1559.6227645874023","0.2","0.4","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6302,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3072c -size -9216c",25,"1466.1505222320557","0.2","0.4","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
7200,"Experiment 1","HostHtml","IaC",1,2,"apt update
apt install nginx

echo ""Hello, World!"" > /usr/share/nginx/html/index.html

systemctl restart nginx",32,"1398.4355926513672","0","0.1","gpt-3.5-turbo","index.html ir atkarīgs no citām datnēm",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","5.550000000000001"
7168,"Experiment 1","HostHtml","IaC",1,1,"mkdir -p /usr/html
echo ""<!DOCTYPE html><html><head><title>Welcome</title></head><body><h1>Hello, World!</h1></body></html>"" > /usr/html/index.html
cat > /etc/nginx/sites-available/default <<EOF
server {
 listen 80 default_server;
 listen [::]:80 default_server;
 root /usr/html;
 index index.html;
 server_name _;
 location / {
 try_files \$uri \$uri/ =404;
 }
}
EOF
nginx -t && systemctl restart nginx",652,"4984.140396118164","1","1","o1-mini","index.html ir atkarīgs no citām datnēm",2,"nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful ",False,"index.html was not hosted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
5544,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",128,"10575.292348861694","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5650,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
USERNAME=${USERNAME}
echo $USERNAME",17,"1548.0294227600098","0","0.1","llama3.3-70b",".env datne are tikai USERNAME",1,"",False,"",0,3,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: This variable is assigned to itself, so the assignment does nothing. Line 4: Double quote to prevent globbing and word splitting. ","5.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","4"
8433,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"6472.336053848267","0","0.1","deepseek-v3","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
5552,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ ! -d ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not a regular executable file)""
 fi
done",223,"13490.965366363525","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","79.1"
5569,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1343.9648151397705","0.2","0.4","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
5576,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 ./""$script"" &> /dev/null
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",58,"1348.3924865722656","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A script that was successful was marked as failed.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","15.799999999999999"
5577,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 ./""$script"" &> /dev/null
 if [ $? -eq 0 ]; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
done",58,"1348.3924865722656","0.7","0.9","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A script that was successful was marked as failed. Note: script names with spaces should be supported.",1,0,0,0,"Line 4: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","15.799999999999999"
5556,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 ./""$script"" && echo ""$script: OK"" || echo ""$script: FAIL""
 fi
done",49,"1433.8123798370361","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","23.45"
7209,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",77,"1743.701696395874","0","0.1","gpt-4o","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
5545,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",128,"10575.292348861694","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
5547,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",128,"10575.292348861694","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
6236,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"954.1122913360596","0.7","0.9","gpt-3.5-turbo","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6875,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with no flags passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
7233,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796"" && 
gpg --verify data.tgz.asc data.tgz && echo ""OK"" || echo ""FAIL""",76,"1764.6617889404297","0.2","0.4","llama3.3-70b","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.650000000000002"
7231,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash

# Retrieve the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796""

# Verify the signature
if gpg --verify data.tgz.asc data.tgz &> /dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",106,"1903.2974243164062","0","0.1","llama3.3-70b","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.95"
6237,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",13,"851.8917560577393","0.7","0.9","gpt-3.5-turbo","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6155,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",172,"3465.360403060913","0.7","0.9","llama3.3-70b","arhīvs ir .bz2",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","43.55"
6314,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3k -size -9k -exec ls -l {} +",29,"966.4664268493652","0.2","0.4","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.9000000000000001"
6232,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"954.1122913360596","0.7","0.9","gpt-3.5-turbo","arhīvs ir .tar.gz",1," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.tar.gz or  archive.tar.gz.zip, and cannot find archive.tar.gz.ZIP, period. ",False,"An archive of type .tar.gz was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
7212,"Experiment 1","VerifyFile","IaC",1,1,"# Import the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the file against its signature
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",95,"1964.7493362426758","0.2","0.4","gpt-4o","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
7214,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",77,"1769.685983657837","0.7","0.9","gpt-4o","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
7234,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796"" && 
gpg --verify data.tgz.asc data.tgz && echo ""OK"" || echo ""FAIL""",76,"1764.6617889404297","0.2","0.4","llama3.3-70b","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.650000000000002"
7230,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Retrieve the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796

# Verify the signature
if gpg --verify data.tgz.asc data.tgz &> /dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",96,"1961.4758491516113","0","0.1","llama3.3-70b","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.95"
7232,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash

# Retrieve the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796""

# Verify the signature
if gpg --verify data.tgz.asc data.tgz &> /dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",106,"1903.2974243164062","0","0.1","llama3.3-70b","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.95"
7215,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",1064,"9295.913934707642","1","1","o1-mini","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
7222,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"2670.0408458709717","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
6311,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"1468.0213928222656","0","0.1","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
8357,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",1767,"10897.801160812378","1","1","o1-mini","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
4955,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"From file:///usr/git_server * branch  develop -> FETCH_HEAD edb13f7..cdba5b3 develop -> origin/develop ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","8.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4970,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Nav konfliktu",1,"",True,"",0,0,0,0,"","9.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
7239,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDDCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",634,"34696.24853134155","0","0.1","deepseek-r1","Datne ir pareiza",1,"",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
7240,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDDCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",634,"34696.24853134155","0","0.1","deepseek-r1","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
7249,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key if not already present
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 &>/dev/null

# Verify the signature and capture output
if gpg --verify data.tgz.asc data.tgz &>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",104,"10700.22177696228","0.2","0.4","deepseek-v3","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.25"
7247,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature and capture the output
if gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature""; then
 echo ""OK""
else
 echo ""FAIL""
fi",108,"10392.459869384766","0","0.1","deepseek-v3","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","16.1"
7238,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796"" && 
gpg --verify data.tgz.asc data.tgz > /dev/null 2>&1 && echo ""OK"" || echo ""FAIL""",84,"1750.3974437713623","0.7","0.9","llama3.3-70b","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.750000000000004"
6303,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"1354.1216850280762","0.7","0.9","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
4895,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash;;# Find json data in files with ""user"" keys;users=$(grep -h '""user""' *.json | cut -d '""' -f 4 | sort | uniq);;if [ -z ""$users"" ]; then; echo ""No users found"";else; echo ""Here are the users: $users"";fi",77,"1678.184986114502","0","0.1","gpt-3.5-turbo","Viena datne, kur ir ievadīts “users”: “Tommy Black”, bet nav json, otra ar json, kur ir citi lietotāji",2,"",False,"Users were found but the output should be alphabetically sorted.",0,1,0,0,"Line 4: Use ./*glob* or -- *glob* so names with dashes won't become options. ","6.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","9.450000000000001"
4929,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
4964,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Nav konfliktu",1,"",True,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
8487,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"4962.979793548584","0.2","0.4","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8491,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"1861.0262870788574","0.7","0.9","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7259,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1391.5436267852783","0.2","0.4","gpt-3.5-turbo","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
7255,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1953.2959461212158","0","0.1","gpt-3.5-turbo","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
8391,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",41,"1068.2544708251953","0.2","0.4","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.25"
8459,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1158.3952903747559","0.2","0.4","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7261,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key from keyserver.ubuntu.com
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature of the file
gpg --verify data.tgz.asc data.tgz 2>/dev/null

if [ $? -eq 0 ]; then
 echo ""OK""
else
 echo ""FAIL""
fi",133,"1865.4935359954834","0.7","0.9","gpt-3.5-turbo","Datne ir pareiza",1,"",False,"",1,0,0,0,"Line 9: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.2"
7264,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash

# Import the public key from keyserver.ubuntu.com
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature of the file
if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",101,"1591.5627479553223","0.7","0.9","gpt-3.5-turbo","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.7"
5437,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1344.7151184082031","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"A succesful script was skipped. Note: script names with spaces should be supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
5438,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1344.7151184082031","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
5258,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"find . -type f -exec sh -c 'if git check-ignore -q {} 2>/dev/null; then rm {}; fi' \;",36,"2254.000663757324","0","0.1","gpt-3.5-turbo","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"",0,0,1,0,"Line 2: Injecting filenames is fragile and insecure. Use parameters. ","7.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.7"
8488,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"4962.979793548584","0.2","0.4","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
6140,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 esac
done",160,"3597.9018211364746","0","0.1","llama3.3-70b","arhīvs ir .bz2",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.199999999999996"
4947,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,": hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. No stash entries found. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
6304,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3072c -size -9216c",25,"1514.8308277130127","0.7","0.9","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6299,"Experiment 1","SearchFilesBySize","NL2Bash",1,1,"find /usr/lib -type f -size +3k -size -9k",23,"1587.040901184082","0","0.1","llama3.3-70b","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.65"
6970,"Experiment 1","InstallHtop","IaC",3,2,"cd /usr/local || exit wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf 3.1.0.tar.gz mv htop-3.1.0 htop310 cd htop310 || exit apt-get update apt-get install -y build-essential autoconf pkg-config libtool libncursesw5-dev ./autogen.sh ./configure --prefix=/usr/local/htop310 make make install ln -s /usr/local/htop310/bin/htop /usr/local/bin/htop",146,"3834.280490875244","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,"n/autoconf --force autoreconf: running: /usr/bin/autoheader --force autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was not installed to the correct directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","19.200000000000003"
6098,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find the archive file with the name pattern archive.*
file=$(ls archive.* 2>/dev/null | head -n 1)

if [ -z ""$file"" ]; then
 echo ""No archive file named archive.* found in the current directory.""
 exit 1
fi

case ""$file"" in
 *.tar.gz|*.tgz)
 tar -xzf ""$file""
 ;;
 *.tar.bz2|*.tbz2)
 tar -xjf ""$file""
 ;;
 *.tar.xz|*.txz)
 tar -xJf ""$file""
 ;;
 *.zip)
 unzip ""$file""
 ;;
 *.7z)
 7z x ""$file""
 ;;
 *.gz)
 gunzip ""$file""
 ;;
 *.bz2)
 bunzip2 ""$file""
 ;;
 *.xz)
 unxz ""$file""
 ;;
 *)
 echo ""Unsupported archive format: $file""
 exit 1
 ;;
esac",1003,"5970.0939655303955","1","1","o1-mini","arhīvs ir .gz",1,"",False,"",0,1,0,0,"Line 4: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
6967,"Experiment 1","InstallHtop","IaC",3,1,"mkdir -p /usr/local/htop310 wget -O /usr/local/htop310/htop-3.1.0.tar.gz https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf /usr/local/htop310/htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1 cd /usr/local/htop310 ./configure --prefix=/usr/local/htop310 make make install echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile source /etc/profile",162,"4574.073076248169","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,".... 81% 1.21M 0s 300K .......... .......... .......... .......... .......... 94% 2.30M 0s 350K .......... .........     100% 1.03M=0.3s 2025-04-03 04:17:29 (1.40 MB/s) - ‘/usr/local/htop310/htop-3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 5: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,2,1,0,"Line 5: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 9: Expressions don't expand in single quotes, use double quotes for that. Line 10: Not following: /etc/profile was not specified as input (see shellcheck -x). ","1.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","11.5"
6968,"Experiment 1","InstallHtop","IaC",3,2,"mkdir -p /usr/local/htop310 wget -O /usr/local/htop310/htop-3.1.0.tar.gz https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf /usr/local/htop310/htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1 cd /usr/local/htop310 || exit ./autogen.sh ./configure --prefix=/usr/local/htop310 make make install echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile source /etc/profile",169,"4184.7288608551025","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,"e is generated without pkg.m4. 'make dist' target will be disabled. autoreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ",False,"Htop was installed but not added to path",0,2,0,0,"Line 10: Expressions don't expand in single quotes, use double quotes for that. Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","6.0","CONDITION_PARTIALLY_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","14.1"
6971,"Experiment 1","InstallHtop","IaC",3,1,"cd /usr/local wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz tar -xzf 3.1.0.tar.gz mv htop-3.1.0 htop310 cd htop310 ./configure --prefix=/usr/local/htop310 make make install echo 'export PATH=$PATH:/usr/local/htop310/bin' >> /etc/profile source /etc/profile",115,"3565.704345703125","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāinstalē htop 3.1.0",1,".... .......... .......... 81% 6.65M 0s 300K .......... .......... .......... .......... .......... 94% 1.08M 0s 350K .......... .........     100% 13.6M=0.2s 2025-04-03 04:20:28 (1.56 MB/s) - ‘3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_qwen_qwen2.5-coder-32b-instruct_0.7_0.9.sh: line 6: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,2,1,0,"Line 2: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 10: Expressions don't expand in single quotes, use double quotes for that. Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","1.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","12.6"
6135,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",120,"3559.7331523895264","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
7292,"Experiment 1","Factorial","NL2Bash",2,2,"factorial=1
for ((i=1; i<=623; i++)); do
 factorial=$(bc <<< ""$factorial * $i"")
done

echo ""Factorial of 623 is: $factorial""",52,"1406.7838191986084","0.7","0.9","gpt-3.5-turbo","Jāaprēķina faktoriālis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate the factorial of 623","-1"
6136,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do case $file in  *.zip)  unzip *$file*  ;;  *.tar.gz|*.tgz)  tar -xzf *$file*  ;;  *.tar.bz2|*.tbz2)  tar -xjf *$file*  ;;  *.tar.xz)  tar -xJf *$file*  ;;  *.7z)  7z x *$file*  ;;  *)  echo *Unsupported archive format: $file*  ;; esac done",120,"3559.7331523895264","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","23.3"
6975,"Experiment 1","InstallHtop","IaC",3,1,"wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz
tar -xvf 3.1.0.tar.gz
mkdir -p /usr/local/htop310
mv htop-3.1.0 /usr/local/htop310
cd /usr/local/htop310/htop-3.1.0
./configure --prefix=/usr/local/htop310
make
make install
echo ""export PATH=$PATH:/usr/local/htop310/bin"" >> /etc/profile
source /etc/profile",131,"2951.3328075408936","0.2","0.4","llama3.3-70b","Jāinstalē htop 3.1.0",1,"... .......... .......... .......... .......... 81% 6.52M 0s 300K .......... .......... .......... .......... .......... 94% 11.3M 0s 350K .......... .........     100% 31.1M=0.2s 2025-04-03 04:21:54 (2.00 MB/s) - ‘3.1.0.tar.gz’ saved [378838/378838] /media/sf_scripts/InstallHtop_llama3.3-70b_0_0.1.sh: line 6: ./configure: No such file or directory make: *** No targets specified and no makefile found. Stop. make: *** No rule to make target 'install'. Stop. ",False,"Htop was not installed or not added to path (couldn't find)",0,1,1,0,"Line 6: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. Line 11: Not following: /etc/profile was not specified as input (see shellcheck -x). ","2.0","CONDITION_NOT_MET","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","12.65"
6896,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

# Check if at least source and destination are provided
if [ $# -lt 2 ]; then
 echo ""Usage: $0 [--sc|--sd] [--dr|--dk|--dd] [--sw] source destination""
 exit 1
fi

# Initialize flags
copy_mode=true
delete_source=false
dest_replace=true
dest_keep=false
dest_delete=false
swap_mode=false

# Parse flags
while [[ $# -gt 2 ]]; do
 case ""$1"" in
 --sc)
 copy_mode=true
 delete_source=false
 shift
 ;;
 --sd)
 copy_mode=false
 delete_source=true
 shift
 ;;
 --dr)
 dest_replace=true
 dest_keep=false
 dest_delete=false
 shift
 ;;
 --dk)
 dest_replace=false
 dest_keep=true
 dest_delete=false
 shift
 ;;
 --dd)
 dest_replace=false
 dest_keep=false
 dest_delete=true
 shift
 ;;
 --sw)
 swap_mode=true
 shift
 ;;
 *)
 echo ""Unknown option: $1""
 exit 1
 ;;
 esac
done

# Get source and destination from remaining arguments
args=(""$@"")
source_dir=""${args[-2]}""
dest_dir=""${args[-1]}""

# Validate directories
if [ ! -d ""${source_dir:?}"" ]; then
 echo ""Source directory does not exist: $source_dir""
 exit 1
fi

if [ ! -d ""${dest_dir:?}"" ]; then
 echo ""Destination directory does not exist: $dest_dir""
 exit 1
fi

# Handle swap mode
if [ ""$swap_mode"" = true ]; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""${temp_dir:?}/"" 2>/dev/null
 mv ""${dest_dir:?}""/* ""${source_dir:?}/"" 2>/dev/null
 mv ""${temp_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 rm -rf ""$temp_dir""
 exit 0
fi

# Handle destination deletion
if [ ""$dest_delete"" = true ]; then
 rm -rf ""${dest_dir:?}""/*
fi

# Process files
if [ ""$copy_mode"" = true ]; then
 if [ ""$dest_replace"" = true ]; then
 cp -rf ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  cp -rf ""$file"" ""${dest_dir:?}/""
 fi
 fi
 done
 fi
 if [ ""$delete_source"" = true ]; then
 rm -rf ""${source_dir:?}""/*
 fi
else
 # Move mode (--sd)
 if [ ""$dest_replace"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ -e ""${dest_dir:?}/$base"" ]; then
  rm -rf ""${dest_dir:?}/$base""
 fi
 mv ""$file"" ""${dest_dir:?}/""
 fi
 done
 elif [ ""$dest_keep"" = true ]; then
 for file in ""${source_dir:?}""/*; do
 if [ -e ""$file"" ]; then
 base=$(basename ""$file"")
 if [ ! -e ""${dest_dir:?}/$base"" ]; then
  mv ""$file"" ""${dest_dir:?}/""
 elif [ ""$delete_source"" = true ]; then
  rm -rf ""$file""
 fi
 fi
 done
 elif [ ""$dest_delete"" = true ]; then
 # Special case for --sd --dd
 rm -rf ""${dest_dir:?}""/*
 mv ""${source_dir:?}""/* ""${dest_dir:?}/"" 2>/dev/null
 fi
fi",1080,"51155.34234046936","0","0.1","deepseek-v3","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",True,"",0,0,0,0,"","10.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6162,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"shopt -s nullglob
for file in archive.*; do
 case ""$file"" in
 *.tar.gz|*.tgz) tar xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar xjf ""$file"" ;;
 *.tar.xz) tar xJf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar xf ""$file"" ;;
 *) echo ""Skipping unsupported file: $file"" ;;
 esac
done
shopt -u nullglob",1752,"15410.104990005493","0","0.1","deepseek-r1","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","32.9"
6137,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 esac
done",160,"3597.9018211364746","0","0.1","llama3.3-70b","arhīvs ir .tar.gz",1,"",False,"An archive of type .tar.gz was not extracted.",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.199999999999996"
6142,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 esac
done",160,"1649.8157978057861","0","0.1","llama3.3-70b","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.2"
6163,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"shopt -s nullglob
for file in archive.*; do
 case ""$file"" in
 *.tar.gz|*.tgz) tar xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar xjf ""$file"" ;;
 *.tar.xz) tar xJf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar xf ""$file"" ;;
 *) echo ""Skipping unsupported file: $file"" ;;
 esac
done
shopt -u nullglob",1752,"15410.104990005493","0","0.1","deepseek-r1","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","32.9"
5717,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"1455.7926654815674","0.2","0.4","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5733,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",143,"12588.644742965698","0.7","0.9","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","13.450000000000001"
5707,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"2147.033452987671","0","0.1","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
6172,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find all files matching archive.*
files=( archive.* )

# Check if there is exactly one archive file
if [[ ${#files[@]} -eq 0 ]]; then
 echo ""Error: No archive.* file found."" >&2
 exit 1
elif [[ ${#files[@]} -gt 1 ]]; then
 echo ""Error: Multiple archive.* files found. Only one expected."" >&2
 exit 1
fi

file=""${files[0]}""

# Extract based on file extension
case ""$file"" in
 *.tar.gz|*.tgz) tar -xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar -xjf ""$file"" ;;
 *.tar.xz|*.txz) tar -xJf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.gz)  gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz)  unxz ""$file"" ;;
 *.7z)  7z x ""$file"" ;;
 *)
 echo ""Error: Unsupported archive format: $file"" >&2
 exit 1
 ;;
esac

# Check if extraction succeeded
if [[ $? -ne 0 ]]; then
 echo ""Error: Failed to extract $file"" >&2
 exit 1
fi

echo ""Successfully extracted: $file""",1821,"46573.923110961914","0.7","0.9","deepseek-r1","arhīvs ir .tar.gz",1,"",False,"",1,0,0,0,"Line 36: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","12.5","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
6211,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzf archive.tar.gz",80,"8984.855651855469","0.7","0.9","deepseek-v3","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5748,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"1441.9188499450684","0.2","0.4","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5750,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"1371.0200786590576","0.2","0.4","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5081,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge --ff-only origin/develop
git checkout stash -- .
git stash drop",2958,"126781.91184997559","0.7","0.9","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 4dd2027..79c7401 develop -> origin/develop Switched to branch 'develop' fatal: Not possible to fast-forward, aborting. fatal: invalid reference: stash No stash entries found. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","8.549999999999999"
7144,"Experiment 1","SetupAlpineContainer","IaC",2,2,"mkdir -p /usr/alpinedata
chmod 755 /usr/alpinedata
docker run -it --name alpine-linux-container -v /usr/alpinedata:/imported alpine sh
ls /imported
exit
docker inspect alpine-linux-container | grep -A 5 Mounts",231,"15773.987770080566","0.2","0.4","deepseek-v3","Docker nav iedarbināts",3,"the input device is not a TTY ls: cannot access '/imported': No such file or directory ",False,"Alpine container named *alpine-linux-container* was not created. The script should start docker if it's not running.",0,1,0,0,"Line 7: Command appears to be unreachable. Check usage (or ignore if invoked indirectly). ","4.0","CONDITION_NOT_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","12"
8683,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8393,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"1050.1229763031006","0.7","0.9","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
6198,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"9391.114711761475","0.2","0.4","deepseek-v3","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6199,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",91,"9391.114711761475","0.2","0.4","deepseek-v3","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6207,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzf archive.tar.gz",80,"8984.855651855469","0.7","0.9","deepseek-v3","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6985,"Experiment 1","InstallHtop","IaC",3,1,"# Install required build tools
apt update
apt install -y build-essential

# Download htop source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir -p /usr/local/htop310
tar -xzf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310
./autogen.sh
./configure
make
make install

# Add htop binary to the system path
ln -s /usr/local/bin/htop /usr/local/htop310/htop

# Clean up
rm htop-3.1.0.tar.gz",188,"2956.825017929077","0","0.1","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"igure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ln: failed to create symbolic link '/usr/local/htop310/htop': File exists rm: cannot remove 'htop-3.1.0.tar.gz': No such file or directory ",False,"Htop was not installed to the correct directory",0,0,1,0,"Line 14: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","3.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","13.600000000000001"
5753,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"1371.0200786590576","0.2","0.4","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
8685,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8686,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, bet viena no tām ir aizkomentēta",3,"",False,"",0,0,0,0,"","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
6954,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

if [ ""$1"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/. ""$destination_dir""
elif [ ""$1"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--dd"" ]; then
 rm -rf ""$destination_dir""/*
 cp -r ""$source_dir""/* ""$destination_dir""
elif [ ""$1"" == ""--sw"" ]; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 cp -r ""$source_dir""/* ""$destination_dir""
fi",233,"3271.5070247650146","0.7","0.9","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","127.85000000000002"
6241,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzvf archive.tar.gz",13,"851.8917560577393","0.7","0.9","gpt-3.5-turbo","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5754,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"1371.0200786590576","0.2","0.4","gpt-3.5-turbo",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
8354,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -ls",22,"1272.392988204956","0.7","0.9","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
6989,"Experiment 1","InstallHtop","IaC",3,1,"# Install necessary build tools
apt update
apt install -y build-essential

# Download the source code
wget https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz -O htop-3.1.0.tar.gz

# Extract the source code
mkdir /usr/local/htop310
tar -xzvf htop-3.1.0.tar.gz -C /usr/local/htop310 --strip-components=1

# Compile and install htop
cd /usr/local/htop310
./autogen.sh
./configure
make
make install

# Add htop binary to the path
ln -s /usr/local/htop310/htop /usr/local/bin/htop",168,"2361.6998195648193","0.7","0.9","gpt-3.5-turbo","Jāinstalē htop 3.1.0",1,"toreconf: running: automake --add-missing --copy --force-missing configure.ac:61: installing 'build-aux/compile' configure.ac:15: installing 'build-aux/config.guess' configure.ac:15: installing 'build-aux/config.sub' configure.ac:16: installing 'build-aux/install-sh' configure.ac:16: installing 'build-aux/missing' Makefile.am: installing './INSTALL' Makefile.am: installing 'build-aux/depcomp' autoreconf: Leaving directory '.' ln: failed to create symbolic link '/usr/local/bin/htop': File exists ",False,"Htop was not installed to the correct directory",0,0,1,0,"Line 14: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","3.0","TOO_MUCH_DONE","RISK","Download Htop from https://github.com/htop-dev/htop/archive/refs/tags/3.1.0.tar.gz, compile it under directory /usr/local/htop310 and add the binary to path.","12.200000000000001"
5735,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo $USERNAME
else
 echo ""Error: .env file not found""
fi",61,"2147.5472450256348","0","0.1","gpt-3.5-turbo",".env datne are tikai USERNAME",1,"",False,"",0,2,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). Line 6: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5049,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5050,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",False,"",0,0,0,0,"","7.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5480,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do chmod +x *$script* if ./*$script*; then  echo *$script: OK* else  echo *$script: FAIL* fi done",98,"2766.2668228149414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","12.4"
5708,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo ""$USERNAME""",14,"2147.033452987671","0","0.1","deepseek-v3",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,1,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). ","7.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5452,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in ./*.sh; do
 if bash ""$script""; then
 echo ""$(basename ""$script""): OK""
 else
 echo ""$(basename ""$script""): FAIL""
 fi
done",444,"3579.9190998077393","1","1","o1-mini","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5741,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"2062.706470489502","0","0.1","gpt-3.5-turbo",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"Only USERNAME should be set, not other fields",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","TOO_MUCH_DONE","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5742,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"2062.706470489502","0","0.1","gpt-3.5-turbo",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
7004,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update && apt install -y postgresql;;# Change PostgreSQL to listen on port 5433;sed -i ""s/^#*port = .*/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create the storedb database;sudo -u postgres createdb storedb;;# Run init.sql on storedb;sudo -u postgres psql -d storedb -f ""$(pwd)/init.sql"";;# Create user public_view with password 'fox' and grant read-only access;sudo -u postgres psql -d storedb <<EOF;CREATE USER public_view WITH PASSWORD 'fox';;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",2266,"14391.648530960083","1","1","o1-mini","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","20.450000000000003"
5743,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"#!/bin/bash

# Load the value of ""USERNAME"" from the .env file in the current directory
if [ -f .env ]; then
 source .env
 echo ""$USERNAME""
else
 echo ""Error: .env file not found""
fi",61,"2062.706470489502","0","0.1","gpt-3.5-turbo",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,".env: line 1: Jameson: command not found ",False,"The script attempted to use a utility Jameson that is not available in the Debian repositories (via apt-get install)",0,1,0,0,"Line 5: Not following: .env was not specified as input (see shellcheck -x). ","7.0","CONDITION_NOT_MET","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","10.5"
5600,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",25,"1552.9584884643555","0.7","0.9","gpt-4o",".env datne are tikai USERNAME",1,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","7.2","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5601,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",25,"1552.9584884643555","0.7","0.9","gpt-4o",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","7.2","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5602,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",25,"1552.9584884643555","0.7","0.9","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","7.2","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
7783,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"strace -f -e execve ./exec.sh 2>&1 | grep execve | awk '{print $2}' | sed 's/[^a-zA-Z0-9_./-]*//g'",50,"1254.1680335998535","0.2","0.4","llama3.3-70b","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.799999999999999"
6994,"Experiment 1","SetupPostgres","IaC",2,2,"# Ensure the init.sql file is in the current directory;INIT_SQL_PATH=""$(pwd)/init.sql"";;# Check if the init.sql file exists;if [ ! -f ""$INIT_SQL_PATH"" ]; then; echo ""Error: init.sql file not found in the current directory.""; exit 1;fi;;# Install PostgreSQL;apt update;DEBIAN_FRONTEND=noninteractive apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres bash << EOF;;# Create the database ""storedb"";psql -c ""CREATE DATABASE storedb;"";;# Run the init.sql script on the ""storedb"" database;psql -d storedb -f ""$INIT_SQL_PATH"";;# Create the user ""public_view"" with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Create the schema ""common_data"" if it doesn't exist;psql -d storedb -c ""CREATE SCHEMA IF NOT EXISTS common_data;"";;# Grant read-only access to the ""common_data"" schema;psql -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",389,"4207.209825515747","0","0.1","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2," WARNING: apt does not have a stable CLI interface. Use with caution in scripts. W: https://aquasecurity.github.io/trivy-repo/deb/dists/bookworm/InRelease: Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. NOTICE: schema *common_data* already exists, skipping ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","28.799999999999997"
6231,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1045.0496673583984","0.2","0.4","gpt-3.5-turbo","arhīvs ir .7z",2,"tar (child): archive.tar.gz: Cannot open: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","9.8","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
5666,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep ""^USERNAME="" .env | cut -d ""="" -f2-)
echo ""$USERNAME""",27,"1269.089698791504","0.2","0.4","llama3.3-70b",".env datne ar USERNAME un citām vērtībām (vajag tikai USERNAME)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5668,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep ""^USERNAME="" .env | cut -d ""="" -f2-)
echo ""$USERNAME""",27,"1269.089698791504","0.2","0.4","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5672,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",24,"1947.615385055542","0.7","0.9","llama3.3-70b",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
8326,"Experiment 1","FindDate","NL2Bash",3,1,"date -d ""2013-05-01 + 7 - $(date -d ""2013-05-01"" +%u) days"" +%Y-%m-%d",43,"8301.098823547363","0.7","0.9","llama3.3-70b","Jāizdrukā datuma skaitlis",1,"date: invalid date ‘2013-05-01 + 7 - 3 days’ ",False,"The correct date was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print date of first Monday in May, 2013","1.45"
7696,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,1,"ip -4 addr show | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+' | head -n 1 | awk '{print ""IP: "" $1}'",53,"9478.555679321289","0","0.1","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",False,"The correct IP address was not outputted. If there exist any virtual interfaces, only output the physical interface's IP",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","10.94"
5673,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",24,"1947.615385055542","0.7","0.9","llama3.3-70b",". .env datne ar tikai USERNAME, kas satur atstarpi un otra .env datne ar tikai USERNAME apakšdirektorijā",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
5674,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"false",24,"1947.615385055542","0.7","0.9","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,0,1,0,"Line 2: Declare and assign separately to avoid masking return values. ","11.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","1.35"
4949,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git stash
git pull origin develop
git stash pop",17,"1067.7986145019531","0.2","0.4","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,": hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. No stash entries found. ",False,"The repository is not in develop branch after running the script.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.199999999999999"
7003,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update && apt install -y postgresql;;# Change PostgreSQL to listen on port 5433;sed -i ""s/^#*port = .*/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create the storedb database;sudo -u postgres createdb storedb;;# Run init.sql on storedb;sudo -u postgres psql -d storedb -f ""$(pwd)/init.sql"";;# Create user public_view with password 'fox' and grant read-only access;sudo -u postgres psql -d storedb <<EOF;CREATE USER public_view WITH PASSWORD 'fox';;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",2266,"14391.648530960083","1","1","o1-mini","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","20.450000000000003"
6084,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do; case ""$file"" in; *.tar.bz2) tar xjf ""$file"" ;;; *.tar.gz) tar xzf ""$file"" ;;; *.tar.xz) tar xJf ""$file"" ;;; *.bz2) bunzip2 ""$file"" ;;; *.rar) unrar x ""$file"" ;;; *.gz) gunzip ""$file"" ;;; *.tar) tar xf ""$file"" ;;; *.tbz2) tar xjf ""$file"" ;;; *.tgz) tar xzf ""$file"" ;;; *.zip) unzip ""$file"" ;;; *.Z) uncompress ""$file"";;; *.7z) 7z x ""$file"" ;;; *.xz) unxz ""$file"" ;;; *)  echo ""Cannot extract '$file'"" ;;; esac;done",212,"5333.782434463501","0","0.1","gpt-4o","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","50.300000000000004"
7005,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/13/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/13/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",322,"6968.606233596802","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/13/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0_0.1.sh: line 14: /etc/postgresql/13/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
6235,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"954.1122913360596","0.7","0.9","gpt-3.5-turbo","arhīvs ir .bz2",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
7216,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",1064,"9295.913934707642","1","1","o1-mini","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
7220,"Experiment 1","VerifyFile","IaC",1,2,"# Fetch the key again gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Assuming you have the key in a file named key.asc gpg --import key.asc # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Try a different keyserver gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi",360,"8357.962608337402","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","28.999999999999996"
7742,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"strace -f -e execve ./exec.sh 2>&1 | grep -o '""[^""]*\.sh""' | tr -d '""' | sort -u",3709,"577695.6238746643","0.2","0.4","deepseek-r1","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","10.7"
8380,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 ls -l ""$file""
 fi
done
find . -maxdepth 1 -type f -perm -u=r -exec ls -l {} +",169,"12248.180150985718","0.2","0.4","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","20.199999999999996"
8438,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"7469.672203063965","0.7","0.9","deepseek-v3","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7223,"Experiment 1","VerifyFile","IaC",1,2,"# Fetch the key again gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Assuming you have the key in a file named key.asc gpg --import key.asc # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi # Try a different keyserver gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 # Verify the signature if gpg --verify data.tgz.asc data.tgz 2>/dev/null; then echo *OK* else echo *FAIL* fi",360,"7936.457872390747","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data gpg: can't open 'key.asc': No such file or directory gpg: Total number processed: 0 gpg: keyserver receive failed: No data ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","28.999999999999996"
7225,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCED917721F63BD38B4796 gpg --verify data.tgz.asc data.tgz && echo *OK* || echo *FAIL*",72,"2567.0931339263916","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: keyserver receive failed: No data gpg: Signature made Wed 26 Mar 2025 03:36:09 PM PDT gpg:  using RSA key 0F06FF86BEEAF4E71866EE5232EE5355A6BC6E42 gpg: Can't check signature: No public key ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","13.649999999999999"
6183,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1958.5239887237549","0","0.1","deepseek-v3","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5039,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8383,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -f ""$file"" ] && [ -r ""$file"" ]; then
 ls -l ""$file""
 fi
done",144,"14121.92440032959","0.7","0.9","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","18.299999999999997"
7008,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Modify PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all all 0.0.0.0/0 md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",390,"8823.762655258179","0","0.1","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
7229,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Retrieve the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796

# Verify the signature
if gpg --verify data.tgz.asc data.tgz &> /dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",96,"1961.4758491516113","0","0.1","llama3.3-70b","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: *EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796* not a key ID: skipping ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.95"
8394,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep ""^-r""",14,"1050.1229763031006","0.7","0.9","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.7"
8395,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",33,"1163.9325618743896","0.7","0.9","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","9.799999999999999"
7235,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796 && 
gpg --verify data.tgz.asc data.tgz && echo ""OK"" || echo ""FAIL""",65,"3672.297477722168","0.7","0.9","llama3.3-70b","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: *EB4C1BFD4F04F6DDDCCEC917721F63BD38B4796* not a key ID: skipping ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.650000000000002"
8396,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do
 if [ -r ""$file"" ]; then
 echo ""$file""
 fi
done",33,"1163.9325618743896","0.7","0.9","gpt-3.5-turbo","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","9.799999999999999"
4962,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git checkout develop
git fetch origin develop
git merge -X ours origin/develop",23,"1841.1140441894531","0.7","0.9","gpt-4o","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 2bd49a4..cbe9b7b develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7237,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys ""EB4C 1BFD 4F04 2F6D DDCC EC91 7721 F63B D38B 4796"" && 
gpg --verify data.tgz.asc data.tgz > /dev/null 2>&1 && echo ""OK"" || echo ""FAIL""",84,"1750.3974437713623","0.7","0.9","llama3.3-70b","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","20.750000000000004"
6312,"Experiment 1","SearchFilesBySize","NL2Bash",1,2,"find /usr/lib -type f -size +3k -size -9k -exec ls -l {} +",29,"1166.0032272338867","0","0.1","gpt-3.5-turbo","Direktorijā datne, kas atbilst un kas 2 neatbilst (mazāka un lielāka).",1,"",False,"A file of size 4kb was not found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Search for all the files in the  /usr/library directory which have size greater than 3KB (approx) and less than 9KB(approx).","1.9000000000000001"
8349,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"find . -maxdepth 1 -type f -perm -400 -exec ls -l {} \;",27,"2183.0406188964844","0.2","0.4","gpt-4o","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
5428,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",65,"1846.451997756958","0","0.1","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","30.949999999999996"
8369,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"1348.724126815796","0.2","0.4","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
8499,"Experiment 1","SetSGID","NL2Bash",3,1,"#!/bin/bash
if [ -d ""$1/.sn"" ]; then
 find ""$1/.sn"" -type d -exec chmod g+s {} \;
fi",149,"11378.690242767334","0.2","0.4","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","6.15"
8510,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"957.6952457427979","0","0.1","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
7243,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1

if gpg --verify data.tgz.asc data.tgz >/dev/null 2>&1; then
 echo ""OK""
else
 echo ""FAIL""
fi",1648,"84885.16092300415","0.2","0.4","deepseek-r1","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.85"
7242,"Experiment 1","VerifyFile","IaC",1,2,"#!/bin/bash
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 >/dev/null 2>&1
if gpg --trust-model always --verify data.tgz.asc data.tgz 2>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi",967,"60011.48819923401","0","0.1","deepseek-r1","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","9.9"
6203,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",10,"1864.5775318145752","0.7","0.9","deepseek-v3","arhīvs ir .gz",1,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
5128,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
5014,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
4972,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"#!/bin/bash
git checkout develop
git pull origin develop --no-rebase --strategy=recursive --strategy-option=ours",875,"5251.199007034302","1","1","o1-mini","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.0","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3"
8436,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"7070.435285568237","0.2","0.4","deepseek-v3","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7013,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Configure PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/12/main/postgresql.conf # Allow connections on the new port echo *host all  all  127.0.0.1/32  md5* >> /etc/postgresql/12/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",329,"7073.296308517456","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"e dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: sed: can't read /etc/postgresql/12/main/postgresql.conf: No such file or directory /media/sf_scripts/SetupPostgres_qwen_qwen2.5-coder-32b-instruct_0.7_0.9.sh: line 14: /etc/postgresql/12/main/pg_hba.conf: No such file or directory ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
5129,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"1464.8759365081787","0","0.1","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
4954,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1305.5994510650635","0.7","0.9","gpt-4o","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5727,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo $USERNAME",14,"1648.5297679901123","0.7","0.9","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",False,"",0,2,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
7015,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Configure PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all  all  127.0.0.1/32  md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",398,"8619.599103927612","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
6055,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*$/! s/^/#/' settings.env",115,"10984.790563583374","0.7","0.9","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5729,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,1,"source .env
echo $USERNAME",14,"1648.5297679901123","0.7","0.9","deepseek-v3",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",False,"",0,2,0,0,"Line 2: Not following: .env was not specified as input (see shellcheck -x). Line 3: Double quote to prevent globbing and word splitting. ","6.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.7"
5732,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"false",143,"12588.644742965698","0.7","0.9","deepseek-v3",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","13.450000000000001"
8552,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Define the path to the settings.ini file;INI_FILE=""settings.ini"";;# Read the ini file and export variables;while IFS='=' read -r key value; do; # Skip lines that are comments or empty; [[ ""$key"" =~ ^\s*# ]] || [[ -z ""$key"" ]] && continue; # Trim whitespace and export the variable; key=$(echo ""$key"" | xargs); value=$(echo ""$value"" | xargs); export ""$key""=""$value"";done < <(grep -v '^\[' ""$INI_FILE"")",134,"1960.1404666900635","0.2","0.4","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
7845,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

set -e

source=""$1""
dest=""$2""
shift 2

# Validate directories
if [ ! -d ""$source"" ] || [ ! -d ""$dest"" ]; then
 echo ""Error: Source and destination must be directories"" >&2
 exit 1
fi

# Parse flags
swap_mode=0
delete_source=0
delete_dest=0
overwrite=""replace""

for flag in ""$@""; do
 case ""$flag"" in
 --sw) swap_mode=1 ;;
 --sd) delete_source=1 ;;
 --dd) delete_dest=1 ;;
 --dk) overwrite=""keep"" ;;
 --dr) overwrite=""replace"" ;;
 --sc) : ;; # Now handled through delete_source=0
 *) echo ""Unknown flag: $flag"" >&2; exit 1 ;;
 esac
done

# Handle swap mode
if [ $swap_mode -eq 1 ]; then
 tmp=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source""/* ""$tmp""/
 mv -- ""$dest""/* ""$source""/
 mv -- ""$tmp""/* ""$dest""/
 rmdir ""$tmp""
 shopt -u dotglob
 exit 0
fi

# Clean destination if requested
if [ $delete_dest -eq 1 ]; then
 shopt -s dotglob
 rm -rf -- ""${dest:?}""/*
 shopt -u dotglob
fi

# Determine copy/move action and flags
if [ $delete_source -eq 1 ]; then
 cmd=(mv)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
else
 cmd=(cp -a)
 case $overwrite in
 keep) overwrite_flags=(-n) ;;
 *) overwrite_flags=(-f) ;;
 esac
fi

# Execute the operation
shopt -s dotglob
if [ ""${cmd[0]}"" = ""cp"" ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/. ""$dest/""
else
 files=(""$source""/*)
 if [ ${#files[@]} -gt 0 ]; then
 ""${cmd[@]}"" ""${overwrite_flags[@]}"" -- ""$source""/* ""$dest/""
 fi
fi
shopt -u dotglob",4747,"217783.73837471008","0.7","0.9","deepseek-r1","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"Error: Source and destination must be directories ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
8413,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"head -n -5 data.md > temp.md && mv temp.md data.md",22,"872.4374771118164","0.7","0.9","gpt-4o","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7253,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>/dev/null | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1364.9959564208984","0","0.1","gpt-3.5-turbo","Datne ir pareiza",1,"gpg: directory '/root/.gnupg' created gpg: keybox '/root/.gnupg/pubring.kbx' created gpg: key 7721F63BD38B4796: 2 duplicate signatures removed gpg: /root/.gnupg/trustdb.gpg: trustdb created gpg: key 7721F63BD38B4796: public key *Google Inc. (Linux Packages Signing Authority) <linux-packages-keymaster@google.com>* imported gpg: Total number processed: 1 gpg:   imported: 1 ",False,"The file was valid but OK was not outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
7016,"Experiment 1","SetupPostgres","IaC",2,2,"#!/bin/bash # Install PostgreSQL apt update apt install -y postgresql postgresql-contrib # Stop PostgreSQL service systemctl stop postgresql # Configure PostgreSQL to listen on port 5433 sed -i *s/#port = 5432/port = 5433/* /etc/postgresql/15/main/postgresql.conf # Allow connections on the new port echo *host all  all  127.0.0.1/32  md5* >> /etc/postgresql/15/main/pg_hba.conf # Start PostgreSQL service systemctl start postgresql # Create database storedb sudo -u postgres psql -c *CREATE DATABASE storedb;* # Run init.sql on storedb sudo -u postgres psql -d storedb -f ./init.sql # Create user public_view with password 'fox' sudo -u postgres psql -c *CREATE USER public_view WITH PASSWORD 'fox';* # Grant read-only access to schema common_data for user public_view sudo -u postgres psql -d storedb -c *GRANT USAGE ON SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;* sudo -u postgres psql -d storedb -c *ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;* # Reload PostgreSQL to apply changes systemctl reload postgresql",398,"8619.599103927612","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"/trusted.gpg), see the DEPRECATION section in apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.599999999999998"
6425,"Experiment 1","FindMeanValue","Ikdienas uzdevumu automatizācija",3,1,"awk -F, 'NR>1 {sum+=$2; count++} END {print *Mean:*, sum/count}' products.csv",33,"1649.4312286376953","0","0.1","qwen/qwen2.5-coder-32b-instruct","products.csv ar vairākiem produktiem, kur ir skaitliskas cenas",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find the mean value of column price in products.csv (USA/UK format) contained in the current directory. Output it in the format ""Mean: <value>"".","2.5300000000000002"
6147,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) tar -xvf ""$file"" ;;
 *.bz2) tar -xvf ""$file"" ;;
 *.xz) tar -xvf ""$file"" ;;
 *.lzma) tar --lzma -xvf ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xvf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",124,"7123.215198516846","0.2","0.4","llama3.3-70b","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.15"
7820,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash
set -eo pipefail

source_dir=""$1""
dest_dir=""$2""
shift 2
flags=(""$@"")

swap_directories() {
 local temp_dir
 temp_dir=$(mktemp -d)
 shopt -s dotglob
 mv -- ""$source_dir""/* ""$temp_dir/"" 2>/dev/null || true
 mv -- ""$dest_dir""/* ""$source_dir/"" 2>/dev/null || true
 mv -- ""$temp_dir""/* ""$dest_dir/"" 2>/dev/null || true
 shopt -u dotglob
 rmdir ""$temp_dir"" 2>/dev/null || true
}

contains_flag() {
 local flag=""$1""
 for f in ""${flags[@]}""; do
 [[ ""$f"" == ""$flag"" ]] && return 0
 done
 return 1
}

handle_sw() {
 if contains_flag ""--sw""; then
 swap_directories
 exit 0
 fi
}

handle_dd() {
 if contains_flag ""--dd""; then
 find ""$dest_dir"" -mindepth 1 -delete 2>/dev/null || true
 fi
}

setup_rsync_opts() {
 rsync_opts=(-a)
 if contains_flag ""--dk""; then
 rsync_opts+=(--ignore-existing)
 fi
}

handle_normal_operation() {
 setup_rsync_opts
 
 if contains_flag ""--sd""; then
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 find ""$source_dir"" -mindepth 1 -delete 2>/dev/null || true
 else
 rsync ""${rsync_opts[@]}"" --progress -- ""$source_dir""/ ""$dest_dir/""
 fi
}

main() {
 handle_sw
 handle_dd
 handle_normal_operation
}

main",4423,"198785.76159477234","0","0.1","deepseek-r1","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"rsync: [sender] change_dir */--sc* failed: No such file or directory (2) rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1338) [sender=3.2.7] ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order “source”, “destination” directories. Move all contents from “source” to “destination”. By default copy from “source” to “destination” replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows: “--sc” - copy from source “--sd” - delete from source “--dr” - replace same name in destination “--dk” - keep same name in destination “--dd” - delete all existing in destination “--sw” - swap contents of directories","-1"
5052,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git checkout develop
git pull -X ours origin develop",575,"9533.930778503418","0","0.1","deepseek-r1","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 89d2cbb..b75d1eb develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
8464,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"954.3204307556152","0.7","0.9","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
5983,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1344.9342250823975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.25","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
6644,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1345.1287746429443","0.7","0.9","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
6633,"Experiment 1","CountLoggedInUsers","NL2Bash",2,1,"who | wc -l",11,"2266.2038803100586","0","0.1","llama3.3-70b","1 lietotājs ar tty1 savienojumu (virtuālās mašīnas sesija) un ssh (lai izpildītu skriptu)",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Count number of users logged in","3.6500000000000004"
6252,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep *result.log$* | wc -l",25,"1544.6934700012207","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6253,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl *FAIL* /usr/results/ | grep *result.log$* | wc -l",25,"1544.6934700012207","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",False,"",1,0,0,0,"Line 2: Consider using 'grep -c' instead of 'grep|wc -l'. ","12.5","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6254,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rl *FAIL* /usr/results/ | grep -c *result.log$*",23,"1445.4050064086914","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
6636,"Experiment 1","CountLoggedInUsers","NL2Bash",2,2,"users | wc -w",11,"1547.6667881011963","0","0.1","llama3.3-70b","2 dažādi lietotāji (ieskaitot skripta izpildītāju), vienam ir tikai ssh sesija",3,"",False,"The number of logged in users was not correctly counted. Some users are using SSH.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","NO_RISK","Count number of users logged in","3.6500000000000004"
7702,"Experiment 1","FindIPAddress","Sistēmas informācijas izgūšana",1,2,"ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | awk '{print ""IP: "" $1}';ip -4 addr | awk '/inet/ && !/127.0.0.1/ {split($2, a, ""/""); print ""IP: "" a[1]; exit}'",164,"11884.686470031738","0.2","0.4","deepseek-v3","Viens fizisks interfeiss + loopback + virtuāls docker0 interfeiss",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print the local network ipv4 address of this computer (it has only one physical network interface) in a single line in the format “IP: {address}”.","15.68"
8768,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '10' < /dev/urandom | fold -w 75 | head -n 1",30,"1376.4910697937012","0.7","0.9","llama3.3-70b","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
5947,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"948.6925601959229","0.7","0.9","gpt-4o","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8191,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; mkdir -p ""$target_dir""; mv -- ""$found_file"" ""$docx_file"" ""$target_dir/""; fi;done",3092,"114909.73544120789","0","0.1","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","38.25"
8759,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '01' </dev/urandom | head -c75 && echo",484,"4366.878986358643","1","1","o1-mini","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","10.1"
6255,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rl *FAIL* /usr/results/ | grep -c *result.log$*",23,"1445.4050064086914","0","0.1","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
8437,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"7469.672203063965","0.7","0.9","deepseek-v3","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
8416,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > temp && mv temp data.md",352,"3862.2777462005615","1","1","o1-mini","data.md ar 4 rindām",3,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7153,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",39,"1389.8630142211914","0.2","0.4","gpt-3.5-turbo","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7751,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter for script names;pstree -p ""$exec_pid"" | grep -oP '\(\d+\) \K[^ ]+' | while IFS= read -r pid; do; # Check if the process is a script; script_name=$(ps -p ""$pid"" -o args= | grep -oP '.*\.sh'); if [ -n ""$script_name"" ]; then; echo ""$script_name""; fi;done",135,"1866.8162822723389","0","0.1","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","27.2"
7752,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter for script names;pstree -p ""$exec_pid"" | grep -oP '\(\d+\) \K[^ ]+' | while IFS= read -r pid; do; # Check if the process is a script; script_name=$(ps -p ""$pid"" -o args= | grep -oP '.*\.sh'); if [ -n ""$script_name"" ]; then; echo ""$script_name""; fi;done",135,"1866.8162822723389","0","0.1","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","27.2"
7773,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I{} ps -o cmd= -p {} | awk '{print $1}'",123,"3664.9727821350098","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7755,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter out the script names;pstree -p ""$exec_pid"" | grep -oP '\(\d+\) \K[^ ]+' | grep -v '^('",74,"1754.0457248687744","0.2","0.4","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","9.500000000000002"
7756,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter out the script names;pstree -p ""$exec_pid"" | grep -oP '\(\d+\) \K[^ ]+' | grep -v '^('",74,"1754.0457248687744","0.2","0.4","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","9.500000000000002"
7749,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Get the process ID of exec.sh;exec_pid=$(pgrep -f exec.sh);;# Use pstree to list all child processes and filter for script names;pstree -p $exec_pid | grep -oP '\(\d+\) \K[^ ]+' | while read pid; do; # Check if the process is a script; script_name=$(ps -p $pid -o args= | grep -oP '.*\.sh'); if [ -n ""$script_name"" ]; then; echo ""$script_name""; fi;done",128,"3857.652187347412","0","0.1","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,2,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 7: read without -r will mangle backslashes. Line 9: Double quote to prevent globbing and word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","27.2"
7154,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",39,"1389.8630142211914","0.2","0.4","gpt-3.5-turbo","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7759,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Enable extended globbing;shopt -s extglob;;# Get the PID of exec.sh;exec_pid=$(pgrep -f ""^/bin/bash ./exec.sh$"");;# Use pstree to list all child processes of exec.sh and filter out script names;if [ -n ""$exec_pid"" ]; then; pstree -p $exec_pid | grep -oP '(?<=\().*?(?=\))' | while IFS= read -r pid; do; # Check if the process is a script; cmd=$(ps -o args= -p ""$pid""); if [[ $cmd == */bin/bash* ]]; then; script_name=$(basename ""$(echo ""$cmd"" | awk '{print $2}')""); echo ""$script_name""; fi; done | sort -u;fi",183,"2559.699773788452","0.7","0.9","gpt-4o","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7769,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I {} basename $(readlink -f /proc/{}/exe)",119,"3160.9086990356445","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"ormation. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. basename: missing operand Try 'basename --help' for more information. ",False,"All child processes weren't listed",0,1,1,0,"Line 13: Double quote to prevent globbing and word splitting. Line 13: Quote this to prevent word splitting. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7768,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | while read -r PID; do  if [ -f */proc/$PID/exe* ]; then basename *$(readlink -f */proc/$PID/exe*)*  fi done",146,"3574.3801593780518","0","0.1","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7774,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I{} ps -o cmd= -p {} | awk '{print $1}'",123,"3664.9727821350098","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7139,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create the directory on the host if it doesn't exist;mkdir -p /usr/alpinedata;;# Run the Alpine container with the volume mount;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",68,"7284.186840057373","0","0.1","deepseek-v3","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
7098,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash;systemctl stop postgresql;apt update && apt install -y postgresql-17;# Remove automatically created new cluster if exists;if pg_lsclusters | grep -q '^17[[:space:]]*main'; then; pg_dropcluster 17 main --stop;fi;pg_upgradecluster -v 17 16 main;systemctl start postgresql@17-main;pg_dropcluster 16 main --stop",1468,"75405.40480613708","0.7","0.9","deepseek-r1","Jāinstalē postgres 17",2,"",True,"",0,0,0,0,"","13.0","","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","20.7"
6259,"Experiment 1","CountFailFiles","NL2Bash",1,2,"grep -rlZ *FAIL* /usr/results/ | grep -z *result.log$* | tr '\0' '\n' | grep -c *result.log$*",40,"1746.7904090881348","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Datne result.log ar ‘FAIL’ apakšdirektorijā (kuras nosaukums ir result.log). Direktorijā 1 cita datne, kas arī satur ‘FAIL’.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","-1"
7775,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I{} ps -o cmd= -p {} | awk '{print $1}' | xargs -I{} basename *{}*",132,"3377.016544342041","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
7776,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash # Get the PID of exec.sh EXEC_PID=$(pgrep -f exec.sh) # Check if exec.sh is running if [ -z *$EXEC_PID* ]; then  echo *exec.sh is not running.*  exit 1 fi # Use pstree to list all child processes of exec.sh pstree -p $EXEC_PID | grep -oP '\(\K[^\)]+' | grep -v *^$EXEC_PID$* | xargs -I{} ps -o cmd= -p {} | awk '{print $1}' | xargs -I{} basename *{}*",132,"3377.016544342041","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus, sākotnējo skriptu izsauc no Bash procesa (meklējot skripta PID ar `pgrep -f`, atgriezīs arī Bash programmas PID)",3,"",False,"All child processes weren't listed",0,1,0,0,"Line 13: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
6937,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
4933,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b549a7d..e0fc63a develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8911,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",38,"1151.1263847351074","0","0.1","gpt-3.5-turbo","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
6940,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=$1
dest_dir=$2

if [ ""$#"" -ne 2 ]; then
 echo ""Usage: $0 source_dir dest_dir""
 exit 1
fi

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ur ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -ur ""$source_dir""/* ""$dest_dir""
fi",352,"6664.550065994263","0.2","0.4","gpt-3.5-turbo","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 25: Use *${var:?}* to ensure this never expands to /* . ","4.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","142.95000000000002"
8900,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"2356.656789779663","0.2","0.4","llama3.3-70b","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
5029,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1306.3604831695557","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 1203e02..0fd4f48 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
7151,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",55,"1165.3084754943848","0.2","0.4","gpt-3.5-turbo","Docker ir iedarbināts",1,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
7156,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine docker container with the volume mounted
docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",56,"1159.7566604614258","0.7","0.9","gpt-3.5-turbo","Docker nav iedarbināts",3,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
6100,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find the archive file with the name pattern archive.*
file=$(ls archive.* 2>/dev/null | head -n 1)

if [ -z ""$file"" ]; then
 echo ""No archive file named archive.* found in the current directory.""
 exit 1
fi

case ""$file"" in
 *.tar.gz|*.tgz)
 tar -xzf ""$file""
 ;;
 *.tar.bz2|*.tbz2)
 tar -xjf ""$file""
 ;;
 *.tar.xz|*.txz)
 tar -xJf ""$file""
 ;;
 *.zip)
 unzip ""$file""
 ;;
 *.7z)
 7z x ""$file""
 ;;
 *.gz)
 gunzip ""$file""
 ;;
 *.bz2)
 bunzip2 ""$file""
 ;;
 *.xz)
 unxz ""$file""
 ;;
 *)
 echo ""Unsupported archive format: $file""
 exit 1
 ;;
esac",1003,"5970.0939655303955","1","1","o1-mini","arhīvs ir .bz2",2,"",False,"",0,1,0,0,"Line 4: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
5035,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"6085.596799850464","0.2","0.4","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b549a7d..e0fc63a develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8053,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.414810180664","0.2","0.4","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
5037,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8415,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > temp && mv temp data.md",352,"3862.2777462005615","1","1","o1-mini","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
7801,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P $pid);;# List the names of all child scripts launched by exec.sh script or its child processes;for child_pid in $children; do; cmdline=$(tr -d '\0' < /proc/$child_pid/cmdline); echo ""Child script name: $cmdline"";done",108,"1654.1774272918701","0","0.1","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All indirect child processes weren't listed",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. Line 11: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","8.25"
7803,"Experiment 1","FindChildScripts","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;;# Find the process ID of the exec.sh script;pid=$(pgrep -f ""exec.sh"");;# Find all child processes of the exec.sh script;children=$(pgrep -P ""$pid"");;# List the names of all child scripts launched by exec.sh script or its child processes;while IFS= read -r child_pid; do; cmdline=$(tr -d '\0' < ""/proc/$child_pid/cmdline""); echo ""Child script name: $cmdline"";done <<< ""$children""",114,"2070.685386657715","0","0.1","gpt-3.5-turbo","Ir izsaukti vairāki skripti, kas arī izsauc citus skriptus",1,"",False,"All indirect child processes weren't listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","List the names of all child scripts launched by exec.sh script or it’s child processes","-1"
6930,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
7023,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql postgresql-contrib;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change authentication method to md5 for postgres user;echo ""host all postgres 127.0.0.1/32 md5"" >> /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database ""storedb"";psql -U postgres -h localhost -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -h localhost -p 5433 -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -h localhost -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -h localhost -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",365,"3710.3683948516846","0.2","0.4","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"ting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? psql: error: connection to server at *localhost* (::1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? connection to server at *localhost* (127.0.0.1), port 5433 failed: Connection refused 	Is the server running on that host and accepting TCP/IP connections? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","19.250000000000004"
6101,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Find the archive file with the name pattern archive.*
file=$(ls archive.* 2>/dev/null | head -n 1)

if [ -z ""$file"" ]; then
 echo ""No archive file named archive.* found in the current directory.""
 exit 1
fi

case ""$file"" in
 *.tar.gz|*.tgz)
 tar -xzf ""$file""
 ;;
 *.tar.bz2|*.tbz2)
 tar -xjf ""$file""
 ;;
 *.tar.xz|*.txz)
 tar -xJf ""$file""
 ;;
 *.zip)
 unzip ""$file""
 ;;
 *.7z)
 7z x ""$file""
 ;;
 *.gz)
 gunzip ""$file""
 ;;
 *.bz2)
 bunzip2 ""$file""
 ;;
 *.xz)
 unxz ""$file""
 ;;
 *)
 echo ""Unsupported archive format: $file""
 exit 1
 ;;
esac",1003,"5970.0939655303955","1","1","o1-mini","arhīvs ir .7z",2,"",False,"",0,1,0,0,"Line 4: Use find instead of ls to better handle non-alphanumeric filenames. ","12.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
8755,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"for ((i=0; i<75; i++)); do echo -n $((RANDOM%2)); done; echo",2478,"112783.54024887085","0.7","0.9","deepseek-r1","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","-1"
5341,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d -w 32 | cut -c 1-32",43,"1377.6211738586426","0.2","0.4","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.9"
6944,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Source or destination directory does not exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"2971.2202548980713","0.2","0.4","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
5038,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Repozitorijos izmaiņas nerada konfliktus, bet lokālā repozitorija atrodas zarā “main” nevis “develop”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
6106,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"#!/bin/bash;;# Find the first archive file matching archive.* in the current directory;file=$(find . -maxdepth 1 -type f -name 'archive.*' -print -quit);;if [ -z ""$file"" ]; then; echo ""No archive file named archive.* found in the current directory.""; exit 1;fi;;case ""$file"" in; *.tar.gz|*.tgz); tar -xzf ""$file"";;; *.tar.bz2|*.tbz2); tar -xjf ""$file"";;; *.tar.xz|*.txz); tar -xJf ""$file"";;; *.zip); unzip ""$file"";;; *.7z); 7z x ""$file"";;; *.gz); gunzip ""$file"";;; *.bz2); bunzip2 ""$file"";;; *.xz); unxz ""$file"";;; *); echo ""Unsupported archive format: $file""; exit 1;;;esac",692,"5174.609184265137","1","1","o1-mini","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","34.150000000000006"
8770,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"tr -dc '01' < /dev/urandom | head -c 75; echo",93,"9501.210451126099","0","0.1","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8777,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"#!/bin/bash;;tr -dc '01' < /dev/urandom | head -c 75; echo",30,"949.613094329834","0.2","0.4","gpt-3.5-turbo","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8779,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"tr -dc '01' < /dev/urandom | fold -w 75 | head -n 1",30,"971.9481468200684","0.7","0.9","gpt-3.5-turbo","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
8757,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '01' < /dev/urandom | head -c 75; echo",26,"1254.903793334961","0.2","0.4","gpt-4o","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","6.1499999999999995"
8767,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"tr -dc '10' < /dev/urandom | fold -w 75 | head -n 1",30,"1164.5076274871826","0.2","0.4","llama3.3-70b","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
6948,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
8212,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" | while read -r file; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",86,"1992.5997257232666","0","0.1","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
5040,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 5e023d1..17ebedc develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7157,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Check the container ID;CONTAINER_ID=$(docker ps -aqf ""name=alpine-linux-container"");;# Stop and remove the container;docker stop $CONTAINER_ID;docker rm $CONTAINER_ID;;# Create the volume on the host if it doesn't exist;if [ ! -d ""/usr/alpinedata"" ]; then; mkdir /usr/alpinedata;fi;;# Run the Alpine docker container with the volume mounted;docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",123,"1796.9880104064941","0.7","0.9","gpt-3.5-turbo","Docker ir iedarbināts",1," more information docker: 'docker rm' requires at least 1 argument Usage: docker rm [OPTIONS] CONTAINER [CONTAINER...] See 'docker rm --help' for more information Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,1,0,0,"Line 6: Double quote to prevent globbing and word splitting. Line 7: Double quote to prevent globbing and word splitting. ","7.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.6"
6949,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
7147,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine container with the volume mounted
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",55,"1155.7722091674805","0","0.1","gpt-3.5-turbo","Docker ir iedarbināts",1,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
7150,"Experiment 1","SetupAlpineContainer","IaC",2,2,"# Since the directory already exists, we can skip creating it and try running the container again
docker run -d -v /usr/alpinedata:/imported --name alpine-linux-container alpine",48,"1606.7397594451904","0","0.1","gpt-3.5-turbo","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7099,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"1028.4082889556885","0","0.1","gpt-4o","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7892,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;output="""";found=false;;for iface in /sys/class/net/*; do; iface=$(basename ""$iface""); if [[ ""$iface"" != ""lo"" ]]; then; ip=$(ip -4 addr show ""$iface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); if [[ $ip != ""None"" ]]; then; output+=""$iface - $ip""$'\n'; found=true; fi; fi;done;;if ! $found; then; echo ""No virtual interfaces found"";else; echo ""$output"";fi",141,"2376.495122909546","0","0.1","gpt-4o","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
6950,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""

# Check if source and destination directories are provided
if [ -z ""$source_dir"" ] || [ -z ""$dest_dir"" ]; then
 echo ""Usage: $0 <source_directory> <destination_directory>""
 exit 1
fi

# Move all contents from source to destination based on flags
if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 yes | cp -rf ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/* ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$tmp_dir""
 mv ""$dest_dir""/* ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -f ""$source_dir""/* ""$dest_dir""
fi",275,"3153.380870819092","0.7","0.9","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 16: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","146.4"
8251,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -name ""*.docx.found"" -exec mv {} /etc/movedDocs \;
find /etc/docs -name ""*.docx"" -exec mv {} /etc/movedDocs \;",58,"1880.9778690338135","0","0.1","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.8"
5017,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 1203e02..0fd4f48 develop -> origin/develop ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","8.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
7562,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat | tail -n 1 | awk '{print $NF}') echo *exit code: $exit_code*",38,"9299.698829650879","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
4772,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,1,"#!/bin/bash # Find all JSON files in the current directory json_files=$(find . -maxdepth 1 -type f -name **.json*) # Initialize an array to hold user names users=() # Loop through each JSON file for file in $json_files; do # Extract user values and add them to the users array jq -r '.user' *$file* 2>/dev/null | while read -r user; do  users+=(*$user*) done done # Check if we found any users if [ ${#users[@]} -eq 0 ]; then echo *No users found* else # Sort the users array and format the output sorted_users=$(printf *%s\n* *${users[@]}* | sort | tr '\n' ', ') # Remove the trailing comma and space sorted_users=${sorted_users%, } echo *Here are the users: $sorted_users* fi",207,"3691.3065910339355","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viena datne ar vienu korektu json, kur 3 lietotāji",1,"",False,"A user was not found!",0,2,0,0,"Line 13: Modification of users is local (to subshell caused by pipeline). Line 18: users was modified in a subshell. That change might be lost. Line 22: users was modified in a subshell. That change might be lost. ","4.0","CONDITION_NOT_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","-1"
6929,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
6932,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
5012,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git merge -X ours origin/develop",19,"1706.8727016448975","0","0.1","llama3.3-70b","Nav konfliktu",1,"",True,"",0,0,0,0,"","8.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","2.95"
5021,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7055,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash # Stop the current PostgreSQL 16 service systemctl stop postgresql # Install PostgreSQL 17 apt update apt install -y postgresql-17 # Create a new cluster for PostgreSQL 17 pg_createcluster 17 main --start # Upgrade the existing cluster from 16 to 17 pg_upgradecluster 16 main # Drop the old PostgreSQL 16 cluster pg_dropcluster 16 main --stop # Restart the PostgreSQL 17 service systemctl restart postgresql # Verify the upgrade psql -c *SELECT version();*",136,"4787.824869155884","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: FATAL: role *root* does not exist ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","11.3"
6933,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""${1:?}""
dest_dir=""${2:?}""

if [ ! -d ""$source_dir"" ] || [ ! -d ""$dest_dir"" ]; then
 echo ""Both source and destination directories must exist.""
 exit 1
fi

if [ ""$3"" == ""--sc"" ]; then
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sd"" ]; then
 mv ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dr"" ]; then
 cp -ru ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dk"" ]; then
 cp -n ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--dd"" ]; then
 rm -rf ""$dest_dir""/*
 cp -r ""$source_dir""/. ""$dest_dir""
elif [ ""$3"" == ""--sw"" ]; then
 tmp_dir=$(mktemp -d)
 mv ""$source_dir""/. ""$tmp_dir""
 mv ""$dest_dir""/. ""$source_dir""
 mv ""$tmp_dir""/* ""$dest_dir""
 rmdir ""$tmp_dir""
else
 cp -r ""$source_dir""/. ""$dest_dir""
fi",271,"3497.6892471313477","0","0.1","gpt-3.5-turbo","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,1,0,"Line 20: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","141.20000000000002"
7116,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",28,"1459.6214294433594","0","0.1","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
7118,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker ps -a docker start alpine-linux-container docker inspect alpine-linux-container | grep -A 5 Mounts docker rm -f alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",176,"4396.16584777832","0","0.1","qwen/qwen2.5-coder-32b-instruct","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","11.9"
5704,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -E '^USERNAME=' .env | sed -e 's/^USERNAME=//' -e 's/^[""'\''""]//' -e 's/[""'\''""]$//');export USERNAME",560,"34961.12394332886","0.7","0.9","deepseek-r1",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
5587,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep -oP '^USERNAME=\K.*' .env);export USERNAME",24,"1450.5157470703125","0","0.1","gpt-4o",".env datne ar tikai USERNAME un otra .env datne ar tikai USERNAME apakšdirektorijā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
6798,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
dest_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_same_name=true
delete_existing_in_dest=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case $1 in
 --sc)
 copy_from_source=true
 ;;
 --sd)
 delete_from_source=true
 ;;
 --dr)
 replace_same_name=true
 ;;
 --dk)
 replace_same_name=false
 ;;
 --dd)
 delete_existing_in_dest=true
 ;;
 --sw)
 swap_contents=true
 ;;
 *)
 echo ""Invalid option: $1""
 exit 1
 ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}""/* ""$temp_dir/""
 mv ""${dest_dir:?}""/* ""$source_dir/""
 mv ""$temp_dir""/* ""$dest_dir/""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_dest; then
 rm -rf ""${dest_dir:?}""/*
 fi

 if $copy_from_source; then
 if $replace_same_name; then
 cp -r ""${source_dir:?}/."" ""${dest_dir:?}/""
 else
 rsync -av --ignore-existing ""${source_dir:?}/"" ""${dest_dir:?}/""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}""/*
 fi
fi",333,"3308.673620223999","0.7","0.9","gpt-4o","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"A subdirectory was not moved to destination (with --sc --dr passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6781,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace=true
delete_destination=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace=true ;;
 --dk) replace=false ;;
 --dd) delete_destination=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""$source_dir""/* ""$temp_dir""
 mv ""$destination_dir""/* ""$source_dir""
 mv ""$temp_dir""/* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_destination; then
 rm -rf ""$destination_dir""/*
 fi

 if $copy; then
 if $replace; then
 cp -r ""$source_dir""/* ""$destination_dir""
 else
 cp -rn ""$source_dir""/* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""$source_dir""/*
 fi
fi",273,"3649.742841720581","0.2","0.4","gpt-4o","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sd/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 46: Use *${var:?}* to ensure this never expands to /* . ","5.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","77.95"
7056,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash # Stop the current PostgreSQL 16 service systemctl stop postgresql # Install PostgreSQL 17 apt update apt install -y postgresql-17 # Remove the automatically created PostgreSQL 17 cluster pg_dropcluster 17 main --stop # Create a new cluster for PostgreSQL 17 pg_createcluster 17 main --start # Upgrade the existing cluster from 16 to 17 pg_upgradecluster 16 main # Drop the old PostgreSQL 16 cluster pg_dropcluster 16 main --stop # Restart the PostgreSQL 17 service systemctl restart postgresql # Verify the upgrade psql -c *SELECT version();*",201,"5234.252452850342","0","0.1","qwen/qwen2.5-coder-32b-instruct","Jāinstalē postgres 17",2,"(TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: specified cluster does not exist Error: target cluster 17/main already exists psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: FATAL: role *root* does not exist ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","12.75"
5022,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD 5e023d1..17ebedc develop -> origin/develop Already on 'develop' error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
7173,"Experiment 1","HostHtml","IaC",1,1,"cat <<EOF > /etc/nginx/sites-available/default server { listen 80 default_server; listen [::]:80 default_server;  root /usr/html; index index.html;  server_name _;  location / {  try_files \$uri \$uri/ =404; } } EOF nginx -s reload",78,"2671.415328979492","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","-1"
7068,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash

# Stop the current PostgreSQL 16 cluster
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install -y postgresql-17

# Create new cluster with same name (main) for PostgreSQL 17
pg_createcluster 17 main --start

# Stop the new cluster to perform the upgrade
systemctl stop postgresql@17-main

# Perform the upgrade using pg_upgradecluster
pg_upgradecluster -v 17 16 main

# Remove the old cluster (after verifying the upgrade worked)
pg_dropcluster 16 main --stop

# Update any configuration files if needed (like pg_hba.conf, postgresql.conf)
# The new cluster will have default configs, you may want to merge your customizations
# from /etc/postgresql/16/main/ to /etc/postgresql/17/main/

# Start the new PostgreSQL 17 cluster
systemctl start postgresql@17-main

# Verify the upgrade was successful
sudo -u postgres psql -c ""SELECT version();""",353,"20035.3524684906","0.2","0.4","deepseek-v3","Jāinstalē postgres 17",2," apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists ",False,"Neither was data migrated to new version of postgres nor was the old database kept.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","12.950000000000001"
8404,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*$//' data.md",51,"1370.1674938201904","0","0.1","gpt-4o","data.md ar 4 rindām",3,"",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.45"
7934,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7935,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip_address=$(ip addr show $interface | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",132,"3679.1903972625732","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 9: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7939,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3880.7995319366455","0","0.1","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7951,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash interfaces=$(ip link show | grep 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip_address=$(ip addr show *$interface* | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1)  if [ -z *$ip_address* ]; then  ip_address=*None*  fi  echo *$interface - $ip_address* done fi",133,"3662.4221801757812","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 8: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
7957,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7958,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in $interfaces; do  ip=$(ip -4 addr show $interface | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",111,"3168.724536895752","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7963,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7964,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7965,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8419,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i -e :a -e '$d;N;2,5ba' -e 'P;D' data.md",33,"1482.0740222930908","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","1.7"
6170,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Enable nullglob to prevent literal interpretation if no files match
shopt -s nullglob

# Find all files matching archive.* pattern
files=(archive.*)

# Check if exactly one file exists
if [[ ${#files[@]} -ne 1 ]]; then
 echo ""Error: Exactly one archive.* file must exist in the current directory"" >&2
 exit 1
fi

filename=""${files[0]}""

# Extract based on file extension
case ""$filename"" in
 *.tar.bz2|*.tbz2) tar xjf ""$filename"" ;;
 *.tar.gz|*.tgz) tar xzf ""$filename"" ;;
 *.tar.xz) tar xJf ""$filename"" ;;
 *.tar) tar xf ""$filename"" ;;
 *.zip) unzip ""$filename"" ;;
 *.gz)  gunzip ""$filename"" ;;
 *.bz2) bunzip2 ""$filename"" ;;
 *.rar) unrar x ""$filename"" ;;
 *.7z)  7z x ""$filename"" ;;
 *)
 echo ""Unsupported archive format: $filename"" >&2
 exit 1
 ;;
esac

echo ""Extracted $filename successfully""",1753,"16222.480058670044","0.2","0.4","deepseek-r1","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
7967,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, otram IPv6",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that an interface is named *inet*?",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
7968,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"interfaces=$(ip -o link show | grep -E 'state UP' | awk -F': ' '{print $2}' | grep -v 'lo') if [ -z *$interfaces* ]; then echo *No virtual interfaces found* else for interface in *$interfaces*; do  ip=$(ip -4 addr show *$interface* | grep -oP '(?<=inet\s)\d+(\.\d+){3}')  echo *${interface} - ${ip:-None}* done fi",112,"3571.4950561523438","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found",0,0,0,1,"Line 6: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8197,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash
mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' found_file; do
 docx_file=""${found_file%.found}""
 mv -f ""$found_file"" /etc/movedDocs/ 2>/dev/null
 mv -f ""$docx_file"" /etc/movedDocs/ 2>/dev/null
done",1395,"53673.779010772705","0.2","0.4","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","20.3"
8840,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"find /usr/src -maxdepth 1 -type f -name '*.java' -exec ln -s -t . {} +",1355,"64490.96369743347","0.2","0.4","deepseek-r1","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","2"
7031,"Experiment 1","SetupPostgres","IaC",2,1,"#!/bin/bash;;# Install PostgreSQL;apt update;apt install -y postgresql postgresql-client;;# Configure PostgreSQL to listen on port 5433;sed -i ""s/^#listen_addresses =.*/listen_addresses = '*'/"" /etc/postgresql/*/main/postgresql.conf;echo ""port = 5433"" >> /etc/postgresql/*/main/postgresql.conf;;# Allow connections from localhost to all databases for postgres user;echo ""host all all 127.0.0.1/32 md5"" >> /etc/postgresql/*/main/pg_hba.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database and run init.sql;sudo -u postgres psql -p 5433 -c ""CREATE DATABASE storedb;"";sudo -u postgres psql -p 5433 -d storedb -f init.sql;;# Create read-only user and grant permissions;sudo -u postgres psql -p 5433 -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";sudo -u postgres psql -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;echo ""PostgreSQL setup complete. Database 'storedb' created, init.sql executed, and read-only user 'public_view' configured.""",384,"21412.23168373108","0.2","0.4","deepseek-v3","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","20.150000000000002"
4854,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"NOT_A_BASH_SCRIPT",2048,"26845.974683761597","0.7","0.9","deepseek-r1","Viena datne, kur ir vairāki json ar lietotājiem abos",2,"",False,"N/A",0,0,0,0,"N/A","0","NO_SCRIPT","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","0.3"
8029,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"#!/bin/bash;;# Get all virtual interfaces (excluding loopback);virtual_interfaces=$(ip -o link show | awk -F': ' '{print $2}' | grep -E '^veth|^docker|^virbr|^br-|^tun|^tap' | grep -v '^lo$');;if [[ -z ""$virtual_interfaces"" ]]; then; echo ""No virtual interfaces found""; exit 0;fi;;# Process each interface;while IFS= read -r interface; do; # Get IPv4 address or set to None; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}' || echo ""None""); echo ""${interface} - ${ipv4}"";done <<< ""$virtual_interfaces""",320,"17922.832250595093","0.7","0.9","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie ar IPv4 adresi",1,"",False,"No virtual interfaces were found but there should be 2",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8013,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;found=0;;for interface in $(ip -o link show | awk -F': ' '{print $2}' | grep -v '^lo$'); do; # Check if it's a virtual interface (either by name or by flags); if [[ ""$interface"" =~ ^(veth|virbr|docker|br-|tun|tap|vnet|vmnet)[a-zA-Z0-9]* ]] || \; [[ $(ip -d link show dev ""$interface"" | grep -c ""link/ether"") -eq 0 ]]; then; ipv4=$(ip -4 addr show dev ""$interface"" | grep -oP '(?<=inet\s)\d+(\.\d+){3}'); if [ -z ""$ipv4"" ]; then; ipv4=""None""; fi; echo ""$interface - $ipv4""; found=1; fi;done;;if [ ""$found"" -eq 0 ]; then; echo ""No virtual interfaces found"";fi",384,"20518.41425895691","0","0.1","deepseek-v3","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese",2,"",False,"No virtual interfaces were found but there should be 1",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","-1"
8042,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,1,"ifaces=$(ip -o -4 addr show | awk '$2 !~ /lo/ {print $2}');if [[ -z $ifaces ]]; then; echo ""No virtual interfaces found"";else; for iface in $ifaces; do; ip=$(ip -o -4 addr show dev $iface | awk '{print $4}'); if [[ -z $ip ]]; then; ip=""None""; fi; echo ""$iface - $ip""; done;fi",110,"1665.2319431304932","0","0.1","gpt-3.5-turbo","Viens fizisks interfeiss un neviens virtuālais",1,"",False,"When there are no virtual interfaces, *No virtual interfaces found* should be outputted",0,1,0,0,"Line 7: Double quote to prevent globbing and word splitting. ","5.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","27.500000000000004"
6805,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash;;# Exit immediately if a command exits with a non-zero status;set -e;;# Function to display usage;usage() {; echo ""Usage: $0 [OPTIONS] source_directory destination_directory""; echo """"; echo ""Options:""; echo "" --sc Copy from source (default operation)""; echo "" --sd Move from source (delete from source after copying)""; echo "" --dr Replace files with the same name in destination (default)""; echo "" --dk Keep existing files in destination (do not overwrite)""; echo "" --dd Delete all existing files in destination before operation""; echo "" --sw Swap contents of source and destination directories""; echo "" -h, --help Display this help message""; exit 1;};;# Parse options using getopt;PARSED_OPTIONS=$(getopt -o h --long sc,sd,dr,dk,dd,sw,help -- ""$@"");if [[ $? -ne 0 ]]; then; usage;fi;;eval set -- ""$PARSED_OPTIONS"";;# Initialize flags;COPY=false;MOVE=false;REPLACE=false;KEEP=false;DELETE_DEST=false;SWAP=false;;# Process options;while true; do; case ""$1"" in; --sc); COPY=true; shift;;; --sd); MOVE=true; shift;;; --dr); REPLACE=true; shift;;; --dk); KEEP=true; shift;;; --dd); DELETE_DEST=true; shift;;; --sw); SWAP=true; shift;;; -h|--help); usage;;; --); shift; break;;; *); echo ""Unknown option: $1""; usage;;; esac;done;;# Check for source and destination directories;if [ ""$SWAP"" = false ]; then; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;else; if [ ""$#"" -ne 2 ]; then; echo ""Error: Source and destination directories are required for swapping.""; usage; fi;; SOURCE=""$1""; DESTINATION=""$2"";; if [ ! -d ""$SOURCE"" ]; then; echo ""Error: Source directory '$SOURCE' does not exist.""; exit 1; fi;; if [ ! -d ""$DESTINATION"" ]; then; echo ""Error: Destination directory '$DESTINATION' does not exist.""; exit 1; fi;fi;;# Perform swap if --sw is specified;if [ ""$SWAP"" = true ]; then; TEMP=""/tmp/swap_temp_$$""; mkdir -p ""$TEMP""; mv ""$SOURCE""/* ""$TEMP/""; mv ""$DESTINATION""/* ""$SOURCE/""; mv ""$TEMP""/* ""$DESTINATION/""; rmdir ""$TEMP""; echo ""Swapped contents of '$SOURCE' and '$DESTINATION'.""; exit 0;fi;;# Determine operation mode;if [ ""$MOVE"" = true ]; then; OPERATION=""move"";else; OPERATION=""copy""; COPY=true;fi;;# Handle destination overwrite options;if [ ""$DELETE_DEST"" = true ]; then; echo ""Deleting all contents in destination directory '$DESTINATION'.""; rm -rf ""$DESTINATION""/*;elif [ ""$KEEP"" = true ]; then; OVERWRITE_OPTION=""-n"";elif [ ""$REPLACE"" = true ] || [ ""$MOVE"" = true ] || [ ""$COPY"" = true ]; then; OVERWRITE_OPTION=""-f"";else; OVERWRITE_OPTION=""-f"";fi;;# Perform copy or move;if [ ""$OPERATION"" = ""copy"" ]; then; echo ""Copying from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; cp -a $OVERWRITE_OPTION ""$SOURCE""/. ""$DESTINATION""/;elif [ ""$OPERATION"" = ""move"" ]; then; echo ""Moving from '$SOURCE' to '$DESTINATION' with options: $OVERWRITE_OPTION""; mv ""$SOURCE""/. ""$DESTINATION""/;fi;;echo ""Operation completed successfully.""",1082,"7464.219093322754","1","1","o1-mini","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,1,1,0,"Line 75: Use *${var:?}* to ensure this never expands to /* . Line 87: Double quote to prevent globbing and word splitting. Line 90: Use *${var:?}* to ensure this never expands to /* . ","6.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","240.60000000000002"
6171,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"#!/bin/bash

# Enable nullglob to prevent literal interpretation if no files match
shopt -s nullglob

# Find all files matching archive.* pattern
files=(archive.*)

# Check if exactly one file exists
if [[ ${#files[@]} -ne 1 ]]; then
 echo ""Error: Exactly one archive.* file must exist in the current directory"" >&2
 exit 1
fi

filename=""${files[0]}""

# Extract based on file extension
case ""$filename"" in
 *.tar.bz2|*.tbz2) tar xjf ""$filename"" ;;
 *.tar.gz|*.tgz) tar xzf ""$filename"" ;;
 *.tar.xz) tar xJf ""$filename"" ;;
 *.tar) tar xf ""$filename"" ;;
 *.zip) unzip ""$filename"" ;;
 *.gz)  gunzip ""$filename"" ;;
 *.bz2) bunzip2 ""$filename"" ;;
 *.rar) unrar x ""$filename"" ;;
 *.7z)  7z x ""$filename"" ;;
 *)
 echo ""Unsupported archive format: $filename"" >&2
 exit 1
 ;;
esac

echo ""Extracted $filename successfully""",1753,"16222.480058670044","0.2","0.4","deepseek-r1","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","-1"
8080,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"current_date=$(date +""%b %_d"");zgrep -hE -i ""$current_date.*(failed password|authentication failure|failed login|authentication error|user unknown|invalid user)"" /var/log/auth.log* 2>/dev/null | {; while read -r line; do; user=$(echo ""$line"" | sed -nE \; -e 's/.*[Ff]ailed [Pp]assword (for|during) (invalid user )?([^ ]+).*/\3/p' \; -e 's/.*[Aa]uthentication failure.* (user|ruser)=([^ ]+).*/\2/p' \; -e 's/.*FAILED LOGIN .* FOR (\x27)?([^ ]+).*/\2/p' \; -e 's/.*Invalid user ([^ ]+) from.*/\1/p' \; -e 's/.* user ([^ ]+) .*authentication failure.*/\1/p' \; -e 's/.*[Ee]rror: ([^ ]+) authentication failure.*/\1/p'); [ -n ""$user"" ] && echo ""$user""; done;} | sort | uniq -c | awk '$1 >=3 {count++} END {printf ""Users: %d\n"", count}'",5415,"253107.13052749634","0","0.1","deepseek-r1","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8338,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -mindepth 1 -perm -u=r -exec ls -ld {} +",2955,"131696.12741470337","0","0.1","deepseek-r1","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.9000000000000001"
6788,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy=true
delete_source=false
replace_dest=true
delete_dest=false
swap=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy=true ;;
 --sd) delete_source=true ;;
 --dr) replace_dest=true ;;
 --dk) replace_dest=false ;;
 --dd) delete_dest=true ;;
 --sw) swap=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_dest; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy; then
 if $replace_dest; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",282,"2967.482805252075","0.2","0.4","gpt-4o","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: unrecognized option '--sc/*' Try 'cp --help' for more information. ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
6274,"Experiment 1","CountFailFiles","NL2Bash",1,1,"grep -rl ""FAIL"" /usr/results --include=""result.log"" | wc -l
grep -ril ""FAIL"" /usr/results --include=""result.log"" | wc -l",170,"12480.655908584595","0","0.1","deepseek-v3","Datne result.log ar ‘FAIL’ direktorijā un apakšdirektorijā. Direktorijā 1 cita datne, kas arī satur ‘FAIL’. Vēl viena apakšdirektorija, kas satur result.log bez ‘FAIL’.",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Count the number of files named ""result.log"" under ""/usr/results directory tree that match ""FAIL"" in their contents","11.7"
8076,"Experiment 1","FindVirtualInterfaces","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check if there are any virtual interfaces (excluding loopback);if ip -o addr show | grep -q -v lo:; then; # Loop through each interface (excluding loopback); ip -o addr show | grep -v lo: | while read -r line; do; interface=$(echo ""$line"" | awk '{print $2}'); ip=$(echo ""$line"" | awk '{print $4}'); # Check if interface has an IPv4 address; if [[ $ip == *"".""* ]]; then; echo ""$interface - $ip""; else; echo ""$interface - None""; fi; done;else; echo ""No virtual interfaces found"";fi",159,"2175.994873046875","0.7","0.9","gpt-3.5-turbo","Viens fizisks interfeiss un 2 virtuālie, tikai 1 no tiem ir IPv4 adrese, tā nosaukums ir *inet*",3,"",False,"All required virtual interfaces were not found. Perhaps the issue is that the interface is named *inet*?",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","List the names and ipv4 addreses of all virtual network interface’s (except loopback) in the format “{interface name} - {IP}”, if the interface doesn’t have an ipv4 address, replace it with “None” in the output. If there are no such virtual interfaces, print “No virtual interfaces found”.","56.9"
7036,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install postgresql;;# Change port to 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/$(ls /etc/postgresql)/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Create database ""storedb"";sudo -u postgres psql -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";sudo -u postgres psql -d storedb -f init.sql;;# Create user ""public_view"" with read-only access to schema ""common_data"";sudo -u postgres psql -d storedb -c ""CREATE USER public_view WITH PASSWORD 'fox';"";sudo -u postgres psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";sudo -u postgres psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;""",212,"2451.3096809387207","0","0.1","gpt-3.5-turbo","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"",False,"Script won't finish",0,0,1,0,"Line 7: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","13.75"
8119,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"2049.76224899292","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
8120,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"2049.76224899292","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
8098,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep -E ""authentication failure|Failed password|login"" | awk '{for(i=1;i<=NF;i++) if($i ~ /user=/) {split($i,a,""=""); print a[2]}}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print ""Users:"", count}'",92,"3073.8134384155273","0","0.1","gpt-4o","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","15.39"
8113,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep ""Failed password"" | awk '{for(i=1;i<=NF;i++) if ($i==""user"") {print $(i+1)}}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",988,"12988.736629486084","1","1","o1-mini","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","19.360000000000003"
8114,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""$(date '+%b %e')"" /var/log/auth.log | grep ""Failed password"" | awk '{for(i=1;i<=NF;i++) if ($i==""user"") {print $(i+1)}}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",988,"12988.736629486084","1","1","o1-mini","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","19.360000000000003"
8129,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",128,"3312.5927448272705","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
8130,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",128,"3312.5927448272705","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
8131,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/Failed password/ && $1 == *$(date +*%b*)* && $2 == *$(date +*%d*)* {print $9}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",67,"2054.0895462036133","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.86"
8121,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep *Failed password* /var/log/auth.log | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",62,"2049.76224899292","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar ssh",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.32"
8122,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",139,"3976.47762298584","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
8123,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep *Failed password* /var/log/auth.log /var/log/auth.log.1 | grep *$(date +%b\ %d)* | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print *Users: *$1}'",139,"3976.47762298584","0","0.1","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory grep: /var/log/auth.log.1: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.37"
8149,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"users=$(awk -v date=$(date +""%b %d"") '$0 ~ date && $6 == ""Failed"" {print $9}' /var/log/auth.log | cut -d':' -f1 | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",78,"2654.714345932007","0.7","0.9","llama3.3-70b","Autorizācijas ar tty",1,"awk: cannot open $0 ~ date && $6 == *Failed* {print $9} (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8140,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"LOG_FILE=""/var/log/auth.log"";if [ -f ""$LOG_FILE"" ]; then; TODAY=$(date +""%b %d""); UNIQUE_USERS=$(grep -E ""authentication failure|Failed password|invalid user"" ""$LOG_FILE"" | grep ""$TODAY"" | awk '{print $3}' | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l); echo ""Users: $UNIQUE_USERS"";else; echo ""Users: 0"";fi",114,"2289.195775985718","0","0.1","llama3.3-70b","Autorizācijas ar tty",1,"",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8134,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep -E 'Failed password|Failed login' /var/log/auth.log | grep *$(date +*%b %d*)* | awk '{print $(NF-1)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",66,"2833.6715698242188","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8135,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep -E 'Failed password|Failed login' /var/log/auth.log | grep *$(date +*%b %d*)* | awk '{print $(NF-1)}' | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",66,"2833.6715698242188","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","14.05"
8132,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"awk '/Failed password/ && $1 == *$(date +*%b*)* && $2 == *$(date +*%d*)* {print $9}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {count++} END {print *Users: * count}'",67,"2054.0895462036133","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Autorizācijas ar su un sudo",2,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","10.86"
5174,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -X -f -d",410,"3212.918519973755","1","1","o1-mini","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.5"
6995,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres psql <<EOF;-- Create the database;CREATE DATABASE storedb;;;-- Connect to the storedb database;\c storedb;;-- Run the init.sql script;\i 'init.sql';;-- Create the user with read-only access;CREATE USER public_view WITH PASSWORD 'fox';;;-- Grant read-only access to the schema common_data;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;;-- Ensure future tables in schema common_data are accessible;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",237,"7378.440141677856","0.2","0.4","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: init.sql: No such file or directory ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","29.400000000000006"
8150,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"users=$(awk -v date=$(date +""%b %d"") '$0 ~ date && $6 == ""Failed"" {print $9}' /var/log/auth.log | cut -d':' -f1 | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",78,"2654.714345932007","0.7","0.9","llama3.3-70b","Autorizācijas ar su un sudo",2,"awk: cannot open $0 ~ date && $6 == *Failed* {print $9} (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8151,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"users=$(awk -v date=$(date +""%b %d"") '$0 ~ date && $6 == ""Failed"" {print $9}' /var/log/auth.log | cut -d':' -f1 | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",78,"2654.714345932007","0.7","0.9","llama3.3-70b","Autorizācijas ar ssh",2,"awk: cannot open $0 ~ date && $6 == *Failed* {print $9} (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using ssh for authorization, different types of authorization should be checked)",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8152,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"users=$(awk -v date=""$(date +""%b %d"")"" '/failed password for|authentication failure|invalid user/ && $0 ~ date {print $NF}' /var/log/auth.log | sort | uniq -c | awk '$1 >= 3 {print $2}' | wc -l);echo ""Users: $users""",76,"2972.919702529907","0.7","0.9","llama3.3-70b","Autorizācijas ar tty",1,"awk: cannot open /var/log/auth.log (No such file or directory) ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
8159,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"#!/bin/bash;;# Check for auth log files (Debian typically uses auth.log or secure);LOG_FILES=();[ -f /var/log/auth.log ] && LOG_FILES+=(/var/log/auth.log);[ -f /var/log/secure ] && LOG_FILES+=(/var/log/secure);[ -f /var/log/syslog ] && LOG_FILES+=(/var/log/syslog);;if [ ${#LOG_FILES[@]} -eq 0 ]; then; echo ""Error: No authentication log files found"" >&2; exit 1;fi;;# Count unique users with >=3 failed auth attempts today;count=$(grep -h ""$(date '+%b %e')"" ""${LOG_FILES[@]}"" | \; grep -iE ""failed|invalid|authentication failure"" | \; grep -iE ""password|authentication|login|sshd"" | \; awk 'match($0, /user(name)?=([^ ]+)/, a) {print a[2]} ;  match($0, /for( invalid user)? ([^ ]+)/, a) {print a[2]} ;  /FAILED/ {for(i=1;i<=NF;i++) if ($i==""for"") print $(i+1)}' | \; sort | uniq -c | \; awk '$1 >= 3 {print $0}' | \; wc -l);;echo ""Users: $count""",448,"23656.993865966797","0","0.1","deepseek-v3","Autorizācijas ar su un sudo",2,"Error: No authentication log files found ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","-1"
6998,"Experiment 1","SetupPostgres","IaC",2,2,"# Ensure the init.sql file exists in the current directory;if [ ! -f init.sql ]; then; echo ""init.sql file not found in the current directory.""; exit 1;fi;;# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres psql <<EOF;-- Create the database;CREATE DATABASE storedb;;;-- Connect to the storedb database;\c storedb;;-- Run the init.sql script;\i '$(pwd)/init.sql';;-- Create the user with read-only access;CREATE USER public_view WITH PASSWORD 'fox';;;-- Create the schema if it doesn't exist;CREATE SCHEMA IF NOT EXISTS common_data;;;-- Grant read-only access to the schema common_data;GRANT CONNECT ON DATABASE storedb TO public_view;;GRANT USAGE ON SCHEMA common_data TO public_view;;GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;;;-- Ensure future tables in schema common_data are accessible;ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;;EOF",300,"3523.609399795532","0.2","0.4","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,") for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: NOTICE: schema *common_data* already exists, skipping ",False,"Postgres is running on incorrect port",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","-1"
8207,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 relative_path=""${file#/etc/docs/}""
 dest_dir=""/etc/movedDocs/$(dirname ""$relative_path"")""
 mkdir -p ""$dest_dir""
 mv -- ""$file"" ""$dest_dir/""
 mv -- ""${file%.found}"" ""$dest_dir/""
done",1136,"43119.956970214844","0.7","0.9","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","13.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","26.9"
8185,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep 'authentication failure' /var/log/auth.log | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",51,"1149.799108505249","0.7","0.9","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","16.189999999999998"
8174,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,1,"grep ""authentication failure"" /var/log/auth.log | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",62,"2249.5899200439453","0","0.1","gpt-3.5-turbo","Autorizācijas ar su un sudo",2,"grep: /var/log/auth.log: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `sudo` and `su` commands for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
8208,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 relative_path=""${file#/etc/docs/}""
 dest_dir=""/etc/movedDocs/$(dirname ""$relative_path"")""
 mkdir -p ""$dest_dir""
 mv -- ""$file"" ""$dest_dir/""
 mv -- ""${file%.found}"" ""$dest_dir/""
done",1136,"43119.956970214844","0.7","0.9","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",True,"",0,0,0,0,"","13.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","26.9"
8193,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; mkdir -p ""$target_dir""; mv -- ""$found_file"" ""$docx_file"" ""$target_dir/""; fi;done",3092,"114909.73544120789","0","0.1","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","38.25"
8406,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"lines_to_remove=5
total_lines=$(wc -l < data.md)
lines_to_keep=$((total_lines - lines_to_remove))

if [ $lines_to_keep -gt 0 ]; then
 head -n $lines_to_keep data.md > temp.md && mv temp.md data.md
else
 > data.md
fi",75,"1873.866081237793","0","0.1","gpt-4o","data.md ar 4 rindām",3,"",False,"",0,0,1,0,"Line 9: This redirection doesn't have a command. Move to its command (or use 'true' as no-op). ","11.0","","RISK","Remove last 5 lines from data.md","18.6"
8176,"Experiment 1","FindUnsuccesfulLoginAttempts","Sistēmas informācijas izgūšana",3,2,"grep ""authentication failure"" /var/log/auth.log* | grep ""$(date +""%b %e"")"" | awk '{print $9}' | sort | uniq -c | awk '$1 >= 3' | wc -l | awk '{print ""Users: "" $1}'",63,"1871.473789215088","0","0.1","gpt-3.5-turbo","Autorizācijas ar tty",1,"grep: /var/log/auth.log*: No such file or directory ",False,"The correct number of user was not found (in the case where users are using `login` command for authorization, different types of authorization should be checked)",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find how many unique users had atleast 3 unsuccesful authorization attempts today. Output it in the format *Users: {number}*","18.54"
8194,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs || exit 1;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; if mkdir -p ""$target_dir""; then; if mv -v -- ""$found_file"" ""$docx_file"" ""$target_dir/""; then; echo ""Moved: $found_file and $docx_file to $target_dir""; else; echo ""Error moving files: $found_file and $docx_file"" >&2; fi; else; echo ""Error creating directory: $target_dir"" >&2; fi; else; echo ""No matching .docx for: $found_file"" >&2; fi;done",7374,"267160.3276729584","0","0.1","deepseek-r1","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","77.19999999999999"
8195,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs || exit 1;find /etc/docs -type f -name '*.docx.found' -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; if [[ -f ""$docx_file"" ]]; then; relative_path=""${found_file#/etc/docs/}""; target_dir=""/etc/movedDocs/${relative_path%/*}""; if mkdir -p ""$target_dir""; then; if mv -v -- ""$found_file"" ""$docx_file"" ""$target_dir/""; then; echo ""Moved: $found_file and $docx_file to $target_dir""; else; echo ""Error moving files: $found_file and $docx_file"" >&2; fi; else; echo ""Error creating directory: $target_dir"" >&2; fi; else; echo ""No matching .docx for: $found_file"" >&2; fi;done",7374,"267160.3276729584","0","0.1","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","77.19999999999999"
8275,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",241,"14148.418426513672","0.2","0.4","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8236,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2384.0949535369873","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
8227,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs

for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 corresponding=""${file%.found}""
 if [ -f ""$corresponding"" ]; then
 mv ""$corresponding"" /etc/movedDocs/
 fi
done",793,"5203.897714614868","1","1","o1-mini","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
8228,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs

for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 corresponding=""${file%.found}""
 if [ -f ""$corresponding"" ]; then
 mv ""$corresponding"" /etc/movedDocs/
 fi
done",793,"5203.897714614868","1","1","o1-mini","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
8230,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs;;find /etc/docs -type f -name '*.docx.found' | while IFS= read -r file; do; # Move the .docx.found file; mv ""$file"" /etc/movedDocs/; # Determine the corresponding .docx file; corresponding=""${file%.found}""; # Check if the corresponding .docx file exists and move it; if [ -f ""$corresponding"" ]; then; mv ""$corresponding"" /etc/movedDocs/; fi;done",1228,"7703.648567199707","1","1","o1-mini","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8239,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"1883.9497566223145","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
8240,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"1883.9497566223145","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
8246,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",50,"1820.3132152557373","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
8252,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
find /etc/docs -name ""*.docx.found"" -exec mv {} /etc/movedDocs \;
find /etc/docs -name ""*.docx"" -exec mv {} /etc/movedDocs \;",58,"1880.9778690338135","0","0.1","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.8"
8457,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"969.2935943603516","0","0.1","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8241,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"1883.9497566223145","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
8247,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",50,"1820.3132152557373","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
8248,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",78,"2483.449935913086","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
8242,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash mkdir -p /etc/movedDocs for found_file in /etc/docs/*.docx.found; do base_name=*${found_file%.found}* if [ -f *$base_name* ]; then  mv *$base_name* /etc/movedDocs  mv *$found_file* /etc/movedDocs fi done",82,"2377.5954246520996","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.95"
8201,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; docx_file=""${found_file%.found}""; relative_path=$(dirname ""$found_file"" | sed 's|^/etc/docs/||'); target_dir=""/etc/movedDocs/${relative_path}""; mkdir -p ""$target_dir""; mv -f ""$found_file"" ""$target_dir/"" 2>/dev/null; mv -f ""$docx_file"" ""$target_dir/"" 2>/dev/null;done",1640,"60423.38562011719","0.2","0.4","deepseek-r1","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","30.299999999999997"
8288,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2076.272964477539","0","0.1","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
7111,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d \
 --name alpine-linux-container \
 -v /usr/alpinedata:/imported \
 alpine:latest",559,"4867.917060852051","1","1","o1-mini","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
8255,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 docx_file=""${file%.found}""
 if [ -f ""$docx_file"" ]; then
 mv ""$file"" ""$docx_file"" /etc/movedDocs
 fi
done",71,"2196.0487365722656","0","0.1","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","13.6"
8290,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2409.4901084899902","0","0.1","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8276,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",241,"14148.418426513672","0.2","0.4","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8297,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx).found' _ {} \;",148,"3706.3872814178467","0.2","0.4","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8209,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"2312.979221343994","0","0.1","gpt-4o","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","6.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
8301,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;mkdir -p /etc/movedDocs;;find /etc/docs -name ""*.docx.found"" -exec sh -c 'mv ""$0"" /etc/movedDocs/ && mv ""${0%.found}"" /etc/movedDocs/' {} \;",62,"1272.0422744750977","0.7","0.9","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.15"
7002,"Experiment 1","SetupPostgres","IaC",2,2,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Start PostgreSQL service;systemctl restart postgresql;;# Ensure init.sql has the correct permissions;chmod 644 /root/init.sql;;# Switch to the postgres user to setup the database;sudo -i -u postgres bash << EOF;;# Create the ""storedb"" database;psql -c ""CREATE DATABASE storedb;"";;# Run the SQL script;psql -d storedb -f /root/init.sql;;EOF;;# Switch to the postgres user to setup the user and permissions;sudo -i -u postgres bash << EOF;;# Create the ""public_view"" user with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Create the schema ""common_data"" if it doesn't exist;psql -d storedb -c ""CREATE SCHEMA IF NOT EXISTS common_data;"";;# Grant read-only access to the ""public_view"" user on the ""common_data"" schema;psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",334,"4226.841688156128","0.7","0.9","gpt-4o","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"nterface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: chmod: cannot access '/root/init.sql': No such file or directory psql: error: /root/init.sql: Permission denied ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","21.050000000000004"
8277,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",241,"14148.418426513672","0.2","0.4","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8216,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs
for file in /etc/docs/*.docx.found; do
 base_name=""${file%.found}""
 mv ""$file"" /etc/movedDocs/
 if [ -e ""$base_name"" ]; then
 mv ""$base_name"" /etc/movedDocs/
 fi
done",76,"1874.6206760406494","0.2","0.4","gpt-4o","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Files in subdirectory were not moved",0,0,0,0,"","6.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.95"
8234,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"2089.3008708953857","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"Only *.docx files that have a corresponding *.docx.found file should be moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
4967,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"nt: your next pull: hint: hint:  git config pull.rebase false # merge hint:  git config pull.rebase true  # rebase hint:  git config pull.ff only  # fast-forward only hint: hint: You can replace *git config* with *git config --global* to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
8310,"Experiment 1","FindDate","NL2Bash",3,2,"for d in {01..07}; do date -d ""2013-05-$d"" ""+%u %F"" 2>/dev/null; done | awk '$1==1{print $2; exit}'",2366,"105897.86911010742","0.7","0.9","deepseek-r1","Jāizdrukā datuma skaitlis",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print date of first Monday in May, 2013","9.27"
8278,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d '' found_file; do; # Get the corresponding .docx file path; docx_file=""${found_file%.found}""; # Calculate relative path from /etc/docs; rel_path=""${found_file#/etc/docs/}""; rel_path=""${rel_path%/*}""; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/${rel_path}""; mkdir -p ""$dest_dir""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" ""$dest_dir/""; else; mv ""$found_file"" ""$dest_dir/""; fi;done",328,"16522.867679595947","0.2","0.4","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.89999999999999"
8235,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash mkdir -p /etc/movedDocs find /etc/docs -type f \( -name **.docx.found* -o -name **.docx* \) -exec mv {} /etc/movedDocs \;",54,"2089.3008708953857","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.4499999999999997"
6991,"Experiment 1","SetupPostgres","IaC",2,1,"# Install PostgreSQL;apt update;apt install -y postgresql;;# Update PostgreSQL to listen on port 5433;sed -i ""s/#port = 5432/port = 5433/"" /etc/postgresql/*/main/postgresql.conf;;# Restart PostgreSQL to apply changes;systemctl restart postgresql;;# Switch to the postgres user to create the database and user;sudo -i -u postgres bash << EOF;;# Create the database ""storedb"";psql -c ""CREATE DATABASE storedb;"";;# Run the init.sql script on the ""storedb"" database;psql -d storedb -f /path/to/init.sql;;# Create the user ""public_view"" with password ""fox"";psql -c ""CREATE USER public_view WITH PASSWORD 'fox';"";;# Grant read-only access to the ""common_data"" schema;psql -d storedb -c ""GRANT CONNECT ON DATABASE storedb TO public_view;"";psql -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;"";;EOF",285,"3405.122995376587","0","0.1","gpt-4o","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,": Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: psql: error: /path/to/init.sql: No such file or directory ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ERROR: schema *common_data* does not exist ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","17.8"
7432,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime 21 -print
find /usr/info -type f -mtime +20 -mtime -22 -print",163,"12694.263458251953","0.7","0.9","deepseek-v3","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","3.3"
8365,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do if [ -r *$file* ]; then  ls -l *$file* fi done",34,"1602.1487712860107","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","9.85"
8263,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"4587.56947517395","0.7","0.9","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"find: sed: read error on /etc/movedDocs: Is a directory missing argument to `-exec' ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
8366,"Experiment 1","LongListReadPermission","NL2Bash",2,2,"for file in *; do if [ -r *$file* ]; then  ls -l *$file* fi done",34,"1602.1487712860107","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","9.85"
8269,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" /etc/movedDocs/; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",177,"10916.786670684814","0","0.1","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.5"
8270,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" /etc/movedDocs/; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",177,"10916.786670684814","0","0.1","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.5"
8261,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs
find /etc/docs -type f -name ""*.docx.found"" -print0 | while IFS= read -r -d ' file; do
 mv ""$file"" /etc/movedDocs
 mv ""${file%.found}"" /etc/movedDocs
done",73,"2182.0149421691895","0.2","0.4","llama3.3-70b","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","16.8"
8271,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" /etc/movedDocs/; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",177,"10916.786670684814","0","0.1","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.5"
8272,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files under /etc/docs and process them;find /etc/docs -type f -name ""*.docx.found"" | while read -r found_file; do; # Get the corresponding .docx file path by removing the .found suffix; docx_file=""${found_file%.found}""; # Get the relative path (removing /etc/docs prefix); relative_path=""${found_file#/etc/docs/}""; relative_path=""${relative_path%/*}"" # Get directory part; # Create destination subdirectory if needed; dest_dir=""/etc/movedDocs/$relative_path""; mkdir -p ""$dest_dir""; # Check if the corresponding .docx file exists; if [ -f ""$docx_file"" ]; then; # Move both files to the destination directory; mv ""$found_file"" ""$docx_file"" ""$dest_dir/""; else; echo ""Warning: Corresponding .docx file not found for $found_file""; fi;done",330,"16326.334476470947","0","0.1","deepseek-v3","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","42.79999999999999"
4968,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"#!/bin/bash
git checkout develop
git pull origin develop -s recursive -X ours",420,"4214.643955230713","1","1","o1-mini","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"Already on 'develop' From file:///usr/git_server * branch  develop -> FETCH_HEAD 4ee37e2..84290cd develop -> origin/develop error: Your local changes to the following files would be overwritten by merge: 	text.txt Please commit your changes or stash them before you merge. Aborting ",False,"Changes have not been pulled. A file is missing.",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","3.05"
7062,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the PostgreSQL service;systemctl stop postgresql;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;mkdir /var/lib/postgresql/17/main;chown postgres:postgres /var/lib/postgresql/17/main;;# Use pg_upgrade to upgrade the data;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf' \;  --link --check;;# Check for any errors;if [ $? -ne 0 ]; then; echo ""Upgrade failed, please check the logs""; exit 1;fi;;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16/main;;# Update the PostgreSQL configuration files;mv /etc/postgresql/16/main/postgresql.conf /etc/postgresql/17/main/;mv /etc/postgresql/16/main/pg_hba.conf /etc/postgresql/17/main/;mv /etc/postgresql/16/main/pg_ident.conf /etc/postgresql/17/main/;;# Start the PostgreSQL service;systemctl start postgresql@17-main",301,"2370.859384536743","0","0.1","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",1,0,0,0,"Line 20: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. ","4.5","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","22.749999999999993"
8282,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",269,"14309.181690216064","0.7","0.9","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",False,"",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8283,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Create destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Find all .docx.found files and process them;find /etc/docs -type f -name ""*.docx.found"" | while read found_file; do; # Get the corresponding .docx filename; docx_file=""${found_file%.found}""; # Move both files if they exist; if [[ -f ""$docx_file"" ]]; then; mv ""$docx_file"" ""$found_file"" /etc/movedDocs/; else; mv ""$found_file"" /etc/movedDocs/; fi;done",269,"14309.181690216064","0.7","0.9","deepseek-v3","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,1,0,0,"Line 7: read without -r will mangle backslashes. ","7.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","29.549999999999997"
8408,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i ':a;N;$!ba;s/\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*\n[^\n]*$//' data.md",51,"1351.7792224884033","0.2","0.4","gpt-4o","data.md ar 4 rindām",3,"",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,0,0,0,"","8.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.45"
8429,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"sed -i -e "":a;N;$d;ba"" -e ""5{h;d};5G;G;$d"" data.md",37,"2089.580535888672","0.2","0.4","llama3.3-70b","data.md ar 10 rindām",1,"",False,"The last 5 lines were not removed",0,0,1,0,"Line 2: d is referenced but not assigned. ","3.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.6"
8447,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",443,"23839.26558494568","0.2","0.4","deepseek-r1","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8300,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;mkdir -p /etc/movedDocs;;find /etc/docs -name ""*.docx.found"" -exec sh -c 'mv ""$0"" /etc/movedDocs/ && mv ""${0%.found}"" /etc/movedDocs/' {} \;",62,"1272.0422744750977","0.7","0.9","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","3.15"
8409,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"lines_to_remove=5
total_lines=$(wc -l < data.md)
lines_to_keep=$((total_lines - lines_to_remove))

if [ $lines_to_keep -gt 0 ]; then
 head -n $lines_to_keep data.md > temp.md && mv temp.md data.md
else
 > data.md
fi",75,"1366.102933883667","0.2","0.4","gpt-4o","data.md ar 10 rindām",1,"",False,"",0,0,1,0,"Line 9: This redirection doesn't have a command. Move to its command (or use 'true' as no-op). ","11.0","","RISK","Remove last 5 lines from data.md","18.6"
7135,"Experiment 1","SetupAlpineContainer","IaC",2,1,"mkdir -p /usr/alpinedata
docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine:latest tail -f /dev/null",622,"32977.609157562256","0.2","0.4","deepseek-r1","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3.2"
7260,"Experiment 1","VerifyFile","IaC",1,2,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1391.5436267852783","0.2","0.4","gpt-3.5-turbo","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
8410,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"lines_to_remove=5
total_lines=$(wc -l < data.md)
lines_to_keep=$((total_lines - lines_to_remove))

if [ $lines_to_keep -gt 0 ]; then
 head -n $lines_to_keep data.md > temp.md && mv temp.md data.md
else
 > data.md
fi",75,"1366.102933883667","0.2","0.4","gpt-4o","data.md ar 4 rindām",3,"",False,"",0,0,1,0,"Line 9: This redirection doesn't have a command. Move to its command (or use 'true' as no-op). ","11.0","","RISK","Remove last 5 lines from data.md","18.6"
8423,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"sed -i '1,$(!d)' -e '$d' -e '$d' -e '$d' -e '$d' -e '$d' data.md",42,"3457.5507640838623","0","0.1","llama3.3-70b","data.md ar 10 rindām",1,"sed: can't read 1,$(!d): No such file or directory ",False,"The last 5 lines were not removed",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.95"
8426,"Experiment 1","RemoveLastLines","NL2Bash",1,2,"sed -i -e ':a;N;$!ba' -e 's/^\(.*\)\n\(.*\)\n\(.*\)\n\(.*\)\n\(.*\)$/\1/' data.md",54,"8908.559799194336","0","0.1","llama3.3-70b","data.md ar 4 rindām",3,"",False,"The last 5 lines were not removed. If a file has less than 5 lines, it should still work and delete all lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Remove last 5 lines from data.md","1.6"
5475,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do if [ -f *$script* ]; then  if bash *$script*; then  echo *$script: OK*  else  echo *$script: FAIL*  fi else  echo *$script: NOT FOUND* fi done",137,"3961.127758026123","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","25.849999999999998"
8448,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",443,"23839.26558494568","0.2","0.4","deepseek-r1","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8453,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",375,"20452.175855636597","0.7","0.9","deepseek-r1","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8492,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"1861.0262870788574","0.7","0.9","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
7365,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1400.6297588348389","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta. Papildus direktorijā ir mape, kas iekļaujas diapozonā",2,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
7348,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -type f -mtime -21 -mtime +20",22,"1445.340871810913","0","0.1","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir senāk modificēta",1,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
8454,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",375,"20452.175855636597","0.7","0.9","deepseek-r1","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8445,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",1662,"76421.0114479065","0","0.1","deepseek-r1","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8446,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",1662,"76421.0114479065","0","0.1","deepseek-r1","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8455,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1478.661298751831","0","0.1","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8456,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1478.661298751831","0","0.1","gpt-4o","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8293,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/'$(basename ""$1"" .docx)'.found' _ {} \;",184,"2880.166530609131","0.2","0.4","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,1,1,0,"Line 10: Quote this to prevent word splitting. Line 10: This will expand once before find runs, not per file found. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
8355,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -perm -u=r -exec ls -l {} +",1060,"11382.601022720337","1","1","o1-mini","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes.",1,"",False,"Only files with atleast read permission should be listed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.8"
5041,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1305.321216583252","0.7","0.9","llama3.3-70b","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus 1 datnei, bet lokālā repozitorija atrodas zarā “main”, kurā ir nesaglabātas izmaiņas (kurām nav jāparādās “develop”, bet tās arī nedrīkst pazaudēt)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b549a7d..e0fc63a develop -> origin/develop Switched to branch 'develop' ",False,"Uncommited changes shouldn't have been kept in the scenario where the repository starts on a different branch than develop but stashed instead.",0,0,0,0,"","9.5","CONDITION_PARTIALLY_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8504,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"6563.850879669189","0.7","0.9","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8506,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} \;",169,"13103.047370910645","0.7","0.9","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8497,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",142,"12388.379573822021","0","0.1","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8493,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1259.7217559814453","0.7","0.9","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
8483,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"3357.3989868164062","0","0.1","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8484,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} \;",22,"3357.3989868164062","0","0.1","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8485,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1372.4863529205322","0","0.1","llama3.3-70b","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
8486,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1372.4863529205322","0","0.1","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
8496,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",150,"11584.298610687256","0","0.1","deepseek-v3","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8494,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -type d -not -path ""$1/.sn"" -exec chmod g+s {} \;",31,"1259.7217559814453","0.7","0.9","llama3.3-70b","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.85"
5518,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done
for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",831,"21754.627227783203","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.4"
8593,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8514,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"854.9623489379883","0.2","0.4","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8518,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"952.8515338897705","0.7","0.9","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
8507,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"847.6958274841309","0","0.1","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8509,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",26,"957.6952457427979","0","0.1","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
9339,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -path '*/wp-includes/version.php' -exec \; grep -h -oP '\$wp_version\s*=\s*\047\K[^\047]+' {} \; | \; awk '{print ""Found: "" $0}'",1613,"80981.71091079712","0.2","0.4","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"",0,1,0,0,"Line 3: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.55"
8302,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;src_dir=""/etc/docs"";dest_dir=""/etc/movedDocs"";;find ""$src_dir"" -type f -name ""*.docx.found"" -exec sh -c '; for found_file; do; base_dir=$(dirname ""$found_file""); dest_subdir=""${base_dir#$src_dir}""; dest_subdir=""${dest_subdir#/}""; mkdir -p ""$dest_dir/$dest_subdir""; mv ""$found_file"" ""$dest_dir/$dest_subdir/""; mv ""${found_file%.found}"" ""$dest_dir/$dest_subdir/""; done;' find-sh {} +",132,"2257.4362754821777","0.7","0.9","gpt-3.5-turbo","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"mv: '/etc/docs/file2.docx.found' and '/etc/docs/file2.docx.found' are the same file mv: '/etc/docs/file2.docx' and '/etc/docs/file2.docx' are the same file mv: '/etc/docs/file1.docx.found' and '/etc/docs/file1.docx.found' are the same file mv: '/etc/docs/file1.docx' and '/etc/docs/file1.docx' are the same file ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,1,0,"Line 4: dest_dir appears unused. Verify use (or export if used externally). ","3.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.5"
8515,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1051.0015487670898","0.7","0.9","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",False,"The SGID bit shoudlnt be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8516,"Experiment 1","SetSGID","NL2Bash",3,1,"find ""$1/.sn"" -type d -exec chmod g+s {} +",21,"1051.0015487670898","0.7","0.9","gpt-3.5-turbo","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
9340,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -path '*/wp-includes/version.php' -exec \; grep -h -oP '\$wp_version\s*=\s*\047\K[^\047]+' {} \; | \; awk '{print ""Found: "" $0}'",1613,"80981.71091079712","0.2","0.4","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"",0,1,0,0,"Line 3: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.55"
8537,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Function to parse the ini file;parse_ini_file() {; local ini_file=""$1""; local section=""""; while IFS= read -r line || [ -n ""$line"" ]; do; # Remove leading/trailing whitespace; line=$(echo ""$line"" | sed 's/^[ \t]*//;s/[ \t]*$//'); # Skip comments and empty lines; if [[ ""$line"" =~ ^\; || ""$line"" =~ ^# || -z ""$line"" ]]; then; continue; fi; # Handle section headers; if [[ ""$line"" =~ ^\[(.*)\]$ ]]; then; section=""${BASH_REMATCH[1]}""; continue; fi; # Handle key-value pairs; if [[ ""$line"" =~ ^([^=]+)=(.*)$ ]]; then; key=""${BASH_REMATCH[1]}""; value=""${BASH_REMATCH[2]}""; # Export the variable with section prefix if section is not empty; if [ -n ""$section"" ]; then; export ""${section}_${key}""=""$value""; else; export ""$key""=""$value""; fi; fi; done < ""$ini_file"";};;# Usage;parse_ini_file ""settings.ini""",281,"5467.270851135254","0","0.1","gpt-4o","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","9.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8589,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8382,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"ls -l | grep -E '^-r'",136,"11681.261777877808","0.7","0.9","deepseek-v3","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",False,"",0,0,1,0,"Line 2: Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames. ","11.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","5.75"
8303,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;src_dir=""/etc/docs"";dest_dir=""/etc/movedDocs"";;find ""$src_dir"" -type f -name ""*.docx.found"" -exec sh -c '; for found_file; do; base_dir=$(dirname ""$found_file""); dest_subdir=""${base_dir#$src_dir}""; dest_subdir=""${dest_subdir#/}""; mkdir -p ""$dest_dir/$dest_subdir""; mv ""$found_file"" ""$dest_dir/$dest_subdir/""; mv ""${found_file%.found}"" ""$dest_dir/$dest_subdir/""; done;' find-sh {} +",132,"2257.4362754821777","0.7","0.9","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"mv: '/etc/docs/file1.docx.found' and '/etc/docs/file1.docx.found' are the same file mv: '/etc/docs/file1.docx' and '/etc/docs/file1.docx' are the same file mv: '/etc/docs/subdir/file5.docx.found' and '/etc/docs/subdir/file5.docx.found' are the same file mv: '/etc/docs/subdir/file5.docx' and '/etc/docs/subdir/file5.docx' are the same file ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,1,0,"Line 4: dest_dir appears unused. Verify use (or export if used externally). ","3.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.5"
4931,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,1,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"1505.9020519256592","0","0.1","gpt-4o","Lokālajā repozitorijā “develop” zarā ir commit, kas rada konfliktus, bet lokālā repozitorija atrodas zarā “main”",2,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
8594,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2254.9445629119873","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8304,"Experiment 1","MoveMarked","NL2Bash",2,2,"#!/bin/bash;;src_dir=""/etc/docs"";dest_dir=""/etc/movedDocs"";;find ""$src_dir"" -type f -name ""*.docx.found"" -exec sh -c '; for found_file; do; base_dir=$(dirname ""$found_file""); dest_subdir=""${base_dir#$src_dir}""; dest_subdir=""${dest_subdir#/}""; mkdir -p ""$dest_dir/$dest_subdir""; mv ""$found_file"" ""$dest_dir/$dest_subdir/""; mv ""${found_file%.found}"" ""$dest_dir/$dest_subdir/""; done;' find-sh {} +",132,"2257.4362754821777","0.7","0.9","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"mv: '/etc/docs/file1.docx.found' and '/etc/docs/file1.docx.found' are the same file mv: '/etc/docs/file1.docx' and '/etc/docs/file1.docx' are the same file mv: '/etc/docs/subdir/file1.docx.found' and '/etc/docs/subdir/file1.docx.found' are the same file mv: '/etc/docs/subdir/file1.docx' and '/etc/docs/subdir/file1.docx' are the same file ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,1,0,"Line 4: dest_dir appears unused. Verify use (or export if used externally). ","3.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","4.5"
9342,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home/*/public_html -path '*/wp-includes/version.php' -exec \; grep -h -oP ""\$wp_version\s*=\s*\047\K[^\047]+"" {} \; | \; awk '{print ""Found: "" $0}'",1615,"82449.99623298645","0.2","0.4","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.55"
9335,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -path '*/wp-includes/version.php' -print0 | while IFS= read -r -d '' file; do; version=$(grep -m1 '^\$wp_version\s*=' ""$file"" | awk -F""['\""]"" '{print $2}'); [[ -n ""$version"" ]] && echo ""Found: $version"";done",1256,"64300.72736740112","0","0.1","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"",0,1,0,0,"Line 3: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.7"
8585,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8586,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8576,"Experiment 1","LoadIniFile","NL2Bash",2,1,"#!/bin/bash;;# Path to the settings.ini file;INI_FILE=""settings.ini"";;# Check if the file exists;if [[ ! -f ""$INI_FILE"" ]]; then; echo ""File $INI_FILE not found.""; exit 1;fi;;# Read the ini file and export variables;while IFS='= ' read -r key value;do; # Remove leading/trailing whitespace; key=$(echo ""$key"" | sed 's/^[ \t]*//;s/[ \t]*$//'); value=$(echo ""$value"" | sed 's/^[ \t]*//;s/[ \t]*$//');; # Skip empty lines and comments; if [[ -z ""$key"" || ""$key"" =~ ^\; || ""$key"" =~ ^\# || ""$key"" =~ ^\[.*\] ]]; then; continue; fi;; # Export the variable; export ""$key""=""$value"";done < ""$INI_FILE""",674,"5470.980405807495","1","1","o1-mini","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","56.4"
8587,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8588,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2352.073907852173","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8846,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1052.5288581848145","0.2","0.4","gpt-4o","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8582,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8583,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8597,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8598,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8599,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8600,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8601,"Experiment 1","LoadIniFile","NL2Bash",2,2,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",71,"2329.418182373047","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8603,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
8605,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
8472,"Experiment 1","SetSGID","NL2Bash",3,1,"find *$1/.sn* -type d -exec chmod g+s {} +",20,"1355.2472591400146","0","0.1","qwen/qwen2.5-coder-32b-instruct","$1 tiek padots ceļš uz direktoriju (kas satur atstarpi), kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",2,"",False,"The SGID bit shoudln't be set on the parent directory",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Find all directories under $1/.sn and set their SGID bit","1.7"
8639,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8619,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
8616,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini file;while IFS=""="" read -r key value; do; # Ignore lines that start with a semicolon or are empty; if [ -z ""$key"" ] || [[ $key =~ ^\; ]] || [[ $key =~ ^# ]]; then; continue; fi;; # Remove leading and trailing whitespace from key and value; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]');; # Export key-value pair as environment variable; export ""$key=$value"";done < settings.ini;;# Print loaded settings;for key in $(compgen -v); do; echo ""$key=${!key}"";done",171,"2716.7487144470215","0","0.1","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","38.050000000000004"
8606,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
8607,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
8849,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do
 ln -s ""$file"" ""$(basename ""$file"")""
done",31,"1251.38258934021","0.7","0.9","gpt-4o","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8501,"Experiment 1","SetSGID","NL2Bash",3,2,"#!/bin/bash
if [ -d ""$1/.sn"" ]; then
 find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} \;
fi",110,"10001.16491317749","0.2","0.4","deepseek-v3","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","6.25"
8699,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8700,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove leading/trailing spaces from key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove leading/trailing spaces from value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",133,"2084.796905517578","0.2","0.4","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8642,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Load settings from settings.ini into the current shell;while IFS=""="" read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]'); value=$(echo ""$value"" | tr -d '[:space:]'); declare ""$key=$value"";done < <(grep -v '^#' settings.ini | grep -v '^$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')",112,"2050.690174102783","0.7","0.9","llama3.3-70b","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir tukša",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8687,"Experiment 1","LoadIniFile","NL2Bash",2,2,"#!/bin/bash;;# Define the path to the settings.ini file;SETTINGS_FILE=""settings.ini"";;# Read the settings.ini file and set the variables in the current shell;while IFS='=' read -r key value; do; key=$(echo ""$key"" | tr -d '[:space:]') # Remove spaces from the key; value=$(echo ""$value"" | tr -d '[:space:]') # Remove spaces from the value; if [[ $key && $value ]]; then; export ""$key""=""$value""; fi;done < ""$SETTINGS_FILE""",129,"2005.7566165924072","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*",1,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","25.95"
8289,"Experiment 1","MoveMarked","NL2Bash",2,1,"#!/bin/bash;;# Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs;;# Create the destination directory if it doesn't exist;mkdir -p /etc/movedDocs;;# Move the files;find /etc/docs -type f -name ""*.docx.found"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .found)' _ {} \;;find /etc/docs -type f -name ""*.docx"" -exec sh -c 'mv ""$1"" /etc/movedDocs/$(basename ""$1"" .docx)' _ {} \;",146,"2076.272964477539","0","0.1","gpt-3.5-turbo","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"All nessesary *.docx.found files were not moved",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","5.2"
5519,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done
for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",831,"21754.627227783203","0.2","0.4","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","29.4"
5187,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Use git to list ignored files and delete them git clean -fdX",57,"1755.662441253662","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","15.950000000000001"
7063,"Experiment 1","UpgradePostgres","IaC",3,1,"# Stop the PostgreSQL 16 service;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;apt install postgresql-17;;# Create a new data directory for PostgreSQL 17;pg_ctlcluster 17 main init;;# Use pg_upgrade to upgrade the data;pg_upgrade -b /usr/lib/postgresql/16/bin -B /usr/lib/postgresql/17/bin \;  -d /var/lib/postgresql/16/main -D /var/lib/postgresql/17/main \;  -o ' -c config_file=/etc/postgresql/16/main/postgresql.conf' \;  -O ' -c config_file=/etc/postgresql/17/main/postgresql.conf';;# Remove the old PostgreSQL 16 data directory;rm -rf /var/lib/postgresql/16/main;;# Start the PostgreSQL 17 service;systemctl start postgresql@17-main;;# Enable the PostgreSQL 17 service to start at boot;systemctl enable postgresql@17-main",207,"3189.4540786743164","0.2","0.4","llama3.3-70b","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","10.350000000000001"
9338,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home/*/public_html -type f -path '*/wp-includes/version.php' -print0 | while IFS= read -r -d '' file; do; version=$(grep -m1 ""^\\\$wp_version[[:space:]]*="" ""$file"" | awk -F""['\""]"" '{print $2}'); [[ -n ""$version"" ]] && echo ""Found: $version"";done",2389,"119767.51494407654","0","0.1","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.7"
5529,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",349,"24430.90319633484","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
6063,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[^[:space:]]/s/^/#/' settings.env",23,"1447.681188583374","0","0.1","gpt-3.5-turbo","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
7354,"Experiment 1","FindFilesModified","NL2Bash",1,1,"find /usr/info -type f -mtime +21",17,"1258.3253383636475","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta Apakšdirektorijā vēl viena datne, kas iekkļaujas diapozonā.",3,"",False,"A file modified 3 weeks ago was not found. Should be within 24 hours.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.55"
6210,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xzf archive.tar.gz",80,"8984.855651855469","0.7","0.9","deepseek-v3","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
8754,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"for i in {1..75}; do echo -n $((RANDOM%2)); done; echo",2157,"98997.11918830872","0.7","0.9","deepseek-r1","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",0,0,1,0,"Line 2: i appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Print a line of 75 random characters either *1* or *0*","3.7"
8775,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"head -c 75 /dev/urandom | tr -dc '01' | head -c 75; echo",31,"1552.7479648590088","0","0.1","gpt-3.5-turbo","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.55"
8771,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"cat /dev/urandom | tr -dc '01' | head -c 75; echo",26,"5465.815544128418","0.2","0.4","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",1,0,0,0,"Line 2: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","12.5","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.450000000000001"
8765,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"cat /dev/urandom | tr -dc '01' | fold -w 75 | head -n 1",32,"1660.9876155853271","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",1,0,0,0,"Line 2: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","12.5","","NO_RISK","Print a line of 75 random characters either *1* or *0*","10.55"
8851,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"ln -s /usr/src/*.java .",538,"4264.261484146118","1","1","o1-mini","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","1.45"
8855,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1350.1098155975342","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8773,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"cat /dev/urandom | tr -dc '01' | head -c 75; echo",26,"5864.726305007935","0.7","0.9","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",1,0,0,0,"Line 2: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","12.5","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.450000000000001"
8769,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"cat /dev/urandom | tr -dc '01' | head -c 75; echo",26,"5369.634389877319","0","0.1","deepseek-v3","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",1,0,0,0,"Line 2: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","12.5","","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.450000000000001"
8778,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"cat /dev/urandom | tr -dc '01' | fold -w 75 | head -n 1",31,"2256.9451332092285","0.7","0.9","gpt-3.5-turbo","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"",1,0,0,0,"Line 2: Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead. ","12.5","","NO_RISK","Print a line of 75 random characters either *1* or *0*","10.55"
8838,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"shopt -s nullglob
ln -sv /usr/src/*.java .",871,"41808.75611305237","0","0.1","deepseek-r1","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","2.8499999999999996"
8839,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"shopt -s nullglob
ln -sv /usr/src/*.java .",871,"41808.75611305237","0","0.1","deepseek-r1","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","2.8499999999999996"
8815,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '%*s\n' 87 | tr ' ' '='",453,"24730.743646621704","0","0.1","deepseek-r1","Jāizprintē rinda",1,"",False,"",0,0,1,0,"Line 2: This format string has 2 variables, but is passed 1 argument. ","11.0","","NO_RISK","Print a line of 87 *=* characters","5.800000000000001"
8836,"Experiment 1","PrintLine","NL2Bash",1,1,"echo ""=======================================================================================""",10,"1450.3886699676514","0.2","0.4","gpt-3.5-turbo","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.35"
8837,"Experiment 1","PrintLine","NL2Bash",1,1,"echo ""=======================================================================================""",10,"2053.9445877075195","0.7","0.9","gpt-3.5-turbo","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.35"
8835,"Experiment 1","PrintLine","NL2Bash",1,1,"echo ""=======================================================================================""",10,"1250.9269714355469","0","0.1","gpt-3.5-turbo","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","1.35"
8829,"Experiment 1","PrintLine","NL2Bash",1,1,"printf ""%*s\n"" 87 | tr ' ' '='",19,"1554.6138286590576","0.2","0.4","llama3.3-70b","Jāizprintē rinda",1,"",False,"",0,0,1,0,"Line 2: This format string has 2 variables, but is passed 1 argument. ","11.0","","NO_RISK","Print a line of 87 *=* characters","5.800000000000001"
5979,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1446.462869644165","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5980,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1446.462869644165","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8876,"Experiment 1","CreateSymlinks","NL2Bash",1,2,"cd /usr/src || exit
for file in *.java; do
 ln -s ""/usr/src/$file"" ""/path/to/current/directory/$file""
done",41,"1436.6545677185059","0.7","0.9","gpt-3.5-turbo","2 .java datnes, 1 cita veida",1,"ln: failed to create symbolic link '/path/to/current/directory/file1.java': No such file or directory ln: failed to create symbolic link '/path/to/current/directory/file2.java': No such file or directory ",False,"Required symlinks were not created",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","7.1"
8852,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1750.361442565918","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida",1,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8853,"Experiment 1","CreateSymlinks","NL2Bash",1,1,"for file in /usr/src/*.java; do ln -s *$file* . done",25,"1750.361442565918","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 .java datnes, 1 cita veida, apakšējā direktorijā papildus 1 java datne (kas nav jāiekļauj)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Create symlinks to all /usr/src/*.java files with the same name in current directory","3.45"
8827,"Experiment 1","PrintLine","NL2Bash",1,1,"printf ""%*s\n"" 87 | tr ' ' '='",19,"1452.9225826263428","0","0.1","llama3.3-70b","Jāizprintē rinda",1,"",False,"",0,0,1,0,"Line 2: This format string has 2 variables, but is passed 1 argument. ","11.0","","NO_RISK","Print a line of 87 *=* characters","5.800000000000001"
8580,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8888,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1050.0457286834717","0.7","0.9","gpt-4o","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8889,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1050.0457286834717","0.7","0.9","gpt-4o","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8884,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1354.537010192871","0","0.1","gpt-4o","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8885,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1354.537010192871","0","0.1","gpt-4o","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8890,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",302,"2656.9974422454834","1","1","o1-mini","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8891,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",302,"2656.9974422454834","1","1","o1-mini","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8896,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while read -r line; do echo *result = $(echo *$line* | rev)* done < info.txt",30,"1451.3578414916992","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8897,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while read -r line; do echo *result = $(echo *$line* | rev)* done < info.txt",30,"1451.3578414916992","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8878,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(rev <<< ""${line}"")""
done < info.txt",717,"34503.9963722229","0","0.1","deepseek-r1","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8908,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo ""result = $(rev <<<""$line"")""; done < info.txt",90,"7982.455253601074","0.7","0.9","deepseek-v3","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
5981,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",15,"1446.462869644165","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8581,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS== read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') export *$key=$value* done < <(grep -v '^#' settings.ini | grep '=')",70,"2452.3255825042725","0","0.1","qwen/qwen2.5-coder-32b-instruct","settings.ini satur 2 rindas, kas definē 2 mainīgos formātā *{var}={val}*, un nodaļas nosaukumu",2,"",False,"",0,0,0,1,"Line 2: Unexpected ==. For assignment, use =. For comparison, use [/[[. Or quote for literal string. ","10.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
8886,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1351.867914199829","0.2","0.4","gpt-4o","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8887,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"1351.867914199829","0.2","0.4","gpt-4o","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
8604,"Experiment 1","LoadIniFile","NL2Bash",2,1,"while IFS='=' read -r key value; do key=$(echo *$key* | tr -d '[:space:]') value=$(echo *$value* | tr -d '[:space:]') if [[ -n *$key* && ! *$key* =~ ^# ]]; then  export *$key=$value* fi done < settings.ini",83,"2454.1497230529785","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","24.800000000000004"
8935,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo pid,ppid,state | awk '$3 == ""Z"" {print $2}'); do; kill -9 $pid;done",42,"1464.7114276885986","0.2","0.4","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8936,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in ""$(ps -eo pid,ppid,state | awk '$3 == ""Z"" {print $2}')""; do; kill -9 ""$pid"";done",42,"1890.5668258666992","0.2","0.4","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,0,0,1,"Line 2: Since you double quoted this, it will not word split, and the loop will only run once. ","10.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8937,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo pid,ppid,state --no-headers | awk '$3 == ""Z"" {print $2}'); do; kill -9 $pid;done",46,"1485.8877658843994","0.7","0.9","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8938,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in ""$(ps -eo pid,ppid,state --no-headers | awk '$3 == ""Z"" {print $2}')""; do; kill -9 ""$pid"";done",46,"1583.5201740264893","0.7","0.9","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,0,0,1,"Line 2: Since you double quoted this, it will not word split, and the loop will only run once. ","10.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8933,"Experiment 1","CleanZombies","NL2Bash",3,1,"for pid in $(ps -eo pid,ppid,state | awk '$3 == ""Z"" {print $2}'); do; kill -9 $pid;done",42,"1587.5217914581299","0","0.1","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","12.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
8934,"Experiment 1","CleanZombies","NL2Bash",3,2,"for pid in ""$(ps -eo pid,ppid,state | awk '$3 == ""Z"" {print $2}')""; do; kill -9 ""$pid"";done",42,"1554.8429489135742","0","0.1","llama3.3-70b","2 procesi izsaukti no vecāka procesiem",1,"",False,"",0,0,0,1,"Line 2: Since you double quoted this, it will not word split, and the loop will only run once. ","10.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","3.4000000000000004"
6078,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^[[:space:]]*[^#]/ s/^\([^#]\)/#\1/' settings.env",31,"1146.3282108306885","0.7","0.9","gpt-3.5-turbo","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","10.625","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5994,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",16,"1950.90913772583","0.2","0.4","llama3.3-70b","settings.env ar vairākām rindām",1,"",True,"",0,0,0,0,"","9.875","","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5985,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,2,"sed -i '/^$/!s/^/#/' settings.env",18,"1344.9342250823975","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","10.25","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8904,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 reversed=$(echo ""$line"" | rev)
 echo ""result = $reversed""
done < info.txt",39,"5864.692211151123","0","0.1","deepseek-v3","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","7.65"
8912,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",37,"950.6838321685791","0.2","0.4","gpt-3.5-turbo","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8914,"Experiment 1","PrintBackwards","NL2Bash",2,1,"#!/bin/bash

while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",37,"1048.9766597747803","0.7","0.9","gpt-3.5-turbo","Info.txt ar 2 rindām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8948,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done < /dev/stdin
echo -e ""line1\nline2%line3"" | ./yourscript.sh
# $text will contain ""line1\nline2""",165,"12033.42056274414","0","0.1","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","14.100000000000001"
8909,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do echo ""result = $(rev <<<""$line"")""; done < info.txt",90,"7982.455253601074","0.7","0.9","deepseek-v3","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8939,"Experiment 1","CleanZombies","NL2Bash",3,1,"pkill -P 1 -9",14,"984.7066402435303","0","0.1","gpt-3.5-turbo","2 procesi izsaukti no vecāka procesiem",1,"",False,"Only zombie process direct parents should be killed",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","1.45"
8435,"Experiment 1","RemoveLastLines","NL2Bash",1,1,"head -n -5 data.md > data.md.tmp && mv data.md.tmp data.md",25,"7070.435285568237","0.2","0.4","deepseek-v3","data.md ar 10 rindām",1,"",True,"",0,0,0,0,"","13.0","","RISK","Remove last 5 lines from data.md","5.9"
5530,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",349,"24430.90319633484","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
8978,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash
IFS= read -r -d % text
echo ""$text"" # Demonstrate usage - remove if actually used elsewhere",372,"21630.234241485596","0.7","0.9","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
8960,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash;# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text;;# Demonstrate usage of the variable (replace with your actual logic);printf ""Captured text: %s\n"" ""$text"";#!/bin/bash;# shellcheck disable=SC2034;IFS='%' read -r -d '%' text",174,"12909.732818603516","0.7","0.9","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","4.4"
8949,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done < /dev/stdin
echo -e ""line1\nline2%line3"" | ./yourscript.sh
# $text will contain ""line1\nline2""",165,"12033.42056274414","0","0.1","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"/media/sf_scripts/StandartInputToVariable_deepseek-v3_0_0.1_2.sh: line 8: ./yourscript.sh: No such file or directory ",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","14.100000000000001"
5563,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1851.043462753296","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"/media/sf_scripts/RunAllScripts_gpt-3.5-turbo_0_0.1_2.sh: line 3: ./subdir.sh: Is a directory ",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
8976,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1323,"66192.3131942749","0.7","0.9","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8977,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d % text",1323,"66192.3131942749","0.7","0.9","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8963,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d '%' text",1201,"61956.7596912384","0","0.1","deepseek-r1","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8964,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d '%' text",1201,"61956.7596912384","0","0.1","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8981,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done",46,"2762.4239921569824","0","0.1","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
8982,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done",46,"2762.4239921569824","0","0.1","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
8999,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d '%' text",535,"3997.265100479126","1","1","o1-mini","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
9000,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d '%' text",535,"3997.265100479126","1","1","o1-mini","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
8965,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS= read -r -d '%' text",1201,"61956.7596912384","0","0.1","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
8967,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",699,"41403.97262573242","0","0.1","deepseek-r1","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
8968,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",699,"41403.97262573242","0","0.1","deepseek-r1","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
8994,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"read -d ""%"" text",11,"964.3082618713379","0.7","0.9","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",False,"",0,1,1,0,"Line 2: read without -r will mangle backslashes. Line 2: text appears unused. Verify use (or export if used externally). ","6.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.45"
8996,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d ""%"" text
echo ""$text""",19,"1053.830623626709","0.7","0.9","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
8997,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d ""%"" text
echo ""$text""",19,"1053.830623626709","0.7","0.9","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
9008,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1154.2763710021973","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
8998,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d ""%"" text
echo ""$text""",19,"1053.830623626709","0.7","0.9","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
9009,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1154.2763710021973","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
9010,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1154.2763710021973","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
6777,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

source_dir=""$1""
destination_dir=""$2""
shift 2

copy_from_source=true
delete_from_source=false
replace_in_destination=true
delete_existing_in_destination=false
swap_contents=false

while [[ $# -gt 0 ]]; do
 case ""$1"" in
 --sc) copy_from_source=true ;;
 --sd) delete_from_source=true ;;
 --dr) replace_in_destination=true ;;
 --dk) replace_in_destination=false ;;
 --dd) delete_existing_in_destination=true ;;
 --sw) swap_contents=true ;;
 *) echo ""Unknown option: $1"" ;;
 esac
 shift
done

if $swap_contents; then
 temp_dir=$(mktemp -d)
 mv ""${source_dir:?}/""* ""$temp_dir""
 mv ""${destination_dir:?}/""* ""$source_dir""
 mv ""${temp_dir:?}/""* ""$destination_dir""
 rmdir ""$temp_dir""
else
 if $delete_existing_in_destination; then
 rm -rf ""${destination_dir:?}/""*
 fi

 if $copy_from_source; then
 if $replace_in_destination; then
 cp -r ""${source_dir:?}/""* ""$destination_dir""
 else
 cp -rn ""${source_dir:?}/""* ""$destination_dir""
 fi
 fi

 if $delete_from_source; then
 rm -rf ""${source_dir:?}/""*
 fi
fi",304,"3517.74001121521","0","0.1","gpt-4o","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"cp: unrecognized option '--sw/*' Try 'cp --help' for more information. ",False,"A file was not removed (swapped) from destination (with --sw passed)",0,0,0,0,"","7.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","-1"
8983,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done",46,"2762.4239921569824","0","0.1","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
8984,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done < <(cat)",50,"2260.9050273895264","0","0.1","gpt-4o","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
8985,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done < <(cat)",50,"2260.9050273895264","0","0.1","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9007,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1168.5950756072998","0","0.1","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9014,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; printf *%s* *$char*; done; })",54,"1956.3944339752197","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
8816,"Experiment 1","PrintLine","NL2Bash",1,2,"printf '%*s\n' 87 '' | tr ' ' '='",496,"27106.677055358887","0","0.1","deepseek-r1","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","5.85"
9015,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; printf *%s* *$char*; done; })",54,"1956.3944339752197","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9023,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"2255.4848194122314","0","0.1","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9002,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",1118,"7076.842308044434","1","1","o1-mini","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
9003,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS= read -r -d '%' text;export text",1118,"7076.842308044434","1","1","o1-mini","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.85"
9011,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; echo -n *$char*; done; })",53,"1957.531452178955","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9012,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none | { while IFS= read -r -n1 char; do if [[ *$char* == *%* ]]; then break; fi; echo -n *$char*; done; })",53,"1957.531452178955","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9021,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1257.4739456176758","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
9022,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1257.4739456176758","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
9044,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '/%/{exit} {print}' /dev/stdin)",21,"855.025053024292","0","0.1","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9032,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"3365.6229972839355","0.2","0.4","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9024,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"2255.4848194122314","0","0.1","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9025,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"2255.4848194122314","0","0.1","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9026,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"1252.5160312652588","0","0.1","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9027,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"1252.5160312652588","0","0.1","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
7026,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres config to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database storedb;psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on storedb;psql -U postgres -d storedb -f init.sql;;# Create user public_view with password fox;psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema common_data for user public_view;psql -U postgres -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",249,"2657.862663269043","0.7","0.9","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.199999999999998"
9056,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '{ if ($0 ~ /%/) { print substr($0, 1, index($0, ""%"")-1); exit } else print $0 }')",42,"1254.0082931518555","0.7","0.9","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9046,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '/%/{exit} {print}' /dev/stdin)",21,"855.025053024292","0","0.1","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9034,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"3365.6229972839355","0.2","0.4","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9035,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 printf ""%s"" ""$char""
done)",59,"2156.024217605591","0.7","0.9","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","5.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9038,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",50,"1252.7878284454346","0.7","0.9","llama3.3-70b","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9039,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",50,"1252.7878284454346","0.7","0.9","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
8682,"Experiment 1","LoadIniFile","NL2Bash",2,1,"false",116,"1858.1738471984863","0","0.1","gpt-3.5-turbo","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var} = {val}*",2,"/media/sf_scripts/LoadIniFile_gpt-3.5-turbo_0_0.1.sh: line 9: export: `attempts = 3': not a valid identifier /media/sf_scripts/LoadIniFile_gpt-3.5-turbo_0_0.1.sh: line 9: export: `appname = test.exe': not a valid identifier ",False,"Variables were not set correctly. The equals sign may be surrounded by spaces",0,0,0,0,"","10.0","CONDITION_NOT_MET","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","21.35"
8257,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs;find /etc/docs -type f -name ""*.docx.found"" -exec mv {} /etc/movedDocs \; -exec mv {} | sed 's/\.found$//' /etc/movedDocs \;",60,"3181.941270828247","0.2","0.4","llama3.3-70b","Direktorijā 2 .docx .found ar atbilstošām *.docx datnēm, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne.",1,"find: sed: read error on /etc/movedDocs: Is a directory missing argument to `-exec' ",False,"All nessesary *.docx.found files were neither moved to /etc/movedDocs nor kept in /etc/docs",0,0,0,1,"Line 3: Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument. ","2.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","7.800000000000001"
5531,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",349,"24430.90319633484","0.7","0.9","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
9051,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n 1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",51,"1253.103494644165","0.2","0.4","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9058,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=$(awk '{ if ($0 ~ /%/) { print substr($0, 1, index($0, ""%"")-1); exit } else print $0 }')",42,"1254.0082931518555","0.7","0.9","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","-1"
9330,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Process each WordPress installation found;while IFS= read -r -d $'\0' wp_version_file; do; wp_version=$(awk -F\' '/^\$wp_version = / {print $2}' ""$wp_version_file""); echo ""Found: $wp_version"";done < <(find /home -type f -path '*/public_html/wp-includes/version.php' -print0)",220,"14861.340284347534","0.2","0.4","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
5512,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [[ -f ""$script"" ]]; then
 if bash ""$script"" &>/dev/null; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",419,"170708.0020904541","0","0.1","deepseek-r1","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","26.799999999999997"
5543,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2175.381898880005","0.2","0.4","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
8368,"Experiment 1","LongListReadPermission","NL2Bash",2,1,"find . -maxdepth 1 -type f -perm /u=r -ls",23,"6568.41778755188","0","0.1","llama3.3-70b","Direktorijā ir datne a tikai lasīšanas tiesībām īpašniekam, otra ar tikai izpildes, trešā ar maksimālajām tiesībām.",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Long list all the files in the current directory which have read permission to the owner","1.7"
6869,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","Noklusētais izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"The file with same name in the destination was not replaced with the one from source (with no flags passed)",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_PARTIALLY_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
5553,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ ! -d ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not a regular executable file)""
 fi
done",223,"13490.965366363525","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"Script names with spaces are not supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","79.1"
6870,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","“--sc” “--dr” izsaukums (datne un apakšdirektorija ar datni)",1,"",False,"",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
7027,"Experiment 1","SetupPostgres","IaC",2,2,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres config to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Change Postgres authentication method to md5;sed -i 's/peer/md5/' /etc/postgresql/13/main/pg_hba.conf;;# Restart Postgres service;service postgresql restart;;# Create database storedb;psql -U postgres -p 5433 -c ""CREATE DATABASE storedb;"";;# Run init.sql on storedb;psql -U postgres -p 5433 -d storedb -f init.sql;;# Create user public_view with password fox;psql -U postgres -p 5433 -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema common_data for user public_view;psql -U postgres -p 5433 -d storedb -c ""GRANT USAGE ON SCHEMA common_data TO public_view;"";psql -U postgres -p 5433 -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -p 5433 -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",322,"2680.1226139068604","0.7","0.9","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"sql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5433* failed: No such file or directory 	Is the server running locally and accepting connections on that socket? ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","18.649999999999995"
5222,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git clean -Xdf",1491,"20732.379913330078","0.2","0.4","deepseek-r1","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",True,"",0,0,0,0,"","9.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","1.4"
5208,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"grep -vE ""^#"" .gitignore | xargs -I {} find . -type f -path ""./{}"" -delete",33,"2176.192045211792","0.2","0.4","llama3.3-70b","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","6.2"
8762,"Experiment 1","PrintRandomLine","NL2Bash",2,1,"head -c 75 /dev/urandom | tr -dc '01'",23,"1358.6833477020264","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","5.85"
8763,"Experiment 1","PrintRandomLine","NL2Bash",2,2,"head -c 75 /dev/urandom | tr -dc '01' | fold -w 75",31,"1674.8292446136475","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Jāizprintē rinda ar nejaušām 0/1 kombinācijām",1,"",False,"The line was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a line of 75 random characters either *1* or *0*","8.25"
5555,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ ! -d ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not a regular executable file)""
 fi
done",223,"13490.965366363525","0.7","0.9","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","79.1"
9071,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process each record in the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_z2 && has_apples2) {; count_both++; } else if (!has_apples2) {; count_no_apples++; };};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",189,"12089.148998260498","0.7","0.9","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,1,0,"Line 4: count_both appears unused. Verify use (or export if used externally). Line 5: count_no_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
5536,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a regular file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",204,"13688.21406364441","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","65.25"
7017,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database ""storedb"";psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",257,"2566.1110877990723","0","0.1","llama3.3-70b","Lietotājām ir vajadzīga piekļuve tikai šobrīdējām tabulām",1,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.199999999999998"
6872,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 elif [ -d ""$file"" ]; then
 cp -r ""$file"" ""$DESTINATION""
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",379,"4101.380825042725","0.2","0.4","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,2,0,"Line 5: COPY appears unused. Verify use (or export if used externally). Line 39: Use *${var:?}* to ensure this never expands to /* . Line 59: Use *${var:?}* to ensure this never expands to /* . ","4.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","123.45000000000002"
9072,"Experiment 1","CountRecords","NL2Bash",3,1,"#!/bin/bash;;# Initialize counters;count_both=0;count_no_apples=0;;# Process each record in the compressed file;zcat records.gz | awk -v RS='****\n' -v FS='\n' ';{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i == ""Z=2"") has_z2 = 1; if ($i == ""apples=2"") has_apples2 = 1; }; if (has_z2 && has_apples2) {; count_both++; } else if (!has_apples2) {; count_no_apples++; };};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",189,"12089.148998260498","0.7","0.9","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,1,0,"Line 4: count_both appears unused. Verify use (or export if used externally). Line 5: count_no_apples appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.66"
9074,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' -v FS='\n' ';BEGIN {; count_both = 0; count_no_apples = 0;};{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i ~ /^Z=2$/) has_z2 = 1; if ($i ~ /^apples=2$/) has_apples2 = 1; }; if (has_z2 && has_apples2) count_both++; if (!has_apples2) count_no_apples++;};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",305,"19719.311475753784","0.7","0.9","deepseek-v3","records.gz visi ieraksta dati vienā rindā",1,"",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","9.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.140000000000001"
7379,"Experiment 1","FindFilesModified","NL2Bash",1,2,"find /usr/info -maxdepth 1 -type f -mtime 21",22,"5681.389808654785","0.2","0.4","llama3.3-70b","Direktorijā ir 2 datnes, viena iekļaujas diapozonā, otra ir nesenāk modificēta",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find files in the /usr/info folder which were modified modified three weeks ago","1.65"
9418,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -p'TEST' TEST_DB | gzip | ssh root@*$1* *gunzip | mysql -u TEST_USER -p'TEST' TEST_DB*",45,"1792.1044826507568","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
5775,"Experiment 1","FindShellCheckIssues","DevOps CI/CD",3,1,"#!/bin/bash

count=$(find . -maxdepth 1 -name ""*.sh"" -exec shellcheck --format=gcc {} + | grep -c ""warning:"")
echo ""Count warning: $count""",48,"1456.9919109344482","0.2","0.4","gpt-4o","2 skripti ar tikai warning līmeņa kļūdām",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Use ShellCheck to find total number of ""warning"" level errors in all the bash scripts in the current directory together. Output the result as ""Count warning: {count}""","2.6500000000000004"
8229,"Experiment 1","MoveMarked","NL2Bash",2,1,"mkdir -p /etc/movedDocs

for file in /etc/docs/*.docx.found; do
 mv ""$file"" /etc/movedDocs/
 corresponding=""${file%.found}""
 if [ -f ""$corresponding"" ]; then
 mv ""$corresponding"" /etc/movedDocs/
 fi
done",793,"5203.897714614868","1","1","o1-mini","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","6.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","15.950000000000001"
9332,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations under public_html in user home directories;find /home -type f -path '*/public_html/wp-includes/version.php' | while read -r version_file; do; # Extract the WordPress version from the version.php file; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; # Get the website path (two directories up from wp-includes); website_path=$(dirname ""$(dirname ""$version_file"")""); echo ""Found: $wp_version (in $website_path)""; fi;done",288,"18414.939403533936","0.7","0.9","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9076,"Experiment 1","CountRecords","NL2Bash",3,2,"#!/bin/bash;;zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' -v FS='\n' ';BEGIN {; count_both = 0; count_no_apples = 0;};{; has_z2 = 0; has_apples2 = 0; for (i=1; i<=NF; i++) {; if ($i ~ /^Z=2$/) has_z2 = 1; if ($i ~ /^apples=2$/) has_apples2 = 1; }; if (has_z2 && has_apples2) count_both++; if (!has_apples2) count_no_apples++;};END {; print ""Final counter value= "" count_both "" ; other= "" count_no_apples;}'",305,"19719.311475753784","0.7","0.9","deepseek-v3","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"",False,"",0,0,0,0,"","9.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.140000000000001"
5210,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,1,"git ls-files --others -z --exclude-standard | xargs -0 rm",22,"1451.4076709747314","0.7","0.9","llama3.3-70b","Vairākas ignorētas un neignorētas datnes, bet nav apakšdirektoriju",1,"",False,"A file was deleted that should not have been.",0,0,0,0,"","5.0","TOO_MUCH_DONE","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","5.9"
9048,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n 1 char; do
 text+=""$char""
 if [ ""$char"" = ""%"" ]; then
 break
 fi
done
echo ""$text""",51,"1153.3043384552002","0.2","0.4","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
6045,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2049.3037700653076","0.2","0.4","deepseek-v3","settings.env ar vairākām rindām, viena jau ir aizkomentēta",3,"",False,"Lines that are already commented out should not be commented out again.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
8231,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs;;find /etc/docs -type f -name '*.docx.found' | while IFS= read -r file; do; # Move the .docx.found file; mv ""$file"" /etc/movedDocs/; # Determine the corresponding .docx file; corresponding=""${file%.found}""; # Check if the corresponding .docx file exists and move it; if [ -f ""$corresponding"" ]; then; mv ""$corresponding"" /etc/movedDocs/; fi;done",1228,"7703.648567199707","1","1","o1-mini","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni.",2,"",True,"",0,0,0,0,"","8.0","","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
8232,"Experiment 1","MoveMarked","NL2Bash",2,2,"mkdir -p /etc/movedDocs;;find /etc/docs -type f -name '*.docx.found' | while IFS= read -r file; do; # Move the .docx.found file; mv ""$file"" /etc/movedDocs/; # Determine the corresponding .docx file; corresponding=""${file%.found}""; # Check if the corresponding .docx file exists and move it; if [ -f ""$corresponding"" ]; then; mv ""$corresponding"" /etc/movedDocs/; fi;done",1228,"7703.648567199707","1","1","o1-mini","Direktorijā 1 .docx .found ar atbilstošu *.docx datni, 1 *.docx datne bez atbilstošas found marķētas datnes, 1 .jpg datne. Apakšdirekorijā papildus 1 .docx .found ar atbilstošu *.docx datni un tādu pašu nosaukumu kā virsējā direktorijā.",3,"",False,"Files in subdirectories should have an equivalent subdirectory created in the destination directory. If they are copied flat, files with the same name will overwrite each other",0,0,0,0,"","8.0","TOO_MUCH_DONE","RISK","Move all *.docx.found files and their corresponding *.docx files under /etc/docs to /etc/movedDocs","28.499999999999996"
9098,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';{; has_apples_2 = match($0, /apples=2/); has_z_2 = match($0, /Z=2/); if (has_apples_2 && has_z_2) {; count_both++; }; if (!has_apples_2) {; count_no_apples++; };};END {; printf ""Final counter value= %d ; other= %d\n"", count_both, count_no_apples;};'",129,"2255.1169395446777","0.7","0.9","gpt-4o","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9092,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='\\*\\*\\*\\*\n' ';BEGIN { has_both=0; no_apples=0; };{; if ($0 ~ /apples=2/ && $0 ~ /Z=2/) {; has_both++;; } else if ($0 !~ /apples=2/) {; no_apples++;; };};END { print ""Final counter value= "" has_both "" ; other= "" no_apples; };'",114,"2158.99658203125","0","0.1","gpt-4o","records.gz visi ieraksta dati vienā rindā",1,"",True,"",0,0,0,0,"","13.0","","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","6.04"
9401,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C root@""$1"" ""mysqldump -u TEST_USER --password=TEST TEST_DB"" | mysql -u TEST_USER --password=TEST TEST_DB",827,"44219.84004974365","0.2","0.4","deepseek-r1","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
9104,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3459.446907043457","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9107,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = *****\n*; FS = *\n*; } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",238,"5384.242057800293","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.76"
9108,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = *****\n*; FS = *\n*; } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",238,"5384.242057800293","0","0.1","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.76"
8955,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"# Read stdin into variable 'text' until first '%' character, including newlines;text="""";while IFS= read -r -d '' -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",173,"11995.249032974243","0.2","0.4","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
9116,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",133,"3359.469413757324","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9111,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",135,"3457.7078819274902","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9113,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS = ******; FS = *\n*; counter = 0; other = 0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; else if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other; }'",242,"5487.3902797698975","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","13.04"
8957,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text",36,"5666.838884353638","0.7","0.9","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",False,"",0,0,1,0,"Line 3: text appears unused. Verify use (or export if used externally). ","11.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.5"
9117,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",133,"3359.469413757324","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās",2,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9118,"Experiment 1","CountRecords","NL2Bash",3,1,"zcat records.gz | awk -v RS='****\n' ' { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",133,"3359.469413757324","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz ierakstu dati var būt vairākās rindās un saturēt ****** vērtībās",3,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may contain **** as long as it isn't immediately followed by a newline",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","5.96"
9119,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk ' BEGIN { RS=******; FS=*\n*; counter=0; other=0 } { has_apples2 = 0; has_Z2 = 0; for (i = 1; i <= NF; i++) {  if ($i == *apples=2*) has_apples2 = 1;  if ($i == *Z=2*) has_Z2 = 1; } if (has_apples2 && has_Z2) counter++; if (!has_apples2) other++; } END { print *Final counter value= * counter * ; other= * other } '",245,"5788.65122795105","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","records.gz visi ieraksta dati vienā rindā",1,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","12.7"
6877,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: cannot stat '/usr/source/*': No such file or directory ",False,"A file was deleted from destination but not replaced with same name file in source (with --sd --dd passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
9334,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Search all home directories for WordPress installations;find /home -type d -name 'wp-content' | while read -r wp_content_dir; do; # Get the WordPress root directory (parent of wp-content); wp_root=$(dirname ""$wp_content_dir""); # Check for version.php in the expected location; version_file=""$wp_root/wp-includes/version.php""; if [[ -f ""$version_file"" ]]; then; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; echo ""Found: $wp_version (in $wp_root)""; fi; fi;done;;# Alternative check for wp-config.php if version.php isn't found;find /home -type f -name 'wp-config.php' | while read -r wp_config; do; wp_root=$(dirname ""$wp_config""); version_file=""$wp_root/wp-includes/version.php""; if [[ -f ""$version_file"" ]]; then; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; echo ""Found: $wp_version (in $wp_root)""; fi; fi;done",432,"25267.83061027527","0.7","0.9","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","83.39999999999999"
9404,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"{ echo -e ""[client]\nuser=TEST_USER\npassword=TEST""; } > ~/.my.cnf.tmp;chmod 600 ~/.my.cnf.tmp;ssh -C ""$1"" ""mysqldump --defaults-extra-file=/root/.my.cnf.tmp --no-tablespaces TEST_DB"" 2> >(grep -v 'Using a password' >&2) | mysql --defaults-extra-file=/root/.my.cnf.tmp TEST_DB;rm ~/.my.cnf.tmp",927,"47920.30072212219","0.7","0.9","deepseek-r1","jāpārnes datubāze",1,"mysqldump: [ERROR] Failed to open required defaults file: /root/.my.cnf.tmp mysqldump: [ERROR] Fatal error in defaults handling. Program aborted! ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","-1"
5537,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a regular file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",204,"13688.21406364441","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",False,"Script names with spaces are not supported.",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","65.25"
6878,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
9125,"Experiment 1","CountRecords","NL2Bash",3,2,"zcat records.gz | awk -v RS='****\n' '/Z=2/ && /apples=2/ {count++} !/apples=2/ {other++} END {print ""Final counter value="" count "" ; other="" other}' | sed '/^$/d'",68,"1558.4194660186768","0","0.1","llama3.3-70b","records.gz visi ieraksta dati vienā rindā",1,"awk: line 0: regular expression compile failed (missing operand) **** ",False,"Neither correct *Final counter value* nor *other* was outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","8.31"
7018,"Experiment 1","SetupPostgres","IaC",2,1,"# Install Postgres;apt install -y postgresql;;# Stop Postgres service;service postgresql stop;;# Edit Postgres configuration to use port 5433;sed -i 's/port = 5432/port = 5433/' /etc/postgresql/13/main/postgresql.conf;;# Start Postgres service;service postgresql start;;# Create database ""storedb"";psql -U postgres -c ""CREATE DATABASE storedb;"";;# Run init.sql on ""storedb"";psql -U postgres -d storedb -f init.sql;;# Create user ""public_view"" with password ""fox"";psql -U postgres -d storedb -c ""CREATE ROLE public_view WITH PASSWORD 'fox';"";;# Grant read-only access to schema ""common_data"" for user ""public_view"";psql -U postgres -d storedb -c ""GRANT SELECT ON SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""GRANT SELECT ON ALL TABLES IN SCHEMA common_data TO public_view;"";psql -U postgres -d storedb -c ""ALTER DEFAULT PRIVILEGES IN SCHEMA common_data GRANT SELECT ON TABLES TO public_view;""",257,"2566.1110877990723","0","0.1","llama3.3-70b","Lietotājām ir vajadzīga piekļuve šobrīdējām un nākotnes tabulām",2,"L.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* psql: error: connection to server on socket */var/run/postgresql/.s.PGSQL.5432* failed: FATAL: Peer authentication failed for user *postgres* ",False,"init.sql was not executed",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Install and setup Postgres to run on port 5433 with a database ""storedb"" and run init.sql on it (located in current directory), finally create a user ""public_view"" with password ""fox"" which has read only access to schema ""common_data"".","15.199999999999998"
9019,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"IFS=% read -r text",11,"1153.0234813690186","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,1,0,"Line 2: text appears unused. Verify use (or export if used externally). ","3.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.4"
9020,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"IFS=% read -r text _ echo *$text*",15,"1257.4739456176758","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","2.8"
6879,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
6880,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Error: Source and destination directories are required.""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$DESTINATION""
 fi
 done
 for file in ""$DESTINATION""/*; do
 if [ -f ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 elif [ -d ""$file"" ]; then
 mv ""$file"" ""$SOURCE""
 fi
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 if [ -f ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
 else
 if [ -f ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 elif [ -d ""$file"" ]; then
 if [ ""$COPY"" = true ]; then
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  cp -rf ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 cp -r ""$file"" ""$DESTINATION""
 fi
 else
 if [ -d ""$DESTINATION/$(basename ""$file"")"" ]; then
 if [ ""$REPLACE"" = true ]; then
  mv -f ""$file"" ""$DESTINATION""
 elif [ ""$KEEP"" = true ]; then
  continue
 fi
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",344,"4255.403995513916","0.7","0.9","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"A subdirectory was not moved to destination (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 38: Use *${var:?}* to ensure this never expands to /* . ","5.5","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","352.5"
9144,"Experiment 1","CountRecords","NL2Bash",3,2,"z_and_apples_counter=0;no_apples_counter=0;;# Count the number of records that contain both ""Z=2"" and ""apples=2"";z_and_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} /Z=2/ && /apples=2/ {count++} END{print count}');;# Count the number of records that do not contain ""apples=2"";no_apples_counter=$(zcat records.gz | awk 'BEGIN{RS=""****\n""} !/apples=2/ {count++} END{print count}');;echo ""Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}"";echo ""Final counter value= $z_and_apples_counter ; other= $no_apples_counter""",183,"2862.870693206787","0","0.1","gpt-3.5-turbo","records.gz ierakstu dati var būt vairākās rindās",2,"awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 awk: run time error: regular expression compile failed (missing operand) **** 	FILENAME=** FNR=0 NR=0 ",False,"Neither correct *Final counter value* nor *other* was outputted. Records may span multiple lines",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Count the number of times that a single *****\n* separated record contains both *Z=2* and *apples=2* and the number of records that do not have *apples=2* in compressed file *records.gz*. Output in the format *Final counter value= {has apples=2 and Z=2} ; other= {doesn't have apples=2}*","7.9"
9182,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"fdupes -r /usr/files | awk -v RS= '{$1=$1}1' OFS=' '",4018,"191226.31740570068","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"Building file list - Building file list \ Building file list | Building file list / Building file list - Building file list \ Building file list | Building file list / Building file list - Progress [0/8] 0% Progress [1/8] 12% Progress [2/8] 25% Progress [3/8] 37% Progress [4/8] 50% Progress [5/8] 62% Progress [6/8] 75% Progress [7/8] 87%      ",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.960000000000001"
9425,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh -i /path/to/private_key $1 'gunzip | mysql -u TEST_USER -pTEST TEST_DB'",46,"1557.9793453216553","0","0.1","gpt-3.5-turbo","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.3"
8951,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read stdin into variable 'text' until first '%' character;text="""";while IFS= read -r -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",175,"11791.301250457764","0.2","0.4","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
8952,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"# Read stdin into variable 'text' until first '%' character;text="""";while IFS= read -r -n1 char; do; if [[ ""$char"" == ""%"" ]]; then; break; fi; text+=""$char"";done",175,"11791.301250457764","0.2","0.4","deepseek-v3","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
9423,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip -c | gzip -dc | mysql -u TEST_USER -pTEST TEST_DB",43,"3569.3187713623047","0.7","0.9","llama3.3-70b","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","10.6"
8962,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"#!/bin/bash;# Read standard input into variable 'text' until the first '%' character is encountered;IFS='%' read -r -d '%' text;;# Demonstrate usage of the variable (replace with your actual logic);printf ""Captured text: %s\n"" ""$text"";#!/bin/bash;# shellcheck disable=SC2034;IFS='%' read -r -d '%' text",174,"12909.732818603516","0.7","0.9","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","4.4"
9049,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n 1 char; do
 text+=""$char""
 if [ ""$char"" = ""%"" ]; then
 break
 fi
done
echo ""$text""",51,"1153.3043384552002","0.2","0.4","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","6.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9387,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all Wordpress installations under users' public_html directories;wp_sites=$(find /home/*/public_html/ -name wp-includes -type d 2>/dev/null);;# Loop through each Wordpress installation and extract the version;for site in $wp_sites; do; version=$(grep ""wp_version = "" $site/version.php 2>/dev/null | cut -d""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",117,"4264.639616012573","0.2","0.4","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"",0,1,0,0,"Line 8: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.399999999999999"
9392,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations under users' home directories;find /home/*/public_html -name wp-includes -type d | while read -r wp_dir; do; version=$(grep 'wp_version =' ""$wp_dir/version.php"" 2>/dev/null | cut -d ""'"" -f 2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",131,"1752.5641918182373","0.7","0.9","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.65"
9354,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",52,"1551.5737533569336","0.7","0.9","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
5538,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 else
 echo ""${script}: SKIP (not executable or not a regular file)""
 fi
done
for script in *.sh; do
 if [ -f ""$script"" ] && [ -x ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",204,"13688.21406364441","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","65.25"
9052,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n 1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=""$char""
done
echo ""$text""",51,"1253.103494644165","0.2","0.4","gpt-3.5-turbo","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
8881,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 reversed=$(printf ""%s"" ""$line"" | rev)
 printf ""result = %s\n"" ""$reversed""
done < info.txt",1329,"60973.99067878723","0.2","0.4","deepseek-r1","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","7.699999999999999"
9161,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files and group by size first (optimization);find /usr/files -type f -printf ""%s\n"" | sort -n | uniq -d > ""$tmpdir/duplicate_sizes"";;# For each duplicate size, find and compare files;while read -r size; do; # Create checksum file for this size group; checksum_file=""$tmpdir/checksums_$size""; touch ""$checksum_file""; # Process all files of this size; find /usr/files -type f -size ""${size}c"" -print0 | while IFS= read -r -d '' file; do; # Get full checksum (not just first bytes); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Get device and inode to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Store file path with unique identifier; echo ""$file"" >> ""$tmpdir/${checksum}_${device}_${inode}""; done;done < ""$tmpdir/duplicate_sizes"";;# Output groups of identical files;find ""$tmpdir"" -type f -name ""*_*_*"" | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Replace newlines with spaces; files=$(tr '\n' ' ' < ""$group""); # Remove trailing space and print; echo ""${files% }""; fi;done",530,"28048.431634902954","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,1,0,"Line 32: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","73.25"
8901,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(echo ""$line"" | rev)""
done < info.txt",34,"2356.656789779663","0.2","0.4","llama3.3-70b","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","5.35"
5562,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -x ""$script"" ]; then
 if ./""$script""; then
 echo ""$script: OK""
 else
 echo ""$script: FAIL""
 fi
 fi
done",58,"1851.043462753296","0","0.1","gpt-3.5-turbo","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā vēl viens skripts (kuru nevajadzētu izpildīt)",2,"",False,"A succesful script was skipped",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","18.45"
8945,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",154,"11547.940254211426","0","0.1","deepseek-v3","teksts vienā rindā, kam pa vidu %",1,"",True,"",0,0,0,0,"","7.0","","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
9351,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",49,"1750.429391860962","0.2","0.4","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9352,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",49,"1750.429391860962","0.2","0.4","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
8907,"Experiment 1","PrintBackwards","NL2Bash",2,1,"while IFS= read -r line; do
 echo ""result = $(rev <<< ""$line"")""
done < info.txt",33,"6869.713306427002","0.2","0.4","deepseek-v3","Info.txt ar 3 rindām, viena pa vidu - tukša",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","For each line in *info.txt*, print *result = * followed by the line backwards.","-1"
8947,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",154,"11547.940254211426","0","0.1","deepseek-v3","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
9170,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;;# Create a temporary directory for storing file information;tmpdir=$(mktemp -d);;# Find all files in /usr/files and its subdirectories;find /usr/files -type f -print0 | while IFS= read -r -d $'\0' file; do; # Get inode and device to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Get file size and first few bytes as checksum; size=$(stat -c '%s' ""$file""); checksum=$(head -c 1024 ""$file"" | md5sum | cut -d' ' -f1); # Create a unique identifier combining device, inode, size and partial checksum; id=""${device}:${inode}:${size}:${checksum}""; # Append file path to the identifier's record; echo ""$file"" >> ""$tmpdir/$id"";done;;# Output files with identical identifiers (including hard links);for idfile in ""$tmpdir""/*; do; # Only show groups with more than one file; if [ $(wc -l < ""$idfile"") -gt 1 ]; then; # Replace newlines with spaces; tr '\n' ' ' < ""$idfile""; echo # Add newline after each group; fi;done;;# Clean up;rm -rf ""$tmpdir""",499,"26644.14930343628","0.7","0.9","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,1,0,"Line 26: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9163,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"#!/bin/bash;;# Create temporary directory;tmpdir=$(mktemp -d);trap 'rm -rf ""$tmpdir""' EXIT;;# Find all files and group by size first (optimization);find /usr/files -type f -printf ""%s\n"" | sort -n | uniq -d > ""$tmpdir/duplicate_sizes"";;# For each duplicate size, find and compare files;while read -r size; do; # Create checksum file for this size group; checksum_file=""$tmpdir/checksums_$size""; touch ""$checksum_file""; # Process all files of this size; find /usr/files -type f -size ""${size}c"" -print0 | while IFS= read -r -d '' file; do; # Get full checksum (not just first bytes); checksum=$(md5sum ""$file"" | cut -d' ' -f1); # Get device and inode to identify hard links; inode=$(stat -c '%i' ""$file""); device=$(stat -c '%d' ""$file""); # Store file path with unique identifier; echo ""$file"" >> ""$tmpdir/${checksum}_${device}_${inode}""; done;done < ""$tmpdir/duplicate_sizes"";;# Output groups of identical files;find ""$tmpdir"" -type f -name ""*_*_*"" | while read -r group; do; # Only show groups with more than one file; if [ $(wc -l < ""$group"") -gt 1 ]; then; # Replace newlines with spaces; files=$(tr '\n' ' ' < ""$group""); # Remove trailing space and print; echo ""${files% }""; fi;done",530,"28048.431634902954","0","0.1","deepseek-v3","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",False,"All duplicates weren't found. Duplicates may exist in different directories",0,0,1,0,"Line 32: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","73.25"
9047,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=""""
while IFS= read -r -n 1 char; do
 text+=""$char""
 if [ ""$char"" = ""%"" ]; then
 break
 fi
done
echo ""$text""",51,"1153.3043384552002","0.2","0.4","gpt-3.5-turbo","teksts vienā rindā, kam pa vidu %",1,"",False,"The *%* character itself should not be included in the variable",0,0,0,0,"","6.0","CONDITION_PARTIALLY_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9382,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user"" ]; then; for file in ""$user/public_html/wp-includes/version.php""; do; if [ -f ""$file"" ]; then; version=$(grep '$wp_version' ""$file"" | cut -d ""'"" -f2); echo ""Found: $version""; fi; done; fi;done",91,"1858.039140701294","0.7","0.9","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,1,0,1,"Line 4: Since you double quoted this, it will not word split, and the loop will only run once. Line 6: Expressions don't expand in single quotes, use double quotes for that. ","1.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","29.55"
9176,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash;fdupes -Hr /usr/files | awk -v RS= '{gsub(/\n/, "" ""); print}'",4733,"223667.86742210388","0","0.1","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
8833,"Experiment 1","PrintLine","NL2Bash",1,1,"printf '=%.0s' {1..87} && echo",19,"5367.19536781311","0.2","0.4","deepseek-v3","Jāizprintē rinda",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a line of 87 *=* characters","3.7"
9266,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ';FNR == NR {; key = $1; rest = substr($0, index($0, "" "") + 1); if (key in merged) {; merged[key] = merged[key] "" "" rest; } else {; merged[key] = $0; }; next;};{; key = $1; rest = substr($0, index($0, "" "") + 1); if (key in merged) {; merged[key] = merged[key] "" "" rest; } else {; merged[key] = $0; };};END {; # Print lines starting with ""Exe"" first; for (key in merged) {; if (key ~ /^Exe/) {; print merged[key]; delete merged[key]; }; }; # Print remaining lines; for (key in merged) {; print merged[key]; };}' GHJ1.txt GHJ2.txt",7729,"363004.57286834717","0.2","0.4","deepseek-r1","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","14.049999999999999"
4891,"Experiment 1","FindInJSON","Ikdienas uzdevumu automatizācija",3,2,"#!/bin/bash;;# Extract all ""user"" values from JSON files in the current directory;users=$(grep -hoP '""user""\s*:\s*""\K[^""]+' ./*.json | sort | uniq);;# Check if any users were found;if [[ -z ""$users"" ]]; then; echo ""No users found"";else; # Format the users into a comma-separated list; user_list=$(echo ""$users"" | tr '\n' ',' | sed 's/,$//'); echo ""Here are the users: $user_list"";fi",240,"9372.568607330322","0.7","0.9","deepseek-v3","Viena datne are 1 korektu json ar lietotājiem un otru nekorekta formāta, bet līdzīgu json (arī ar lietotājiem)",3,"",False,"The script should only search in valid format JSON.",0,0,0,0,"","7.5","CONDITION_PARTIALLY_MET","NO_RISK","In the current directory, find json data in files with ""user"" keys and print out their corresponding values alphabetically (they will be strings) in the format ""Here are the users: {user_1}, {user_2} … {user_n)"". If there are no users print ""No users found""","11.750000000000002"
8988,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",50,"1254.2734146118164","0.2","0.4","gpt-4o","teksts vairākās rindās, kam pa vidu %",2,"",False,"The input may contain new lines, the whole text should be saved untill *%* is hit",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
9378,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user/public_html"" ]; then; version=$(grep -oP 'Version: \K[0-9\.]+' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",88,"1755.6450366973877","0.2","0.4","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","21.549999999999997"
9185,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"fdupes -rq /usr/files | awk -v RS= '{gsub(/\n/, "" "")} NR>1 {print """"} {printf ""%s"", $0} END {print """"}'",1977,"98565.35053253174","0.7","0.9","deepseek-r1","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"Hardlink duplicates weren't found",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","5.91"
9188,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -printf '%i %p\n' | sort -k1,1 | awk '{; if ($1 == prev_inode) {; printf ""%s "", $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_inode = $1;} END { if (NR > 0) print """" }' | while read -r line; do; files=($line); if [ ${#files[@]} -gt 1 ]; then; echo ""${files[@]}""; fi;done",134,"2756.504774093628","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,1,0,"Line 11: Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","-1"
9267,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ';FNR == NR {; file1[$1] = substr($0, index($0, "" "") + 1); next;};{; file2[$1] = substr($0, index($0, "" "") + 1);};END {; # Merge lines where key exists in both files; for (key in file1) {; if (key in file2) {; merged[key] = key "" "" file1[key] "" "" file2[key]; } else {; merged[key] = key "" "" file1[key]; }; }; # Add keys only in file2; for (key in file2) {; if (!(key in file1)) {; merged[key] = key "" "" file2[key]; }; }; # Print ""Exe"" lines first, then others; PROCINFO[""sorted_in""] = ""@ind_str_asc""; for (key in merged) {; if (key ~ /^Exe/) print merged[key]; }; for (key in merged) {; if (key !~ /^Exe/) print merged[key]; };}' GHJ1.txt GHJ2.txt",3020,"145905.60793876648","0.2","0.4","deepseek-r1","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","16.53"
5142,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git stash
git merge -X ours origin/develop
git stash pop",30,"952.3370265960693","0.2","0.4","gpt-3.5-turbo","Lokālajā repozitorijā “develop” zarā ir nesaglabātas izmaiņas (kurām būtu jāveic stash un tās jāatjauno)",3,"From file:///usr/git_server * branch  develop -> FETCH_HEAD b1efe32..6d20947 develop -> origin/develop Already on 'develop' ",False,"After running the script, the file content is incorrect. Neither local changes have been preserved, not remote changes have been pulled.",0,0,0,0,"","9.5","CONDITION_NOT_MET","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","7.1"
9191,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -printf '%s %p\n' | sort -k1,1 | awk '{; if ($1 == prev_size) {; print $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_size = $1;}' | xargs -I{} -d '\n' sh -c '; for file in ""$@""; do; md5sum ""$file""; done | sort | awk ""{print \$2}"" | uniq -d;' sh {} | while read -r file; do; find /usr/files -type f -exec md5sum {} + | grep ""$(md5sum ""$file"" | cut -d"" "" -f1)"" | awk '{print $2}' | tr '\n' ' ' | sed 's/ $/\n/';done",195,"5384.1540813446045","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"md5sum: '/usr/files/file1copy1.txt /usr/files/file1copy2.txt': No such file or directory ",False,"All duplicates weren't found",0,1,0,0,"Lines 10 - 14: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","44.03"
9373,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user/public_html"" ]; then; version=$(grep -oP '(?<=wp_version=)[^;]*' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",88,"1660.6669425964355","0","0.1","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9192,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -printf '%s %p\n' | sort -k1,1 | awk '{; if ($1 == prev_size) {; print $2; } else {; if (NR > 1) print """"; printf ""%s "", $2; }; prev_size = $1;}' | xargs -I{} -d '\n' sh -c '; for file in ""$@""; do; md5sum ""$file""; done | sort | awk ""{print \$2}"" | uniq -d;' sh {} | while read -r file; do; find /usr/files -type f -exec md5sum {} + | grep ""$(md5sum ""$file"" | cut -d"" "" -f1)"" | awk '{print $2}' | tr '\n' ' ' | sed 's/ $/\n/';done",195,"5384.1540813446045","0","0.1","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"md5sum: '/usr/files/file1copy1.txt /usr/files/file1copy2.txt': No such file or directory ",False,"All duplicates weren't found",0,1,0,0,"Lines 10 - 14: Expressions don't expand in single quotes, use double quotes for that. ","4.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","44.03"
9206,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2556.0412406921387","0","0.1","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
9207,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2556.0412406921387","0","0.1","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
9264,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a1 -a2 -1 1 -2 1 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | awk '; $1 ~ /^Exe/ { exe[++n] = $0; next }; { non_exe[++m] = $0 }; END {; for (i=1; i<=n; i++) print exe[i]; for (i=1; i<=m; i++) print non_exe[i]; }'",5365,"251322.01600074768","0","0.1","deepseek-r1","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
8461,"Experiment 1","SetSGID","NL2Bash",3,2,"find ""$1/.sn"" -mindepth 1 -type d -exec chmod g+s {} +",27,"958.6553573608398","0.2","0.4","gpt-4o","$1 tiek padots ceļš uz direktoriju, kur ir 2 apakšdirektorijas bez uzstādīta SGID, 1 datne bez uzstādīta SGID",1,"",True,"",0,0,0,0,"","13.0","","RISK","Find all directories under $1/.sn and set their SGID bit","1.8"
9200,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | awk '{; files[$1] = files[$1] ? files[$1] "" "" $2 : $2;} END {; for (hash in files) {; split(files[hash], arr, "" ""); if (length(arr) > 1) {; print files[hash]; }; };}'",91,"2176.6021251678467","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.32"
9201,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | awk '{; files[$1] = files[$1] ? files[$1] "" "" $2 : $2;} END {; for (hash in files) {; split(files[hash], arr, "" ""); if (length(arr) > 1) {; print files[hash]; }; };}'",91,"2176.6021251678467","0.7","0.9","gpt-4o","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","10.32"
8989,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"#!/bin/bash

text=""""
while IFS= read -r -n1 char; do
 if [[ ""$char"" == ""%"" ]]; then
 break
 fi
 text+=""$char""
done",50,"1254.2734146118164","0.2","0.4","gpt-4o","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","10.4"
5435,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1668.386697769165","0.2","0.4","gpt-4o","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"subdir.sh: subdir.sh: Is a directory ",False,"The script attempted to execute a directory.",0,0,0,0,"","10.625","MINOR_SIDE_EFFECT","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
9212,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | paste -sd' ' - | sed '/^$/d'",67,"2156.141996383667","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","19.549999999999997"
9213,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | paste -sd' ' - | sed '/^$/d'",67,"2156.141996383667","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","19.549999999999997"
9214,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | paste -sd' ' - | sed '/^$/d'",67,"2156.141996383667","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","19.549999999999997"
9208,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2556.0412406921387","0","0.1","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
7181,"Experiment 1","HostHtml","IaC",1,1,"echo ""server {
 listen 80;
 server_name example.com;

 location / {
 root /usr/html;
 index index.html;
 }
}"" > /etc/nginx/sites-available/default

nginx -t
service nginx restart",54,"1665.6432151794434","0.7","0.9","llama3.3-70b","index.html patstāvīgs",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Using nginx host index.html file located at /usr/html/","4.15"
9209,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2457.5424194335938","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
9210,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2457.5424194335938","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
9211,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"#!/bin/bash cd /usr/files || exit find . -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | awk '{print $2}' | xargs -I {} find {} -samefile {} | paste -sd ' ' - | sed 's/ $/\n/'",81,"2457.5424194335938","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link, duplikāti var atrasties apakšdirektorijās",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","22.2"
9258,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;exe_line="""";;# Read GHJ1.txt and store data;while read -r line; do; if [[ $line == Exe* ]]; then; exe_line=$line; else; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$(echo ""$line"" | awk '{$1=""""; print substr($0,2)}'); fi;done < GHJ1.txt;;# Read GHJ2.txt and store data;while read -r line; do; if [[ $line == Exe* ]]; then; continue # Skip Exe line in second file; fi; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$(echo ""$line"" | awk '{$1=""""; print substr($0,2)}');done < GHJ2.txt;;# Print the table header (Exe line from first file);[[ -n ""$exe_line"" ]] && echo ""$exe_line"";;# Print merged data;# First print keys that exist in both files;for key in ""${!file1_data[@]}""; do; if [[ -n ""${file2_data[$key]}"" ]]; then; echo ""$key ${file1_data[$key]} ${file2_data[$key]}""; fi;done;;# Then print keys that only exist in file1;for key in ""${!file1_data[@]}""; do; if [[ -z ""${file2_data[$key]}"" ]]; then; echo ""$key ${file1_data[$key]}""; fi;done;;# Finally print keys that only exist in file2;for key in ""${!file2_data[@]}""; do; if [[ -z ""${file1_data[$key]}"" ]]; then; echo ""$key ${file2_data[$key]}""; fi;done",602,"30857.17248916626","0.2","0.4","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5019,"Experiment 1","PullChangesFromGit","DevOps CI/CD",2,2,"git fetch origin develop
git checkout develop
git merge -X ours origin/develop",23,"2883.445978164673","0","0.1","llama3.3-70b","Lokālajā repozitorijā ir commit, kas rada konfliktus",1,"",True,"",0,0,0,0,"","9.5","","RISK","Pull changes from the ""develop"" branch of remote origin GIT repositry, to the same name branch in the current directory's repository. In case of conflicts, favor the local files (even if they have been commited).","4.35"
9256,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt and store data (skip Exe line);while read -r line; do; if [[ $line == Exe* ]]; then; exe_line=$line; else; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$line; fi;done < GHJ1.txt;;# Read GHJ2.txt and store data;while read -r line; do; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$line;done < GHJ2.txt;;# Print the table header (Exe line);echo ""$exe_line"";;# Print merged data;for key in ""${!file1_data[@]}""; do; if [[ -n ""${file2_data[$key]}"" ]]; then; # Merge lines when key exists in both files; line1=""${file1_data[$key]}""; line2=""${file2_data[$key]}""; echo ""$line1 $line2"" | awk '{; printf ""%s "", $1; for (i=2;i<=NF;i++) if ($i != $1) printf ""%s "", $i; print """"; }' | sed 's/ $//'; else; # Just print line from file1 if no match in file2; echo ""${file1_data[$key]}""; fi;done;;# Print lines from file2 that weren't in file1;for key in ""${!file2_data[@]}""; do; if [[ -z ""${file1_data[$key]}"" ]]; then; echo ""${file2_data[$key]}""; fi;done",533,"29460.139751434326","0.2","0.4","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","69.96000000000001"
9374,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"for user in /home/*; do; if [ -d ""$user/public_html"" ]; then; version=$(grep -oP '(?<=wp_version=)[^;]*' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",88,"1660.6669425964355","0","0.1","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9218,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep -F ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",94,"5108.40368270874","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"md5sum: {}: No such file or directory ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.049999999999997"
9219,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | xargs -I {} find /usr/files -type f -print0 | xargs -0 md5sum | grep -F ""$(md5sum ""{}"" | cut -d' ' -f1)"" | cut -d' ' -f2-",94,"5108.40368270874","0","0.1","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"md5sum: {}: No such file or directory ",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","21.049999999999997"
9030,"Experiment 1","StandartInputToVariable","NL2Bash",1,1,"text=$(dd bs=1 count=1 status=none; while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done)",57,"1655.2555561065674","0.2","0.4","llama3.3-70b","teksts vairākās rindās, kam pa vidu %",2,"",False,"The variable was not set to the required value",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","1.3"
9236,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1382.2050094604492","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
9227,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,1,"find /usr/files -type f -exec md5sum {} \; | sort | uniq -w 32 -d | awk '{print $2}' | xargs -n 1 -I {} find /usr/files -type f -exec md5sum {} \; | grep $(md5sum {} | cut -d' ' -f1) | cut -d' ' -f2- | tr '\n' ' '",96,"1951.2505531311035","0.7","0.9","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 find: ‘md5sum’ terminated by signal 13 ",False,"All duplicates weren't found",0,0,1,0,"Line 2: Quote this to prevent word splitting. ","3.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","18.999999999999996"
9260,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$line; fi;done < GHJ1.txt;;# Read GHJ2.txt;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$line; fi;done < GHJ2.txt;;# Print header;printf ""%-20s %-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"" ""Combined"";;# Process and print matching lines;for key in ""${!file1_data[@]}""; do; if [[ -n ${file2_data[$key]} ]]; then; # If line starts with ""Exe"", print it first; if [[ $key == ""Exe"" ]]; then; printf ""%-20s %-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}"" ""${file1_data[$key]} ${file2_data[$key]#* }""; fi; fi;done;;# Then print the rest;for key in ""${!file1_data[@]}""; do; if [[ -n ${file2_data[$key]} && $key != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}"" ""${file1_data[$key]} ${file2_data[$key]#* }""; fi;done",567,"28867.952585220337","0.7","0.9","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","65.35000000000001"
6230,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1045.0496673583984","0.2","0.4","gpt-3.5-turbo","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6043,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2049.3037700653076","0.2","0.4","deepseek-v3","settings.env ar tukšām rindām (kuras nevajadzētu komentēt)",2,"",False,"Empty lines should not be commented out.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
9224,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -print0 | xargs -0 md5sum | sort | uniq -w 32 -d | awk '{print $2}' | tr '\n' ' '",47,"3274.9226093292236","0.2","0.4","llama3.3-70b","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link",1,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","13.6"
9359,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for dir in /home/*/public_html; do; version_file=""$dir/wp-includes/version.php""; if [ -f ""$version_file"" ]; then; version=$(grep ""\$wp_version"" ""$version_file"" | awk -F""'"" '{print $2}'); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",2471,"19643.203020095825","1","1","o1-mini","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.849999999999998"
9028,"Experiment 1","StandartInputToVariable","NL2Bash",1,2,"text=""""
while IFS= read -r -n1 char; do
 if [ ""$char"" = ""%"" ]; then
 break
 fi
 text+=$char
done
echo ""$text""",50,"1252.5160312652588","0","0.1","llama3.3-70b","teksts vairākās rindās, kam pa vidu %, tieši pirms % ir atstarpe",3,"",False,"The variable was not set to the required value",0,0,0,0,"","7.0","CONDITION_NOT_MET","NO_RISK","Save standard input to variable *text* until the first character encoded as *%* is read","11.75"
9262,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file2_data;declare -a file1_order;;# First read GHJ2.txt into an associative array;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=""${line#* }"" # Store everything after first field; fi;done < GHJ2.txt;;# Then read GHJ1.txt, keeping order and processing matches;printf ""%-10s %-15s %-15s %-15s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"" ""Merged"";while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file1_order+=(""$key"") # Maintain original order; if [[ -n ${file2_data[$key]} ]]; then; # Special case: Exe line should be first; if [[ $key == ""Exe""* ]]; then; exe_line=""$key ${line#* } ${file2_data[$key]}""; else; # Store other lines for later printing; other_lines+=(""$key ${line#* } ${file2_data[$key]}""); fi; fi; fi;done < GHJ1.txt;;# Print Exe line first if it exists;if [[ -n $exe_line ]]; then; printf ""%-10s %-15s %-15s %-15s\n"" ""Exe"" ""${exe_line%% *}"" ""${file2_data[Exe]}"" ""$exe_line"";fi;;# Print other lines in original order;for line in ""${other_lines[@]}""; do; key=$(echo ""$line"" | awk '{print $1}'); printf ""%-10s %-15s %-15s %-15s\n"" ""$key"" ""${line#* }"" ""${file2_data[$key]}"" ""$line"";done",657,"33271.12174034119","0.7","0.9","deepseek-v3","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9286,"Experiment 1","PrintTable","NL2Bash",3,2,"join -j1 -a1 -a2 -e """" -o 0,1.2,1.3,2.2,2.3 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | \;awk '{ if ($1 ~ /^Exe/) print ""1 "" $0; else print ""2 "" $0 }' | \;sort -n | cut -d' ' -f2- | column -t",1851,"10486.24873161316","1","1","o1-mini","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9237,"Experiment 1","FindIdenticalAndHardLinks","NL2Bash",3,2,"find /usr/files -type f -exec md5sum {} + | sort | uniq -D -w32 --all-repeated=separate | cut -c35-",41,"1382.2050094604492","0","0.1","gpt-3.5-turbo","/usr/files atrodas vairākas identisku datņu grupas tai skaitā hard link un symlink (soft link)",2,"",False,"All duplicates weren't found",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Find all identical files in the /usr/files directory and subdirectories including if there are hard links. Output a list of identical files with identical files in space separated lines","8.75"
9273,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt; grep -v '^Exe' GHJ1.txt | awk '{print $1, $0}' > temp1.txt; grep -v '^Exe' GHJ2.txt | awk '{print $1, $0}' > temp2.txt;; join -j 1 temp1.txt temp2.txt | awk '{$1=""""; print $0}';} | column -t;;rm temp1.txt temp2.txt",104,"2408.034086227417","0","0.1","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","6.75"
5499,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"1854.6984195709229","0.2","0.4","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), apakšdirektorijā, kuras nosaukums beidzas ar “.sh”, vēl viens skripts (kuru nevajadzētu izpildīt)",3,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
9259,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$line; fi;done < GHJ1.txt;;# Read GHJ2.txt;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$line; fi;done < GHJ2.txt;;# Print header;printf ""%-20s %-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"" ""Combined"";;# Process and print matching lines;for key in ""${!file1_data[@]}""; do; if [[ -n ${file2_data[$key]} ]]; then; # If line starts with ""Exe"", print it first; if [[ $key == ""Exe"" ]]; then; printf ""%-20s %-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}"" ""${file1_data[$key]} ${file2_data[$key]#* }""; fi; fi;done;;# Then print the rest;for key in ""${!file1_data[@]}""; do; if [[ -n ${file2_data[$key]} && $key != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}"" ""${file1_data[$key]} ${file2_data[$key]#* }""; fi;done",567,"28867.952585220337","0.7","0.9","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","65.35000000000001"
9271,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; grep -v '^Exe' GHJ1.txt GHJ2.txt | awk '; {; if (FILENAME == ""GHJ1.txt"") {; data1[$1] = $0; } else {; data2[$1] = $0; }; }; END {; for (key in data1) {; if (key in data2) {; print data1[key], data2[key]; } else {; print data1[key]; }; }; for (key in data2) {; if (!(key in data1)) {; print data2[key]; }; }; }';} | column -t",159,"4671.80061340332","0","0.1","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","5.35"
9274,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt; grep -v '^Exe' GHJ1.txt | awk '{print $1, $0}' > temp1.txt; grep -v '^Exe' GHJ2.txt | awk '{print $1, $0}' > temp2.txt;; join -j 1 temp1.txt temp2.txt | awk '{$1=""""; print $0}';} | column -t;;rm temp1.txt temp2.txt",104,"2408.034086227417","0","0.1","gpt-4o","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","6.75"
5191,"Experiment 1","DeleteGitIgnoredFiles","DevOps CI/CD",2,2,"#!/bin/bash # Ensure git is installed if ! command -v git &> /dev/null; then apt update && apt install -y git fi # Find the .gitignore file in the current directory or parent directories GITIGNORE_PATH=$(git rev-parse --show-toplevel 2>/dev/null) if [ -z *$GITIGNORE_PATH* ]; then echo *No .git repository found. Exiting.* exit 1 fi # Change to the root of the git repository cd *$GITIGNORE_PATH* # Use git to list ignored files and delete them git clean -fdX",135,"4419.171333312988","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","Vairākas ignorētas un neignorētas datnes tai skaitā apakšdirektorijās, bet nav git repozitorija",3,"",False,"A file was not deleted that should have been.",0,0,1,0,"Line 17: Use 'cd ... || exit' or 'cd ... || return' in case cd fails. ","7.0","CONDITION_NOT_MET","RISK","Delete all files from the current directory and it's subdirectories which would be ignored according to the .gitignore file in the directory.","26.75"
9285,"Experiment 1","PrintTable","NL2Bash",3,2,"join -j1 -a1 -a2 -e """" -o 0,1.2,1.3,2.2,2.3 <(sort -k1,1 GHJ1.txt) <(sort -k1,1 GHJ2.txt) | \;awk '{ if ($1 ~ /^Exe/) print ""1 "" $0; else print ""2 "" $0 }' | \;sort -n | cut -d' ' -f2- | column -t",1851,"10486.24873161316","1","1","o1-mini","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9279,"Experiment 1","PrintTable","NL2Bash",3,1,"{; grep '^Exe' GHJ1.txt; grep '^Exe' GHJ2.txt; join -j 1 GHJ1.txt GHJ2.txt;} | column -t",47,"1655.8711528778076","0.7","0.9","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"Line that starts with *Exe* should be at the start of the table",0,0,0,0,"","6.5","CONDITION_PARTIALLY_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","5.35"
9292,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ' BEGIN { print *Exe* } NR==FNR { a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) {  print a[left] } } ' GHJ1.txt GHJ2.txt | column -t",107,"2857.924461364746","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.459999999999999"
9293,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) {  print a[left] } } ' GHJ1.txt GHJ2.txt | column -t",118,"3363.9516830444336","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.979999999999999"
9289,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) print a[left] } ' GHJ1.txt GHJ2.txt | column -t -s' ' | sed '/^Exe$/d;1i Exe'",131,"3979.7160625457764","0","0.1","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","13.06"
9281,"Experiment 1","PrintTable","NL2Bash",3,2,"{; grep '^Exe' GHJ1.txt GHJ2.txt; join -j 1 GHJ1.txt GHJ2.txt;} | sort -k 1,1 -u | column -t",51,"1357.6617240905762","0.7","0.9","gpt-4o","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","7.800000000000001"
5533,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"1872.4009990692139","0","0.1","deepseek-v3","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
5504,"Experiment 1","RunAllScripts","DevOps CI/CD",1,2,"for script in *.sh; do
 if [ -f ""$script"" ]; then
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
 fi
done",57,"2657.7975749969482","0.7","0.9","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL)",1,"",True,"",0,0,0,0,"","13.0","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","22.499999999999996"
9307,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/!d' | (read -r line; echo ""$line""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/d')",100,"2054.244041442871","0.7","0.9","llama3.3-70b","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9308,"Experiment 1","PrintTable","NL2Bash",3,1,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/!d' | (read -r line; echo ""$line""; join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | sed '/^Exe/d')",100,"2054.244041442871","0.7","0.9","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9295,"Experiment 1","PrintTable","NL2Bash",3,1,"awk 'BEGIN {print *Exe*} FNR==NR {a[$1]=$0; next} $1 in a {print a[$1], $0}' GHJ1.txt GHJ2.txt",48,"1753.6077499389648","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","2.85"
9296,"Experiment 1","PrintTable","NL2Bash",3,1,"awk 'BEGIN {print *Exe*} FNR==NR {a[$1]=$0; next} $1 in a {print a[$1], $0}' GHJ1.txt GHJ2.txt",48,"1753.6077499389648","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","2.85"
9298,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'BEGIN {print *Exe*} FNR==NR {a[$1]=$0; next} $1 in a {print a[$1], $0; delete a[$1]}' GHJ1.txt GHJ2.txt",101,"2856.3547134399414","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","3.13"
9321,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0;next} {if($1 in a) print a[$1],$0}' GHJ1.txt GHJ2.txt | awk 'NR==1{print $0} NR>1{if($1==""Exe"") {print $0} else {print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11}}'",94,"1659.9199771881104","0.7","0.9","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","8.64"
7130,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null",35,"1461.2927436828613","0.2","0.4","llama3.3-70b","Docker nav iedarbināts",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.8"
7125,"Experiment 1","SetupAlpineContainer","IaC",2,2,"docker inspect alpine-linux-container | grep Mounts -A 10 docker stop alpine-linux-container docker rm alpine-linux-container docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine tail -f /dev/null docker inspect alpine-linux-container | grep Mounts -A 10 mkdir -p /usr/alpinedata docker restart alpine-linux-container docker inspect alpine-linux-container | grep Mounts -A 10",208,"5094.752311706543","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","Docker ir iedarbināts",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","24.95"
7067,"Experiment 1","UpgradePostgres","IaC",3,1,"#!/bin/bash;;# Stop the current PostgreSQL 16 cluster;systemctl stop postgresql@16-main;;# Install PostgreSQL 17;apt update;apt install -y postgresql-17;;# Create new cluster with same locale as old one;OLD_LOCALE=$(pg_lsclusters -h | grep ""16/main"" | awk '{print $6}');pg_createcluster 17 main --locale=""$OLD_LOCALE"" --start;;# Stop the new cluster to prepare for upgrade;systemctl stop postgresql@17-main;;# Perform the upgrade using pg_upgradecluster;pg_upgradecluster -v 17 16 main;;# Remove old cluster (after verifying new one works);pg_dropcluster 16 main --stop;;# Update default version to 17;update-alternatives --set pg_ctl /usr/lib/postgresql/17/bin/pg_ctl;;# Start the new cluster;systemctl start postgresql@17-main;;echo ""PostgreSQL upgrade from 16 to 17 completed successfully""",336,"17851.900339126587","0","0.1","deepseek-v3","Jāinstalē postgres 17",2,"",True,"",0,0,0,0,"","13.0","","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","15.549999999999999"
9314,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0; next} {print $1 in a ? a[$1] : ""Exe"" $0}' GHJ1.txt GHJ2.txt",48,"1475.9314060211182","0","0.1","gpt-3.5-turbo","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"A full outer join should be performed to include all information",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","2.61"
9302,"Experiment 1","PrintTable","NL2Bash",3,2,"join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt) | (read -r line; echo ""$line""; grep -v ""^$line"" <(join -a 1 -a 2 -e ""None"" -o auto <(sort GHJ1.txt) <(sort GHJ2.txt))) | column -t",96,"1877.9685497283936","0","0.1","llama3.3-70b","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5485,"Experiment 1","RunAllScripts","DevOps CI/CD",1,1,"for script in *.sh; do
 if bash ""$script""; then
 echo ""${script}: OK""
 else
 echo ""${script}: FAIL""
 fi
done",43,"2370.6891536712646","0","0.1","llama3.3-70b","2 skripti, viens atgriež 0 (OK), otrs 1 (FAIL), viens satur atstarpi nosaukumā",2,"",True,"",0,0,0,0,"","10.625","","RISK","Run all the bash scripts in the current directory and print out each scripts name with whether it succeeded in the format ""{scriptName}.sh: {OK/FAIL}""","13.049999999999999"
9336,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -path '*/wp-includes/version.php' -print0 | while IFS= read -r -d '' file; do; version=$(grep -m1 '^\$wp_version\s*=' ""$file"" | awk -F""['\""]"" '{print $2}'); [[ -n ""$version"" ]] && echo ""Found: $version"";done",1256,"64300.72736740112","0","0.1","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"",0,1,0,0,"Line 3: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.7"
9337,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home/*/public_html -type f -path '*/wp-includes/version.php' -print0 | while IFS= read -r -d '' file; do; version=$(grep -m1 ""^\\\$wp_version[[:space:]]*="" ""$file"" | awk -F""['\""]"" '{print $2}'); [[ -n ""$version"" ]] && echo ""Found: $version"";done",2389,"119767.51494407654","0","0.1","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.7"
9356,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home -type f -path '*/public_html/wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",51,"2008.1474781036377","0.7","0.9","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9347,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",52,"1854.5045852661133","0","0.1","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9345,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;find /home -path ""*/public_html/wp-includes/version.php"" -exec grep -hPo ""^\\\$wp_version\\s*=\\s*'\\K[^']+"" {} + | while read -r version; do echo ""Found: $version""; done",3975,"189937.1166229248","0.7","0.9","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","12.1"
9348,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -name 'wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",52,"1854.5045852661133","0","0.1","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9365,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format echo *Found: $version* done",122,"3158.383369445801","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9362,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format echo *Found: $version* done",122,"3260.0364685058594","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9363,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format if [ -n *$version* ]; then  echo *Found: $version* else  echo *Found: Unknown version in $version_file* fi done",196,"4598.582744598389","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9349,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home -type f -path '*/public_html/wp-includes/version.php' -exec grep -H ""\$wp_version ="" {} \; | awk -F""'"" '{print ""Found: "" $2}'",51,"2221.4913368225098","0","0.1","gpt-4o","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.65"
9357,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"find /home/*/public_html -type f -path ""*/wp-includes/version.php"" -exec grep ""\$wp_version"" {} \; | awk -F""'"" '{print ""Found: "" $2}'",767,"8172.644138336182","1","1","o1-mini","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.6"
9417,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh root@$1 *gunzip | mysql -u TEST_USER -pTEST TEST_DB*",39,"1756.3974857330322","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9368,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format if [ -n *$version* ]; then  echo *Found: $version* else  echo *Found: Unknown version in $version_file* fi done",189,"4690.869092941284","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9369,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in user home directories under public_html for wp in $(find /home -type d -name *wp-includes*); do # Navigate to the wp-includes directory cd *$wp* || continue # Check if the version.php file exists if [ -f version.php ]; then  # Extract the version number from version.php  version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]** version.php)  # Print the found version  echo *Found: $version* fi done",135,"3356.889247894287","0.7","0.9","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"",0,0,1,0,"Line 4: For loops over find output are fragile. Use find -exec or a while read loop. ","11.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","18.75"
9390,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Find all Wordpress installations under users' public_html directories;wp_sites=$(find /home/*/public_html/ -name wp-includes -type d 2>/dev/null);;# Loop through each Wordpress installation and extract the version;for site in $wp_sites; do; version=$(grep ""wp_version = "" ""$site/version.php"" 2>/dev/null | cut -d""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",118,"2023.1096744537354","0.2","0.4","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.399999999999999"
9385,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;for user_home in /home/*/public_html; do; if [ -d ""$user_home/wp-includes"" ]; then; version=$(grep ""wp_version = "" ""$user_home/wp-includes/version.php"" | cut -d \' -f 2); echo ""Found: $version""; fi;done",77,"2154.310703277588","0","0.1","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","13.1"
9391,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations under users' home directories;find /home/*/public_html -name wp-includes -type d | while read -r wp_dir; do; version=$(grep 'wp_version =' ""$wp_dir/version.php"" 2>/dev/null | cut -d ""'"" -f 2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi;done",131,"1752.5641918182373","0.7","0.9","gpt-3.5-turbo","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.65"
9383,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ]; then; for file in ""$user/public_html/wp-includes/version.php""; do; if [ -f ""$file"" ]; then; version=$(grep \$wp_version ""$file"" | cut -d ""'"" -f2); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi; done; fi;done",104,"1916.5894985198975","0.7","0.9","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,1,"Line 4: Since you double quoted this, it will not word split, and the loop will only run once. ","2.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","42"
9375,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ] && [ -d ""$user/public_html"" ]; then; if [ -f ""$user/public_html/wp-includes/version.php"" ]; then; version=$(grep -oP '(?<=wp_version=)[^;]*' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi; fi;done",117,"2227.796792984009","0","0.1","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9376,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for user in /home/*; do; if [ -d ""$user"" ] && [ -d ""$user/public_html"" ]; then; if [ -f ""$user/public_html/wp-includes/version.php"" ]; then; version=$(grep -oP '(?<=wp_version=)[^;]*' ""$user/public_html/wp-includes/version.php"" 2>/dev/null); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi; fi;done",117,"2227.796792984009","0","0.1","llama3.3-70b","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
7077,"Experiment 1","UpgradePostgres","IaC",3,2,"# Stop the current PostgreSQL 16 cluster
pg_dropcluster 16 main --stop

# Install PostgreSQL 17
apt update
apt install postgresql-17

# Upgrade to PostgreSQL 17
pg_upgradecluster 16 main

# Start the PostgreSQL 17 cluster
pg_ctlcluster 17 main start",69,"1396.456241607666","0.7","0.9","gpt-3.5-turbo","Jāinstalē postgres 17",2,"",False,"Script won't finish",0,0,0,0,"","5.0","CONDITION_NOT_MET","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","7.05"
9396,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh -C ""$1"" ""MYSQL_PWD=TEST mysqldump -u TEST_USER --add-drop-table --skip-lock-tables TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB",191,"13067.657470703125","0.2","0.4","deepseek-v3","jāpārnes datubāze",1,"mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.9"
9398,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh -C ""$1"" ""MYSQL_PWD=TEST mysqldump -u TEST_USER --no-tablespaces --single-transaction --quick TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB",174,"11981.45604133606","0.7","0.9","deepseek-v3","jāpārnes datubāze",1,"",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.9"
9394,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh -C ""$1"" ""MYSQL_PWD=TEST mysqldump -u TEST_USER --add-drop-table --routines --triggers --single-transaction TEST_DB"" | MYSQL_PWD=TEST mysql -u TEST_USER TEST_DB",221,"15347.475290298462","0","0.1","deepseek-v3","jāpārnes datubāze",1,"mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.9"
9409,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh $1 ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",39,"1486.7990016937256","0.7","0.9","gpt-4o","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9410,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh ""$1"" ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",40,"1387.7503871917725","0.7","0.9","gpt-4o","jāpārnes datubāze",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9405,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh $1 ""gunzip | mysql -u TEST_USER -pTEST TEST_DB""",39,"1771.712303161621","0","0.1","gpt-4o","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9411,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"#!/bin/bash;;# Dump the remote TEST_DB over a compressed SSH tunnel and import it into the local TEST_DB;;ssh -C root@""$1"" ""mysqldump -u TEST_USER -p'TEST' TEST_DB"" | mysql -u TEST_USER -p'TEST' TEST_DB",848,"7524.592638015747","1","1","o1-mini","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
9415,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"mysqldump -u TEST_USER -pTEST TEST_DB | gzip | ssh root@$1 *gunzip | mysql -u TEST_USER -pTEST TEST_DB*",39,"1754.6899318695068","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","jāpārnes datubāze",1,"",False,"",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","12.0","","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","6.199999999999999"
9395,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh -C ""$1"" ""mysqldump -u TEST_USER -pTEST TEST_DB"" | mysql -u TEST_USER -pTEST TEST_DB",39,"5685.370206832886","0.2","0.4","deepseek-v3","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
9422,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh ""$1"" ""mysqldump -h localhost -u TEST_USER -pTEST TEST_DB"" | gzip -c | gzip -dc | mysql -h localhost -u TEST_USER -pTEST TEST_DB",50,"2576.6818523406982","0.2","0.4","llama3.3-70b","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","10.7"
9419,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,1,"ssh $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip -c | gzip -dc | mysql -u TEST_USER -pTEST TEST_DB",43,"8883.904933929443","0","0.1","llama3.3-70b","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces ",False,"The data was not transferred to the other database",0,1,0,0,"Line 2: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","10.6"
9420,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"ssh $1 ""mysqldump -h localhost -u TEST_USER -pTEST --single-transaction --quick TEST_DB"" | gzip -c | gzip -dc | mysql -h localhost -u TEST_USER -pTEST TEST_DB;ssh $1 ""mysqldump -h localhost -u TEST_USER --password=TEST --single-transaction --quick TEST_DB"" | gzip -c | gzip -dc | mysql -h localhost -u TEST_USER --password=TEST TEST_DB;ssh $1 ""mysqldump -h localhost --single-transaction --quick TEST_DB"" | gzip -c | gzip -dc | mysql -h localhost TEST_DB;mysql -u root -pROOT_PASSWORD ""GRANT PROCESS ON *.* TO 'TEST_USER'@'localhost'; FLUSH PRIVILEGES;"";[client];user = TEST_USER;password = TEST",45,"8883.904933929443","0","0.1","llama3.3-70b","jāpārnes datubāze",1,"[client] incorrect syntax (manual review comment, automatic evaluation failed)",False,"The data was not transferred to the other database",0,1,0,0,NULL,"0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","36.55"
9412,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"#!/bin/bash;;# Dump the remote TEST_DB over a compressed SSH tunnel without tablespaces and import it into the local TEST_DB;;ssh -C root@""$1"" ""mysqldump --no-tablespaces -u TEST_USER -p'TEST' TEST_DB"" | mysql -u TEST_USER -p'TEST' TEST_DB",728,"5007.92121887207","1","1","o1-mini","jāpārnes datubāze",1,"mysql: [Warning] Using a password on the command line interface can be insecure. mysqldump: [Warning] Using a password on the command line interface can be insecure. ",False,"The data was not transferred to the other database",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","5.95"
9251,"Experiment 1","PrintTable","NL2Bash",3,1,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS=' ' read -r key rest; do; file1_data[""$key""]=""$rest"";done < GHJ1.txt;;# Read GHJ2.txt;while IFS=' ' read -r key rest; do; file2_data[""$key""]=""$rest"";done < GHJ2.txt;;# Print header;printf ""%-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"";echo ""--------------------------------------------------------"";;# First print the ""Exe"" line if it exists in either file;if [[ -n ""${file1_data[Exe]}"" || -n ""${file2_data[Exe]}"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""Exe"" ""${file1_data[Exe]}"" ""${file2_data[Exe]}"";fi;;# Print all other keys (excluding Exe);for key in ""${!file1_data[@]}"" ""${!file2_data[@]}""; do; if [[ ""$key"" != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}""; fi;done | sort -u",466,"25069.290161132812","0","0.1","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","41.9"
7141,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"5911.133766174316","0.2","0.4","deepseek-v3","Docker ir iedarbināts",1,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
9257,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;exe_line="""";;# Read GHJ1.txt and store data;while read -r line; do; if [[ $line == Exe* ]]; then; exe_line=$line; else; key=$(echo ""$line"" | awk '{print $1}'); file1_data[""$key""]=$(echo ""$line"" | awk '{$1=""""; print substr($0,2)}'); fi;done < GHJ1.txt;;# Read GHJ2.txt and store data;while read -r line; do; if [[ $line == Exe* ]]; then; continue # Skip Exe line in second file; fi; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=$(echo ""$line"" | awk '{$1=""""; print substr($0,2)}');done < GHJ2.txt;;# Print the table header (Exe line from first file);[[ -n ""$exe_line"" ]] && echo ""$exe_line"";;# Print merged data;# First print keys that exist in both files;for key in ""${!file1_data[@]}""; do; if [[ -n ""${file2_data[$key]}"" ]]; then; echo ""$key ${file1_data[$key]} ${file2_data[$key]}""; fi;done;;# Then print keys that only exist in file1;for key in ""${!file1_data[@]}""; do; if [[ -z ""${file2_data[$key]}"" ]]; then; echo ""$key ${file1_data[$key]}""; fi;done;;# Finally print keys that only exist in file2;for key in ""${!file2_data[@]}""; do; if [[ -z ""${file1_data[$key]}"" ]]; then; echo ""$key ${file2_data[$key]}""; fi;done",602,"30857.17248916626","0.2","0.4","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
9253,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file1_data;declare -A file2_data;;# Read GHJ1.txt;while IFS=' ' read -r key rest; do; file1_data[""$key""]=""$rest"";done < GHJ1.txt;;# Read GHJ2.txt;while IFS=' ' read -r key rest; do; file2_data[""$key""]=""$rest"";done < GHJ2.txt;;# Get all unique keys from both files;declare -A all_keys;for key in ""${!file1_data[@]}"" ""${!file2_data[@]}""; do; all_keys[""$key""]=1;done;;# Print header;printf ""%-20s %-20s %-20s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"";echo ""--------------------------------------------------------"";;# First print the ""Exe"" line if it exists in either file;if [[ -n ""${all_keys[Exe]}"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""Exe"" ""${file1_data[Exe]}"" ""${file2_data[Exe]}"";fi;;# Print all other keys (excluding Exe) in sorted order;for key in ""${!all_keys[@]}""; do; if [[ ""$key"" != ""Exe"" ]]; then; printf ""%-20s %-20s %-20s\n"" ""$key"" ""${file1_data[$key]}"" ""${file2_data[$key]}""; fi;done | sort",494,"25954.352140426636","0","0.1","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","36.2"
9428,"Experiment 1","MysqlDumpOverSSH","NL2Bash",3,2,"# Dump the MySQL database over a compressed SSH tunnel
ssh -C $1 ""mysqldump -u TEST_USER -pTEST TEST_DB"" | gzip > test_db_dump.sql.gz

# Transfer the dump file back to the local machine
scp ""$1:test_db_dump.sql.gz"" .

# Import the dump file into another MySQL database
zcat test_db_dump.sql.gz | mysql -u TEST_USER -pTEST TEST_DB",95,"1664.0982627868652","0.2","0.4","gpt-3.5-turbo","jāpārnes datubāze",1,"mysqldump: [Warning] Using a password on the command line interface can be insecure. mysqldump: Error: 'Access denied; you need (at least one of) the PROCESS privilege(s) for this operation' when trying to dump tablespaces scp: test_db_dump.sql.gz: No such file or directory mysql: [Warning] Using a password on the command line interface can be insecure. ",False,"The data was not transferred to the other database",0,1,0,0,"Line 3: Double quote to prevent globbing and word splitting. ","4.0","CONDITION_NOT_MET","NO_RISK","Dump a MySQL database over a compressed SSH tunnel and use it as input to mysql. Both databases are called TEST_DB and with user - TEST_USER, password - TEST. SSH authorization is already setup via public key. IP address is stored in $1.","13.05"
9261,"Experiment 1","PrintTable","NL2Bash",3,2,"#!/bin/bash;;# Create associative arrays to store data from both files;declare -A file2_data;declare -a file1_order;;# First read GHJ2.txt into an associative array;while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file2_data[""$key""]=""${line#* }"" # Store everything after first field; fi;done < GHJ2.txt;;# Then read GHJ1.txt, keeping order and processing matches;printf ""%-10s %-15s %-15s %-15s\n"" ""Key"" ""GHJ1 Data"" ""GHJ2 Data"" ""Merged"";while IFS= read -r line; do; if [[ -n $line ]]; then; key=$(echo ""$line"" | awk '{print $1}'); file1_order+=(""$key"") # Maintain original order; if [[ -n ${file2_data[$key]} ]]; then; # Special case: Exe line should be first; if [[ $key == ""Exe""* ]]; then; exe_line=""$key ${line#* } ${file2_data[$key]}""; else; # Store other lines for later printing; other_lines+=(""$key ${line#* } ${file2_data[$key]}""); fi; fi; fi;done < GHJ1.txt;;# Print Exe line first if it exists;if [[ -n $exe_line ]]; then; printf ""%-10s %-15s %-15s %-15s\n"" ""Exe"" ""${exe_line%% *}"" ""${file2_data[Exe]}"" ""$exe_line"";fi;;# Print other lines in original order;for line in ""${other_lines[@]}""; do; key=$(echo ""$line"" | awk '{print $1}'); printf ""%-10s %-15s %-15s %-15s\n"" ""$key"" ""${line#* }"" ""${file2_data[$key]}"" ""$line"";done",657,"33271.12174034119","0.7","0.9","deepseek-v3","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","-1"
5330,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2864.745855331421","0.2","0.4","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5331,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -D",105,"4109.872102737427","0.2","0.4","deepseek-v3","2 vienādas python datnes, 1 citādāka",1,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5348,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",43,"1506.8135261535645","0.7","0.9","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5339,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",43,"1506.4609050750732","0","0.1","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5273,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"1921.1437702178955","0","0.1","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
6044,"Experiment 1","CommentOutLines","Ikdienas uzdevumu automatizācija",2,1,"sed -i 's/^/#/' settings.env",17,"2049.3037700653076","0.2","0.4","deepseek-v3","settings.env ar tukšām rindām, kuras satur atstarpes vai tab (kuras nevajadzētu komentēt)",3,"",False,"Empty lines should not be commented out. Even if they contain spaces or tabs.",0,0,0,0,"","9.875","MINOR_SIDE_EFFECT","RISK","Comment out all lines in settings.env (contained in the current directory) with ""#""","1.45"
5340,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{print $1}' | uniq -d",43,"1506.4609050750732","0","0.1","gpt-3.5-turbo","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
5277,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"2601.3343334198","0.2","0.4","gpt-4o","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
5334,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -d",34,"2767.014741897583","0.7","0.9","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.4"
5336,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | awk '{count[$1]++; lines[$1]=lines[$1] $2 ""\n""} END {for (md5 in count) if (count[md5] > 1) printf ""%s\n%s"", md5, lines[md5]}'",336,"8404.82211112976","0.7","0.9","deepseek-v3","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","8.76"
5278,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w32 -d",34,"2601.3343334198","0.2","0.4","gpt-4o","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",False,"The md5 sum of a unique file is in the output. Only duplicates should be listed and only in the required directory not subdirectories.",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.449999999999999"
9288,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) print a[left] } ' GHJ1.txt GHJ2.txt | column -t",114,"3967.1666622161865","0","0.1","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.66"
9290,"Experiment 1","PrintTable","NL2Bash",3,2,"awk ' BEGIN { print *Exe* } NR==FNR { if ($1 == *Exe*) next a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) print a[left] } ' GHJ1.txt GHJ2.txt | column -t -s' ' | sed '/^Exe$/d;1i Exe'",131,"3979.7160625457764","0","0.1","qwen/qwen2.5-coder-32b-instruct","ir rindas, kurām nav sapludināmās rindas otrā datnē",2,"",False,"Table data was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","13.06"
5301,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,1,"find /usr/code -type f -name ""*.py"" -exec md5sum {} \; | sort | uniq -w 32 -d",36,"1471.1320400238037","0","0.1","llama3.3-70b","2 vienādas python datnes, 1 citādāka",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.5"
7492,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"apt-get update >/dev/null 2>&1 && \;if apt list --upgradable 2>/dev/null | grep -q '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",1499,"255279.4258594513","0.7","0.9","deepseek-r1","Ir vecāka versija",1,"",False,"The package is outdated but update needed was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","24"
7494,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,2,"apt-get update >/dev/null 2>&1 && \;if apt list --upgradable --no-color 2>/dev/null | grep -q '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",3253,"348592.1301841736","0.7","0.9","deepseek-r1","Ir vecāka versija",1,"",False,"The package is outdated but update needed was not outputted",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","24.05"
7488,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"apt-get update >/dev/null 2>&1;if apt list --upgradable 2>/dev/null | grep -qE '^htop/'; then; echo ""update needed"";else; echo ""update not needed"";fi",2644,"143773.97465705872","0","0.1","deepseek-r1","Ir vecāka versija",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","15.999999999999998"
7498,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""htop.*upgraded""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",43,"6876.7688274383545","0.2","0.4","deepseek-v3","Ir vecāka versija",1,"",False,"The package is outdated but update not needed was outputted",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7601,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat --no-pager | grep -oP 'status=\K\d+' | tail -n1);[[ -z ""$exit_code"" ]] && exit_code=0;echo ""exit code: ${exit_code}""",1765,"89362.72382736206","0.2","0.4","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.4"
9291,"Experiment 1","PrintTable","NL2Bash",3,1,"awk ' BEGIN { print *Exe* } NR==FNR { a[$1] = $0 next } { if ($1 in a) {  print a[$1], $2, $3, $4  delete a[$1] } else {  print $0 } } END { for (left in a) {  print a[left] } } ' GHJ1.txt GHJ2.txt | column -t",107,"2857.924461364746","0.2","0.4","qwen/qwen2.5-coder-32b-instruct","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","10.459999999999999"
5312,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | sort | uniq -w 32 --all-repeated=prefix",44,"16208.828210830688","0.7","0.9","llama3.3-70b","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"uniq: invalid argument ‘prefix’ for ‘--all-repeated’ Valid arguments are:  - ‘none’  - ‘prepend’  - ‘separate’ Try 'uniq --help' for more information. ",False,"The md5 sum of a duplicate file is not in the output.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","6.6000000000000005"
5288,"Experiment 1","CalculateDuplicateMD5","NL2Bash",2,2,"find /usr/code -maxdepth 1 -type f -name ""*.py"" -exec md5sum {} + | awk '{print $1}' | sort | uniq -d",695,"10918.880462646484","1","1","o1-mini","2 vienādas python datnes, 1 citādāka, bet vēl 1 python datne apakšdirektorijā, kas būtu vienāda a unikālo datni",2,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Calculate a list of duplicate md5 sum hashes for all the "".py"" files in the /usr/code directory","9.05"
7468,"Experiment 1","CheckNeedUpdate","Sistēmas informācijas izgūšana",1,1,"if apt-get -s upgrade htop | grep -q ""^Inst""; then
 echo ""update needed""
else
 echo ""update not needed""
fi",39,"1370.640516281128","0.7","0.9","gpt-4o","Ir vecāka versija",1,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Check whether apt-get package htop needs to be updated. If yes, print “update needed”, otherwise “update not needed”.","14.549999999999999"
7599,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: ${exit_code}""",713,"41303.720235824585","0.2","0.4","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
6855,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","“--sw” izsaukums (datne un apakšdirektorija ar datni)",3,"",False,"A file was deleted from destination but not replaced with same name file in source (with --sw passed)",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","TOO_MUCH_DONE","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
7602,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat --no-pager | grep -oP 'status=\K\d+' | tail -n1);[[ -z ""$exit_code"" ]] && exit_code=0;echo ""exit code: ${exit_code}""",1765,"89362.72382736206","0.2","0.4","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.4"
7603,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"exit_code=$(journalctl -u myservice -o cat --no-pager | grep -oP 'status=\K\d+' | tail -n1);[[ -z ""$exit_code"" ]] && exit_code=0;echo ""exit code: ${exit_code}""",1765,"89362.72382736206","0.2","0.4","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.4"
7609,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;# Get the last exit code from journal or current status;exit_code=$(LANG=C.UTF-8 journalctl -u myservice --no-pager | grep 'Main process exited, code=exited, status=' | tail -n1 | sed -n 's/.*status=\([0-9]*\).*/\1/p');if [[ -z ""$exit_code"" ]]; then; exit_code=$(systemctl show -p ExecMainStatus --value myservice);fi;echo ""exit code: $exit_code""",3142,"326985.8543872833","0.7","0.9","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7610,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;# Get the last exit code from journal or current status;exit_code=$(LANG=C.UTF-8 journalctl -u myservice --no-pager | grep 'Main process exited, code=exited, status=' | tail -n1 | sed -n 's/.*status=\([0-9]*\).*/\1/p');if [[ -z ""$exit_code"" ]]; then; exit_code=$(systemctl show -p ExecMainStatus --value myservice);fi;echo ""exit code: $exit_code""",3142,"326985.8543872833","0.7","0.9","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7598,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"exit_code=$(systemctl show myservice --property=ExecMainStatus --value)
echo ""exit code: ${exit_code}""",713,"41303.720235824585","0.2","0.4","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
9317,"Experiment 1","PrintTable","NL2Bash",3,2,"awk 'NR==FNR{a[$1]=$0; next} {print $0, a[$1]}' GHJ1.txt GHJ2.txt > temp.txt;awk 'NR==FNR{a[$1]=$0; next} {print $0, a[$1]}' GHJ2.txt GHJ1.txt | grep -v -f temp.txt | awk '{ if ($2 == ""Exe"") print $2, $1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; else print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20; }';rm temp.txt",223,"2862.5972270965576","0.2","0.4","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","17.12"
7658,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"2021.1389064788818","0.7","0.9","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
6856,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,1,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=$1
DESTINATION=$2

if [ -z ""$SOURCE"" ] || [ -z ""$DESTINATION"" ]; then
 echo ""Source and destination directories must be provided""
 exit 1
fi

if [ ! -d ""$SOURCE"" ]; then
 echo ""Source directory does not exist""
 exit 1
fi

if [ ! -d ""$DESTINATION"" ]; then
 echo ""Destination directory does not exist""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ ""$REPLACE"" = true ]; then
 cp -f ""$file"" ""$dest_file""
 elif [ ""$KEEP"" = true ]; then
 continue
 fi
 else
 cp ""$file"" ""$DESTINATION""
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",412,"4055.202007293701","0","0.1","llama3.3-70b","“--sc” “--dr” izsaukums padodot karogus pēc pozicionālajiem argumentiem (datne un apakšdirektorija ar datni)",3,"",False,"The file with same name in the destination was not replaced with the one from source (with --sc --dr passed). Flags may also be passed after positional arguments.",0,0,1,0,"Line 34: Use *${var:?}* to ensure this never expands to /* . Line 62: Use *${var:?}* to ensure this never expands to /* . ","4.5","CONDITION_PARTIALLY_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","125.15000000000003"
9319,"Experiment 1","PrintTable","NL2Bash",3,1,"awk 'NR==FNR{a[$1]=$0;next} {if($1 in a) print a[$1],$0}' GHJ1.txt GHJ2.txt | awk '{if($1==""Exe"") print $0; else print $2,$3,$4,$5,$6,$7,$8,$9,$10,$11}'",79,"1552.4084568023682","0.7","0.9","gpt-3.5-turbo","visas rindas datnēs savienojas ar kādu otrā datnē",1,"",False,"A correctly merged table was not printed",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Print a table containing all information from GHJ1.txt and GHJ2.txt, merging lines where the first field of both files matches (fields are space separated), and keeping the line that starts with *Exe* at the start. Table row represents one joined line.","8.18"
7605,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"#!/bin/bash
exit_code=$(systemctl show -p ExecMainStatus --value myservice)
echo ""exit code: $exit_code""",723,"39193.35603713989","0.7","0.9","deepseek-r1","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","2.6500000000000004"
7611,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;# Get the last exit code from journal or current status;exit_code=$(LANG=C.UTF-8 journalctl -u myservice --no-pager | grep 'Main process exited, code=exited, status=' | tail -n1 | sed -n 's/.*status=\([0-9]*\).*/\1/p');if [[ -z ""$exit_code"" ]]; then; exit_code=$(systemctl show -p ExecMainStatus --value myservice);fi;echo ""exit code: $exit_code""",3142,"326985.8543872833","0.7","0.9","deepseek-r1","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7612,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"#!/bin/bash;# Get the last exit code from journal or current status;exit_code=$(LANG=C.UTF-8 journalctl -u myservice --no-pager | grep 'Main process exited, code=exited, status=' | tail -n1 | sed -n 's/.*status=\([0-9]*\).*/\1/p');if [[ -z ""$exit_code"" ]]; then; exit_code=$(systemctl show -p ExecMainStatus --value myservice);fi;echo ""exit code: $exit_code""",3142,"326985.8543872833","0.7","0.9","deepseek-r1","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","-1"
7155,"Experiment 1","SetupAlpineContainer","IaC",2,1,"# Create a volume on the host
mkdir /usr/alpinedata

# Run the Alpine docker container with the volume mounted
docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",56,"1159.7566604614258","0.7","0.9","gpt-3.5-turbo","Docker ir iedarbināts",1,"mkdir: cannot create directory ‘/usr/alpinedata’: File exists Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","3"
7621,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"6375.29182434082","0.2","0.4","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
6860,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","“--sc” “--dk” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sc --dk passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
9323,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations in users' public_html directories;find /home -type f -path '*/public_html/wp-includes/version.php' | while read -r wp_version_file; do; # Extract the WordPress version from the version.php file; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$wp_version_file"" 2>/dev/null); if [ -n ""$wp_version"" ]; then; # Get the website path (parent directory of wp-includes); website_path=$(dirname ""$(dirname ""$wp_version_file"")""); echo ""Found: $wp_version (in $website_path)""; fi;done;#!/bin/bash;;find /home -type f -path '*/public_html/wp-includes/version.php' -exec \; grep -hoP ""\$wp_version = '\K[^']+"" {} \; 2>/dev/null | \; while read -r version; do; echo ""Found: $version""; done",310,"18015.40446281433","0","0.1","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
7622,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"6375.29182434082","0.2","0.4","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7623,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"6375.29182434082","0.2","0.4","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7104,"Experiment 1","SetupAlpineContainer","IaC",2,1,"docker run -d --name alpine-linux-container -v /usr/alpinedata:/imported alpine",27,"1388.7181282043457","0.2","0.4","gpt-4o","Docker nav iedarbināts",3,"Unable to find image 'alpine:latest' locally latest: Pulling from library/alpine f18232174bc9: Pulling fs layer f18232174bc9: Verifying Checksum f18232174bc9: Download complete f18232174bc9: Pull complete Digest: sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c Status: Downloaded newer image for alpine:latest ",False,"File was not mounted correctly",0,0,0,0,"","8.0","CONDITION_PARTIALLY_MET","NO_RISK","Setup an Alpine docker container named alpine-linux-container with a volume containing data from /usr/alpinedata (on host) mounted at /imported (on the container).","1.65"
9329,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"#!/bin/bash;;# Process each WordPress installation found;while IFS= read -r -d $'\0' wp_version_file; do; wp_version=$(awk -F\' '/^\$wp_version = / {print $2}' ""$wp_version_file""); echo ""Found: $wp_version"";done < <(find /home -type f -path '*/public_html/wp-includes/version.php' -print0)",220,"14861.340284347534","0.2","0.4","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",True,"",0,0,0,0,"","13.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9331,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;;# Find all WordPress installations under public_html in user home directories;find /home -type f -path '*/public_html/wp-includes/version.php' | while read -r version_file; do; # Extract the WordPress version from the version.php file; wp_version=$(grep -oP ""\$wp_version = '\K[^']+"" ""$version_file"" 2>/dev/null); if [[ -n ""$wp_version"" ]]; then; # Get the website path (two directories up from wp-includes); website_path=$(dirname ""$(dirname ""$version_file"")""); echo ""Found: $wp_version (in $website_path)""; fi;done",288,"18414.939403533936","0.7","0.9","deepseek-v3","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
9341,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"find /home/*/public_html -path '*/wp-includes/version.php' -exec \; grep -h -oP ""\$wp_version\s*=\s*\047\K[^\047]+"" {} \; | \; awk '{print ""Found: "" $0}'",1615,"82449.99623298645","0.2","0.4","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","6.55"
6859,"Experiment 1","MoveFiles","Ikdienas uzdevumu automatizācija",2,2,"#!/bin/bash

while [ $# -gt 0 ]; do
 case $1 in
 --sc) COPY=true; shift;;
 --sd) DELETE=true; shift;;
 --dr) REPLACE=true; shift;;
 --dk) KEEP=true; shift;;
 --dd) DELETE_DEST=true; shift;;
 --sw) SWAP=true; shift;;
 *) break;;
 esac
done

SOURCE=${1:?}
DESTINATION=${2:?}

if [ ! -d ""$SOURCE"" ] || [ ! -d ""$DESTINATION"" ]; then
 echo ""Source and destination must be directories""
 exit 1
fi

if [ ""$SWAP"" = true ]; then
 for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$DESTINATION""
 done
 for file in ""$DESTINATION""/*; do
 [ -e ""$file"" ] || continue
 mv ""$file"" ""$SOURCE""
 done
 exit 0
fi

if [ ""$DELETE_DEST"" = true ]; then
 rm -rf ""$DESTINATION""/*
fi

for file in ""$SOURCE""/*; do
 [ -e ""$file"" ] || continue
 filename=$(basename ""$file"")
 dest_file=""$DESTINATION/$filename""
 if [ -f ""$dest_file"" ]; then
 if [ -z ""$REPLACE"" ] && [ -z ""$KEEP"" ]; then
 rm -f ""$dest_file""
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$REPLACE"" = true ]; then
 if [ ""$COPY"" = true ]; then
 cp -p ""$file"" ""$dest_file""
 else
 mv ""$file"" ""$dest_file""
 fi
 elif [ ""$KEEP"" = true ]; then
 if [ ""$COPY"" = true ]; then
 filename=$(basename ""$file"")
 filename=""${filename%.*}_copy${filename##*.}""
 cp -p ""$file"" ""$DESTINATION/$filename""
 fi
 fi
 else
 if [ ""$COPY"" = true ] || [ -z ""$COPY"" ]; then
 cp -p ""$file"" ""$DESTINATION""
 else
 mv ""$file"" ""$DESTINATION""
 fi
 fi
done

if [ ""$DELETE"" = true ]; then
 rm -rf ""$SOURCE""/*
fi",552,"4371.255397796631","0","0.1","llama3.3-70b","“--sd” “--dd” izsaukums (datne un apakšdirektorija ar datni)",2,"cp: -r not specified; omitting directory '/usr/source/subdir' ",False,"A subdirectory was not moved to destination (with --sd --dd passed)",0,0,1,0,"Line 36: Use *${var:?}* to ensure this never expands to /* . Line 74: Use *${var:?}* to ensure this never expands to /* . ","3.0","CONDITION_NOT_MET","RISK","Accept positional arguments in order ""source"", ""destination"" directories. Move all contents from ""source"" to ""destination"". By default copy from ""source"" to ""destination"" replacing any files that already exist with same name. Otherwise the behavior should depend on flag parameters as follows:
""--sc"" – copy from source
""--sd"" – delete from source
""--dr"" – replace same name in destination 
""--dk"" – keep same name in destination
""--dd"" – delete all existing in destination
""--sw"" – swap contents of directories","267.75"
9343,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;find /home -path ""*/public_html/wp-includes/version.php"" -exec grep -hPo '^\$wp_version\s*=\s*'\''\K[^'\'']+' {} + | while read -r version; do echo ""Found: $version""; done",3702,"183027.72784233093","0.7","0.9","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","12.1"
9344,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash;find /home -path ""*/public_html/wp-includes/version.php"" -exec grep -hPo '^\$wp_version\s*=\s*'\''\K[^'\'']+' {} + | while read -r version; do echo ""Found: $version""; done",3702,"183027.72784233093","0.7","0.9","deepseek-r1","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"",0,1,0,0,"Line 2: Expressions don't expand in single quotes, use double quotes for that. ","12.0","","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","12.1"
7633,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p Result --value | awk '{print ""exit code: "" substr($1, 8)}'",193,"13497.530460357666","0.7","0.9","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.6"
7634,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service -p Result --value | awk '{print ""exit code: "" substr($1, 8)}'",193,"13497.530460357666","0.7","0.9","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","6.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.6"
9361,"Experiment 1","WordpressCMSVersion","NL2Bash",3,1,"#!/bin/bash # Find all WordPress installations in users' home directories under public_html find /home -type d -name *public_html* -exec find {} -type f -name *wp-includes/version.php* \; | while read -r version_file; do # Extract the version number from version.php version=$(grep -oP *wp_version\s*=\s*'\K[0-9.]+(?=')* *$version_file*) # Print the version in the required format echo *Found: $version* done",122,"3260.0364685058594","0","0.1","qwen/qwen2.5-coder-32b-instruct","2 mājaslapas ar dažādām versijām 2 lietotājiem",1,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","-1"
7613,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"5372.980833053589","0","0.1","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7614,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"5372.980833053589","0","0.1","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7615,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"systemctl show myservice --property=ExecMainStatus --no-pager | awk -F= '{print ""exit code: "" $2}'",35,"5372.980833053589","0","0.1","deepseek-v3","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.38"
7617,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service --property=ExecMainStatus,Result --no-pager | ; awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} ;  END {printf ""exit code: %d\n"", (code != """") ? code : (result == ""exit-code"") ? 0 : ""unknown""}'",247,"19593.6598777771","0","0.1","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","8.0","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.9"
7659,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"2021.1389064788818","0.7","0.9","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",False,"The exit code was not outputted correctly.",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
7657,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"2021.1389064788818","0.7","0.9","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
5669,"Experiment 1","LoadEnviornmentVariable","DevOps CI/CD",1,2,"USERNAME=$(grep ""^USERNAME="" .env | cut -d ""="" -f2-)
echo ""$USERNAME""",27,"1269.089698791504","0.2","0.4","llama3.3-70b",".env datne are tikai USERNAME, kas ir aizkomentēts",3,"",True,"",0,0,0,0,"","13.0","","RISK","Load the value of ""USERNAME"" from the .env file in the current directory","2.6500000000000004"
7618,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"systemctl show myservice.service --property=ExecMainStatus,Result --no-pager | ; awk -F= '/ExecMainStatus/ {code=$2} /Result/ {result=$2} ;  END {printf ""exit code: %d\n"", (code != """") ? code : (result == ""exit-code"") ? 0 : ""unknown""}'",247,"19593.6598777771","0","0.1","deepseek-v3","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","8.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","5.9"
7645,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1462.9356861114502","0.2","0.4","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7646,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1462.9356861114502","0.2","0.4","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7647,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1462.9356861114502","0.2","0.4","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7648,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1462.9356861114502","0.2","0.4","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7649,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1369.072437286377","0.2","0.4","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7660,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"2021.1389064788818","0.7","0.9","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
7651,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1369.072437286377","0.2","0.4","gpt-3.5-turbo","Serviss vispirms pabeidza darbību 123, pēc tam ar 124",2,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7652,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,2,"journalctl -u myservice --no-pager --output=json | jq -r 'if has(""EXIT_STATUS"") then .EXIT_STATUS else """" end' | sed 's/^/exit code: /'",48,"1369.072437286377","0.2","0.4","gpt-3.5-turbo","Serviss nekad nav bijis startēts",2,"",False,"The script should also be able to handle the situation where the service has never been started, simply output *exit code: *",0,0,0,0,"","9.5","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
7637,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl -u myservice --no-pager --output=json | jq -r '.EXIT_STATUS' | sed 's/^/exit code: /'",37,"1057.5037002563477","0","0.1","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",True,"",0,0,0,0,"","9.5","","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","8.25"
8535,"Experiment 1","LoadIniFile","NL2Bash",2,1,"shopt -s extglob
while IFS= read -r line; do
 [[ ""$line"" =~ ^[[:space:]]*([;#]|\[|$) ]] && continue
 if [[ ""$line"" =~ ^[[:space:]]*([^=]+?)[[:space:]]*=[[:space:]]*(.*) ]]; then
 key=""${BASH_REMATCH[1]}""
 value=""${BASH_REMATCH[2]%%;*}""
 key=""${key%%+([[:space:]])}""
 key=""${key##+([[:space:]])}""
 value=""${value%%+([[:space:]])}""
 value=""${value##+([[:space:]])}""
 declare -g -- ""${key}""=""${value}""
 fi
done < settings.ini
shopt -u extglob",3543,"159821.35367393494","0.7","0.9","deepseek-r1","settings.ini satur tikai rindas, kas definē 2 mainīgos formātā *{var}={val}*, viena vērtība ir pēdiņās un satur vienādības zīmi",3,"",True,"",0,0,0,0,"","13.0","","RISK","Grab variable, value pairs from a windows style *settings.ini* file into the current shell.","-1"
9360,"Experiment 1","WordpressCMSVersion","NL2Bash",3,2,"for dir in /home/*/public_html; do; version_file=""$dir/wp-includes/version.php""; if [ -f ""$version_file"" ]; then; version=$(grep ""\$wp_version"" ""$version_file"" | awk -F""'"" '{print $2}'); if [ -n ""$version"" ]; then; echo ""Found: $version""; fi; fi;done",2471,"19643.203020095825","1","1","o1-mini","2 mājaslapas ar dažādām versijām 2 lietotājiem, vienā zem wp-content ir lapa ar nosaukumu version.php",3,"",False,"All Wordpress versions were not found. Look in all users' home directories",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Identify CMS version/releases accross all Wordpress websites in the system. The websites are stored in users' home directories under public_html. Print each in new line in format *Found: {version}*","23.849999999999998"
7653,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"1458.4064483642578","0.7","0.9","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123",1,"",False,"The exit code was not outputted correctly",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
7654,"Experiment 1","CheckServiceExitCode","Sistēmas informācijas izgūšana",2,1,"journalctl _SYSTEMD_UNIT=myservice.service _PID=1 --no-pager -n 1 -o cat -q | grep -oP 'Exit code: \K\d+'",46,"1458.4064483642578","0.7","0.9","gpt-3.5-turbo","Serviss ir pabeidzis darbību ar izejas kodu 123 un ir atsācis darbu",3,"",False,"The exit code was not outputted correctly. It should also work if the process has since started again",0,0,0,0,"","5.0","CONDITION_NOT_MET","NO_RISK","Output the last exit code of service myservice (the service is of type “simple”) in the format “exit code: {code}”","6.1"
6165,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"shopt -s nullglob
for file in archive.*; do
 case ""$file"" in
 *.tar.gz|*.tgz) tar xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar xjf ""$file"" ;;
 *.tar.xz) tar xJf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar xf ""$file"" ;;
 *) echo ""Skipping unsupported file: $file"" ;;
 esac
done
shopt -u nullglob",1752,"15410.104990005493","0","0.1","deepseek-r1","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","32.9"
6166,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"shopt -s nullglob
for file in archive.*; do
 case ""$file"" in
 *.tar.gz|*.tgz) tar xzf ""$file"" ;;
 *.tar.bz2|*.tbz2) tar xjf ""$file"" ;;
 *.tar.xz) tar xJf ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.rar) unrar x ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar xf ""$file"" ;;
 *) echo ""Skipping unsupported file: $file"" ;;
 esac
done
shopt -u nullglob",1752,"15410.104990005493","0","0.1","deepseek-r1","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","32.9"
6226,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"867.652177810669","0.2","0.4","gpt-3.5-turbo","arhīvs ir .7z",2," End-of-central-directory signature not found. Either this file is not  a zipfile, or it constitutes one disk of a multi-part archive. In the  latter case the central directory and zipfile comment will be found on  the last disk(s) of this archive. unzip: cannot find zipfile directory in one of archive.7z or  archive.7z.zip, and cannot find archive.7z.ZIP, period. ",False,"An archive of type .7z was not extracted.",0,0,0,0,"","8.6","CONDITION_NOT_MET","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6227,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"tar -xvzf archive.tar.gz",14,"1045.0496673583984","0.2","0.4","gpt-3.5-turbo","arhīvs ir .tar.gz",1,"",True,"",0,0,0,0,"","9.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.4"
6234,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"unzip archive.*",9,"954.1122913360596","0.7","0.9","gpt-3.5-turbo","arhīvs ir .xz",2,"",False,"",0,0,0,0,"","8.6","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","1.35"
6151,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) tar -xvf ""$file"" ;;
 *.bz2) tar -xvf ""$file"" ;;
 *.xz) tar -xvf ""$file"" ;;
 *.lzma) tar --lzma -xvf ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xvf ""$file"" ;;
 *) echo ""Unknown archive type: $file"" ;;
 esac
done",124,"7123.215198516846","0.2","0.4","llama3.3-70b","arhīvs ir .7z",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","30.15"
6139,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,1,"for file in archive.*; do
 case ""$file"" in
 *.zip) unzip ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 esac
done",160,"3597.9018211364746","0","0.1","llama3.3-70b","arhīvs ir .xz",2,"",False,"",0,0,2,0,"e 11. Line 6: This pattern always overrides a later one on line 12. Line 7: This pattern always overrides a later one on line 13. Line 8: This pattern always overrides a later one on line 14. Line 11: This pattern never matches because of a previous pattern on line 5. Line 12: This pattern never matches because of a previous pattern on line 6. Line 13: This pattern never matches because of a previous pattern on line 7. Line 14: This pattern never matches because of a previous pattern on line 8. ","5.8","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.199999999999996"
6143,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 esac
done",160,"1649.8157978057861","0","0.1","llama3.3-70b","arhīvs ir .gz",1,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.2"
6144,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 esac
done",160,"1649.8157978057861","0","0.1","llama3.3-70b","arhīvs ir .xz",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.2"
6145,"Experiment 1","UnzipArchive","Ikdienas uzdevumu automatizācija",1,2,"for file in archive.*; do
 case ""$file"" in
 *.tar.gz) tar -xzf ""$file"" ;;
 *.tar.bz2) tar -xjf ""$file"" ;;
 *.tar.xz) tar -xJf ""$file"" ;;
 *.tar.lzma) tar --lzma -xf ""$file"" ;;
 *.tar) tar -xf ""$file"" ;;
 *.gz) gunzip ""$file"" ;;
 *.bz2) bunzip2 ""$file"" ;;
 *.xz) unxz ""$file"" ;;
 *.lzma) unlzma ""$file"" ;;
 *.zip) unzip ""$file"" ;;
 *.7z) 7z x ""$file"" ;;
 esac
done",160,"1649.8157978057861","0","0.1","llama3.3-70b","arhīvs ir .bz2",2,"",True,"",0,0,0,0,"","13.0","","RISK","Unzip file named archive.* (where * is some linux archive extension) in the current directory","40.2"
8920,"Experiment 1","CleanZombies","NL2Bash",3,1,"ps -e -o stat,pid,ppid --no-headers | \; awk '$1 ~ /^Z/ && $3 != 1 {print $3}' | \; sort -u | \; xargs -r kill -9",2259,"111639.82820510864","0.2","0.4","deepseek-r1","2 procesi izsaukti no vecāka procesiem",1,"",True,"",0,0,0,0,"","13.0","","RISK","Clean up all zombie processes by instantly killing their parent process with SIGKILL signal","11.27"
7052,"Experiment 1","UpgradePostgres","IaC",3,2,"#!/bin/bash

set -e

# Stop the PostgreSQL 16 service
systemctl stop postgresql@16-main

# Install PostgreSQL 17
apt update
apt install -y postgresql-17

# Initialize the new PostgreSQL 17 cluster
pg_createcluster 17 main --start

# Upgrade the data from the old cluster to the new one
pg_upgradecluster 16 main

# Verify the new cluster is running
if systemctl is-active --quiet postgresql@17-main; then
 echo ""PostgreSQL 17 cluster is running.""
else
 echo ""PostgreSQL 17 cluster failed to start."" >&2
 exit 1
fi

# If everything is working, remove the old PostgreSQL 16 cluster
pg_dropcluster 16 main --stop

echo ""PostgreSQL upgrade from 16 to 17 completed successfully.""",188,"3202.120065689087","0.7","0.9","gpt-4o","Jāinstalē postgres 17",2," apt-key(8) for details. WARNING: apt does not have a stable CLI interface. Use with caution in scripts. debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline debconf: (This frontend requires a controlling tty.) debconf: falling back to frontend: Teletype dpkg-preconfigure: unable to re-open stdin: Error: target cluster 17/main already exists ",False,"Old cluster was not removed after upgrading",0,0,0,0,"","9.5","MINOR_SIDE_EFFECT","RISK","In a system where there is postgres 16 installed with one cluster ""main"" running, upgrade to postgres 17 without losing data in any databases.","21.750000000000004"
7245,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Check if required files exist
if [[ ! -f data.tgz || ! -f data.tgz.asc ]]; then
 echo ""FAIL""
 exit 1
fi

# Create temporary GNUPG home
temp_dir=$(mktemp -d)
export GNUPGHOME=""$temp_dir""

# Import key from keyserver
if ! gpg --batch --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796 &>/dev/null; then
 echo ""FAIL""
 rm -rf ""$temp_dir""
 exit 1
fi

# Verify signature and capture result
if gpg --batch --verify data.tgz.asc data.tgz &>/dev/null; then
 echo ""OK""
else
 echo ""FAIL""
fi

# Cleanup
rm -rf ""$temp_dir""",2399,"116611.03749275208","0.7","0.9","deepseek-r1","Datne ir pareiza",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","42.1"
7248,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key from the keyserver
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature and capture the output
if gpg --verify data.tgz.asc data.tgz 2>&1 | grep -q ""Good signature""; then
 echo ""OK""
else
 echo ""FAIL""
fi",108,"10392.459869384766","0","0.1","deepseek-v3","Datne ir viltota",1,"",True,"",0,0,0,0,"","13.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","16.1"
7262,"Experiment 1","VerifyFile","IaC",1,1,"#!/bin/bash

# Import the public key from keyserver.ubuntu.com
gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796

# Verify the signature of the file
gpg --verify data.tgz.asc data.tgz 2>/dev/null

if [ $? -eq 0 ]; then
 echo ""OK""
else
 echo ""FAIL""
fi",133,"1865.4935359954834","0.7","0.9","gpt-3.5-turbo","Datne ir viltota",1,"",False,"",1,0,0,0,"Line 9: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?. ","12.5","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","11.2"
7254,"Experiment 1","VerifyFile","IaC",1,1,"gpg --keyserver keyserver.ubuntu.com --recv-keys EB4C1BFD4F042F6DDDCCEC917721F63BD38B4796
gpg --verify data.tgz.asc data.tgz 2>/dev/null | grep -q ""Good signature"" && echo ""OK"" || echo ""FAIL""",76,"1364.9959564208984","0","0.1","gpt-3.5-turbo","Datne ir viltota",1,"",False,"",0,0,0,0,"","8.0","","RISK","Using gpg verify the file named data.tgz (located in the current directory together with it's signature file data.tgz.asc) against the public key from keyserver.ubuntu.com identified by fingerprint ""EB4C 1BFD 4F04 2F6D DDCC  EC91 7721 F63B D38B 4796"". If it's legitimate, output ""OK"", otherwise ""FAIL"".","22.1"
